import 'package:aboapp/features/subscriptions/domain/entities/subscription_entity.dart';
import 'package:aboapp/features/subscriptions/domain/usecases/add_subscription_usecase.dart';
import 'package:aboapp/features/subscriptions/domain/usecases/delete_subscription_usecase.dart';
import 'package:aboapp/features/subscriptions/domain/usecases/get_all_subscriptions_usecase.dart';
import 'package:aboapp/features/subscriptions/domain/usecases/update_subscription_usecase.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:injectable/injectable.dart';
import 'package:uuid/uuid.dart';

part 'subscription_state.dart';
part 'subscription_cubit.freezed.dart'; // Generated by Freezed

@injectable // Register with GetIt
class SubscriptionCubit extends Cubit<SubscriptionState> {
  final GetAllSubscriptionsUseCase _getAllSubscriptions;
  final AddSubscriptionUseCase _addSubscription;
  final UpdateSubscriptionUseCase _updateSubscription;
  final DeleteSubscriptionUseCase _deleteSubscription;
  final Uuid _uuid; // For generating IDs if needed for new entities

  // Store all fetched subscriptions internally to apply filters/sorting without re-fetching
  List<SubscriptionEntity> _masterSubscriptionList = [];

  SubscriptionCubit(
    this._getAllSubscriptions,
    this._addSubscription,
    this._updateSubscription,
    this._deleteSubscription,
    this._uuid, // Injected if Uuid is registered as a dependency, or instantiate here
  ) : super(const SubscriptionState.initial());

  Future<void> loadSubscriptions() async {
    emit(const SubscriptionState.loading());
    try {
      _masterSubscriptionList = await _getAllSubscriptions();
      // Apply default filters/sort before emitting loaded state
      _applyFiltersAndSort();
    } catch (e) {
      emit(SubscriptionState.error(message: e.toString()));
    }
  }

  Future<void> addSubscription(SubscriptionEntity subscription) async {
    // Ensure new subscriptions have a unique ID
    final subToAdd = subscription.id.isEmpty 
        ? subscription.copyWith(id: _uuid.v4()) 
        : subscription;
    
    emit(const SubscriptionState.loading()); // Optional: show loading during add
    try {
      await _addSubscription(subToAdd);
      _masterSubscriptionList.add(subToAdd); // Update master list
      _applyFiltersAndSort();
    } catch (e) {
      emit(SubscriptionState.error(message: "Failed to add subscription: ${e.toString()}"));
      // Optionally reload or revert to previous loaded state
      _applyFiltersAndSort(); // Re-emit previous loaded state or specific error state
    }
  }

  Future<void> updateSubscription(SubscriptionEntity subscription) async {
    emit(const SubscriptionState.loading()); // Optional
    try {
      await _updateSubscription(subscription);
      final index = _masterSubscriptionList.indexWhere((s) => s.id == subscription.id);
      if (index != -1) {
        _masterSubscriptionList[index] = subscription;
      } else {
        _masterSubscriptionList.add(subscription); // Or handle as error if update target not found
      }
      _applyFiltersAndSort();
    } catch (e) {
      emit(SubscriptionState.error(message: "Failed to update subscription: ${e.toString()}"));
      _applyFiltersAndSort();
    }
  }

  Future<void> deleteSubscription(String id) async {
    emit(const SubscriptionState.loading()); // Optional
    try {
      await _deleteSubscription(id);
      _masterSubscriptionList.removeWhere((s) => s.id == id);
      _applyFiltersAndSort();
    } catch (e) {
      emit(SubscriptionState.error(message: "Failed to delete subscription: ${e.toString()}"));
      _applyFiltersAndSort();
    }
  }
  
  Future<void> toggleSubscriptionActiveStatus(String id) async {
    final index = _masterSubscriptionList.indexWhere((s) => s.id == id);
    if (index != -1) {
      final sub = _masterSubscriptionList[index];
      final updatedSub = sub.copyWith(isActive: !sub.isActive);
      await updateSubscription(updatedSub); // This will handle loading state and re-filtering
    }
  }

  Future<void> toggleSubscriptionNotification(String id) async {
     final index = _masterSubscriptionList.indexWhere((s) => s.id == id);
    if (index != -1) {
      final sub = _masterSubscriptionList[index];
      final updatedSub = sub.copyWith(notificationsEnabled: !sub.notificationsEnabled);
      await updateSubscription(updatedSub);
    }
  }

  // Method to apply filters and sorting, then emit _Loaded state
  void _applyFiltersAndSort({
      SortOption? newSortOption,
      SubscriptionCategory? newFilterCategory,
      BillingCycle? newFilterBillingCycle,
      String? newSearchTerm,
      bool clearSearch = false,
  }) {
    // Get current state or defaults
    SortOption currentSortOption = state.maybeWhen(
        loaded: (alls, filters, sort, cat, bill, search) => sort ?? SortOption.nextBillingDateAsc,
        orElse: () => SortOption.nextBillingDateAsc);
    SubscriptionCategory? currentFilterCategory = state.maybeWhen(
        loaded: (alls, filters, sort, cat, bill, search) => cat, orElse: () => null);
    BillingCycle? currentFilterBillingCycle = state.maybeWhen(
        loaded: (alls, filters, sort, cat, bill, search) => bill, orElse: () => null);
    String? currentSearchTerm = state.maybeWhen(
        loaded: (alls, filters, sort, cat, bill, search) => search, orElse: () => null);

    // Update with new values if provided
    if (newSortOption != null) currentSortOption = newSortOption;
    if (newFilterCategory != null) currentFilterCategory = newFilterCategory;
    if (newFilterBillingCycle != null) currentFilterBillingCycle = newFilterBillingCycle;
    if (newSearchTerm != null) currentSearchTerm = newSearchTerm;
    if (clearSearch) currentSearchTerm = null;


    List<SubscriptionEntity> filtered = List.from(_masterSubscriptionList);

    // Apply search term
    if (currentSearchTerm != null && currentSearchTerm.isNotEmpty) {
      final query = currentSearchTerm.toLowerCase();
      filtered = filtered.where((sub) => 
        sub.name.toLowerCase().contains(query) || 
        (sub.description?.toLowerCase().contains(query) ?? false)
      ).toList();
    }

    // Apply category filter
    if (currentFilterCategory != null) {
      filtered = filtered.where((sub) => sub.category == currentFilterCategory).toList();
    }

    // Apply billing cycle filter
    if (currentFilterBillingCycle != null) {
      filtered = filtered.where((sub) => sub.billingCycle == currentFilterBillingCycle).toList();
    }
    
    // Apply sorting
    // Add all sorting options as per your SortOption enum
    switch (currentSortOption) {
      case SortOption.nameAsc:
        filtered.sort((a, b) => a.name.toLowerCase().compareTo(b.name.toLowerCase()));
        break;
      case SortOption.nameDesc:
        filtered.sort((a, b) => b.name.toLowerCase().compareTo(a.name.toLowerCase()));
        break;
      case SortOption.priceAsc:
        filtered.sort((a, b) => a.monthlyEquivalentPrice.compareTo(b.monthlyEquivalentPrice));
        break;
      case SortOption.priceDesc:
        filtered.sort((a, b) => b.monthlyEquivalentPrice.compareTo(a.monthlyEquivalentPrice));
        break;
      case SortOption.nextBillingDateAsc:
        filtered.sort((a, b) => a.nextBillingDate.compareTo(b.nextBillingDate));
        break;
      case SortOption.nextBillingDateDesc:
         filtered.sort((a, b) => b.nextBillingDate.compareTo(a.nextBillingDate));
        break;
      case SortOption.category:
        filtered.sort((a, b) => a.category.index.compareTo(b.category.index));
        break;
    }

    emit(SubscriptionState.loaded(
      allSubscriptions: _masterSubscriptionList,
      filteredSubscriptions: filtered,
      currentSortOption: currentSortOption,
      filterCategory: currentFilterCategory,
      filterBillingCycle: currentFilterBillingCycle,
      searchTerm: currentSearchTerm,
    ));
  }

  // Public methods to trigger filter/sort changes
  void changeSortOption(SortOption option) {
    _applyFiltersAndSort(newSortOption: option);
  }

  void filterByCategory(SubscriptionCategory? category) {
    _applyFiltersAndSort(newFilterCategory: category);
  }

  void filterByBillingCycle(BillingCycle? cycle) {
    _applyFiltersAndSort(newFilterBillingCycle: cycle);
  }

  void searchSubscriptions(String searchTerm) {
    _applyFiltersAndSort(newSearchTerm: searchTerm);
  }
   void clearSearch() {
    _applyFiltersAndSort(clearSearch: true, newSearchTerm: '');
  }

  void clearCategoryFilter() {
    _applyFiltersAndSort(newFilterCategory: null); // Pass null to effectively clear
  }

  void clearBillingCycleFilter() {
    _applyFiltersAndSort(newFilterBillingCycle: null); // Pass null to clear
  }

  void clearAllFilters() {
    _applyFiltersAndSort(
      newFilterCategory: null,
      newFilterBillingCycle: null,
      newSearchTerm: '', // Also clear search
      clearSearch: true,
    );
  }
}