============================================================
  PROJECT SUMMARY - Relevant files for project: C:\Hobby\aboapp_v4\aboapp_v4
  Generated: 2025-06-17 10:12:26
============================================================

===== FILE: analysis_options.yaml =====
===== PATH: analysis_options.yaml =====

# This file configures the analyzer, which statically analyzes Dart code to
# check for errors, warnings, and lints.
#
# The issues identified by the analyzer are surfaced in the UI of Dart-enabled
# IDEs (https://dart.dev/tools#ides-and-editors). The analyzer can also be
# invoked from the command line by running `flutter analyze`.

# The following line activates a set of recommended lints for Flutter apps,
# packages, and plugins designed to encourage good coding practices.
include: package:flutter_lints/flutter.yaml

linter:
  # The lint rules applied to this project can be customized in the
  # section below to disable rules from the `package:flutter_lints/flutter.yaml`
  # included above or to enable additional rules. A list of all available lints
  # and their documentation is published at https://dart.dev/lints.
  #
  # Instead of disabling a lint rule for the entire project in the
  # section below, it can also be suppressed for a single line of code
  # or a specific dart file by using the `// ignore: name_of_lint` and
  # `// ignore_for_file: name_of_lint` syntax on the line or in the file
  # producing the lint.
  rules:
    # avoid_print: false  # Uncomment to disable the `avoid_print` rule
    # prefer_single_quotes: true  # Uncomment to enable the `prefer_single_quotes` rule

# Additional information about this file can be found at
# https://dart.dev/guides/language/analysis-options


===== FILE: build.gradle.kts =====
===== PATH: android/app/build.gradle.kts =====

plugins {
    id("com.android.application")
    id("kotlin-android")
    // The Flutter Gradle Plugin must be applied after the Android and Kotlin Gradle plugins.
    id("dev.flutter.flutter-gradle-plugin")
}

android {
    namespace = "com.example.aboapp_v4"
    compileSdk = flutter.compileSdkVersion
    ndkVersion = flutter.ndkVersion

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_11
        targetCompatibility = JavaVersion.VERSION_11
    }

    kotlinOptions {
        jvmTarget = JavaVersion.VERSION_11.toString()
    }

    defaultConfig {
        // TODO: Specify your own unique Application ID (https://developer.android.com/studio/build/application-id.html).
        applicationId = "com.example.aboapp_v4"
        // You can update the following values to match your application needs.
        // For more information, see: https://flutter.dev/to/review-gradle-config.
        minSdk = flutter.minSdkVersion
        targetSdk = flutter.targetSdkVersion
        versionCode = flutter.versionCode
        versionName = flutter.versionName
    }

    buildTypes {
        release {
            // TODO: Add your own signing config for the release build.
            // Signing with the debug keys for now, so `flutter run --release` works.
            signingConfig = signingConfigs.getByName("debug")
        }
    }
}

flutter {
    source = "../.."
}


===== FILE: AndroidManifest.xml =====
===== PATH: android/app/src/main/AndroidManifest.xml =====

<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <application
        android:label="aboapp_v4"
        android:name="${applicationName}"
        android:icon="@mipmap/ic_launcher">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:launchMode="singleTop"
            android:taskAffinity=""
            android:theme="@style/LaunchTheme"
            android:configChanges="orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode"
            android:hardwareAccelerated="true"
            android:windowSoftInputMode="adjustResize">
            <!-- Specifies an Android theme to apply to this Activity as soon as
                 the Android process has started. This theme is visible to the user
                 while the Flutter UI initializes. After that, this theme continues
                 to determine the Window background behind the Flutter UI. -->
            <meta-data
              android:name="io.flutter.embedding.android.NormalTheme"
              android:resource="@style/NormalTheme"
              />
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
        <!-- Don't delete the meta-data below.
             This is used by the Flutter tool to generate GeneratedPluginRegistrant.java -->
        <meta-data
            android:name="flutterEmbedding"
            android:value="2" />
    </application>
    <!-- Required to query activities that can process text, see:
         https://developer.android.com/training/package-visibility and
         https://developer.android.com/reference/android/content/Intent#ACTION_PROCESS_TEXT.

         In particular, this is used by the Flutter engine in io.flutter.plugin.text.ProcessTextPlugin. -->
    <queries>
        <intent>
            <action android:name="android.intent.action.PROCESS_TEXT"/>
            <data android:mimeType="text/plain"/>
        </intent>
    </queries>
</manifest>


===== FILE: MainActivity.kt =====
===== PATH: android/app/src/main/kotlin/com/example/aboapp_v4/MainActivity.kt =====

package com.example.aboapp_v4

import io.flutter.embedding.android.FlutterActivity

class MainActivity : FlutterActivity()


===== FILE: launch_background.xml =====
===== PATH: android/app/src/main/res/drawable/launch_background.xml =====

<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="@android:color/white" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>


===== FILE: launch_background.xml =====
===== PATH: android/app/src/main/res/drawable-v21/launch_background.xml =====

<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="?android:colorBackground" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>


===== FILE: styles.xml =====
===== PATH: android/app/src/main/res/values/styles.xml =====

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is off -->
    <style name="LaunchTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>


===== FILE: styles.xml =====
===== PATH: android/app/src/main/res/values-night/styles.xml =====

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is on -->
    <style name="LaunchTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>


===== FILE: build.gradle.kts =====
===== PATH: android/build.gradle.kts =====

allprojects {
    repositories {
        google()
        mavenCentral()
    }
}

val newBuildDir: Directory = rootProject.layout.buildDirectory.dir("../../build").get()
rootProject.layout.buildDirectory.value(newBuildDir)

subprojects {
    val newSubprojectBuildDir: Directory = newBuildDir.dir(project.name)
    project.layout.buildDirectory.value(newSubprojectBuildDir)
}
subprojects {
    project.evaluationDependsOn(":app")
}

tasks.register<Delete>("clean") {
    delete(rootProject.layout.buildDirectory)
}


===== FILE: gradle.properties =====
===== PATH: android/gradle.properties =====

org.gradle.jvmargs=-Xmx8G -XX:MaxMetaspaceSize=4G -XX:ReservedCodeCacheSize=512m -XX:+HeapDumpOnOutOfMemoryError
android.useAndroidX=true
android.enableJetifier=true


===== FILE: settings.gradle.kts =====
===== PATH: android/settings.gradle.kts =====

pluginManagement {
    val flutterSdkPath = run {
        val properties = java.util.Properties()
        file("local.properties").inputStream().use { properties.load(it) }
        val flutterSdkPath = properties.getProperty("flutter.sdk")
        require(flutterSdkPath != null) { "flutter.sdk not set in local.properties" }
        flutterSdkPath
    }

    includeBuild("$flutterSdkPath/packages/flutter_tools/gradle")

    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}

plugins {
    id("dev.flutter.flutter-plugin-loader") version "1.0.0"
    id("com.android.application") version "8.7.0" apply false
    id("org.jetbrains.kotlin.android") version "1.8.22" apply false
}

include(":app")


===== FILE: project.pbxproj =====
===== PATH: ios/Runner.xcodeproj/project.pbxproj =====

// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 54;
	objects = {

/* Begin PBXBuildFile section */
		1498D2341E8E89220040F4C2 /* GeneratedPluginRegistrant.m in Sources */ = {isa = PBXBuildFile; fileRef = 1498D2331E8E89220040F4C2 /* GeneratedPluginRegistrant.m */; };
		331C808B294A63AB00263BE5 /* RunnerTests.swift in Sources */ = {isa = PBXBuildFile; fileRef = 331C807B294A618700263BE5 /* RunnerTests.swift */; };
		3B3967161E833CAA004F5970 /* AppFrameworkInfo.plist in Resources */ = {isa = PBXBuildFile; fileRef = 3B3967151E833CAA004F5970 /* AppFrameworkInfo.plist */; };
		74858FAF1ED2DC5600515810 /* AppDelegate.swift in Sources */ = {isa = PBXBuildFile; fileRef = 74858FAE1ED2DC5600515810 /* AppDelegate.swift */; };
		97C146FC1CF9000F007C117D /* Main.storyboard in Resources */ = {isa = PBXBuildFile; fileRef = 97C146FA1CF9000F007C117D /* Main.storyboard */; };
		97C146FE1CF9000F007C117D /* Assets.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = 97C146FD1CF9000F007C117D /* Assets.xcassets */; };
		97C147011CF9000F007C117D /* LaunchScreen.storyboard in Resources */ = {isa = PBXBuildFile; fileRef = 97C146FF1CF9000F007C117D /* LaunchScreen.storyboard */; };
/* End PBXBuildFile section */

/* Begin PBXContainerItemProxy section */
		331C8085294A63A400263BE5 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = 97C146E61CF9000F007C117D /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = 97C146ED1CF9000F007C117D;
			remoteInfo = Runner;
		};
/* End PBXContainerItemProxy section */

/* Begin PBXCopyFilesBuildPhase section */
		9705A1C41CF9048500538489 /* Embed Frameworks */ = {
			isa = PBXCopyFilesBuildPhase;
			buildActionMask = 2147483647;
			dstPath = "";
			dstSubfolderSpec = 10;
			files = (
			);
			name = "Embed Frameworks";
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXCopyFilesBuildPhase section */

/* Begin PBXFileReference section */
		1498D2321E8E86230040F4C2 /* GeneratedPluginRegistrant.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = GeneratedPluginRegistrant.h; sourceTree = "<group>"; };
		1498D2331E8E89220040F4C2 /* GeneratedPluginRegistrant.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GeneratedPluginRegistrant.m; sourceTree = "<group>"; };
		331C807B294A618700263BE5 /* RunnerTests.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = RunnerTests.swift; sourceTree = "<group>"; };
		331C8081294A63A400263BE5 /* RunnerTests.xctest */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = RunnerTests.xctest; sourceTree = BUILT_PRODUCTS_DIR; };
		3B3967151E833CAA004F5970 /* AppFrameworkInfo.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.xml; name = AppFrameworkInfo.plist; path = Flutter/AppFrameworkInfo.plist; sourceTree = "<group>"; };
		74858FAD1ED2DC5600515810 /* Runner-Bridging-Header.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = "Runner-Bridging-Header.h"; sourceTree = "<group>"; };
		74858FAE1ED2DC5600515810 /* AppDelegate.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = AppDelegate.swift; sourceTree = "<group>"; };
		7AFA3C8E1D35360C0083082E /* Release.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; name = Release.xcconfig; path = Flutter/Release.xcconfig; sourceTree = "<group>"; };
		9740EEB21CF90195004384FC /* Debug.xcconfig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.xcconfig; name = Debug.xcconfig; path = Flutter/Debug.xcconfig; sourceTree = "<group>"; };
		9740EEB31CF90195004384FC /* Generated.xcconfig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.xcconfig; name = Generated.xcconfig; path = Flutter/Generated.xcconfig; sourceTree = "<group>"; };
		97C146EE1CF9000F007C117D /* Runner.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = Runner.app; sourceTree = BUILT_PRODUCTS_DIR; };
		97C146FB1CF9000F007C117D /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.storyboard; name = Base; path = Base.lproj/Main.storyboard; sourceTree = "<group>"; };
		97C146FD1CF9000F007C117D /* Assets.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; path = Assets.xcassets; sourceTree = "<group>"; };
		97C147001CF9000F007C117D /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.storyboard; name = Base; path = Base.lproj/LaunchScreen.storyboard; sourceTree = "<group>"; };
		97C147021CF9000F007C117D /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
/* End PBXFileReference section */

/* Begin PBXFrameworksBuildPhase section */
		97C146EB1CF9000F007C117D /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXFrameworksBuildPhase section */

/* Begin PBXGroup section */
		331C8082294A63A400263BE5 /* RunnerTests */ = {
			isa = PBXGroup;
			children = (
				331C807B294A618700263BE5 /* RunnerTests.swift */,
			);
			path = RunnerTests;
			sourceTree = "<group>";
		};
		9740EEB11CF90186004384FC /* Flutter */ = {
			isa = PBXGroup;
			children = (
				3B3967151E833CAA004F5970 /* AppFrameworkInfo.plist */,
				9740EEB21CF90195004384FC /* Debug.xcconfig */,
				7AFA3C8E1D35360C0083082E /* Release.xcconfig */,
				9740EEB31CF90195004384FC /* Generated.xcconfig */,
			);
			name = Flutter;
			sourceTree = "<group>";
		};
		97C146E51CF9000F007C117D = {
			isa = PBXGroup;
			children = (
				9740EEB11CF90186004384FC /* Flutter */,
				97C146F01CF9000F007C117D /* Runner */,
				97C146EF1CF9000F007C117D /* Products */,
				331C8082294A63A400263BE5 /* RunnerTests */,
			);
			sourceTree = "<group>";
		};
		97C146EF1CF9000F007C117D /* Products */ = {
			isa = PBXGroup;
			children = (
				97C146EE1CF9000F007C117D /* Runner.app */,
				331C8081294A63A400263BE5 /* RunnerTests.xctest */,
			);
			name = Products;
			sourceTree = "<group>";
		};
		97C146F01CF9000F007C117D /* Runner */ = {
			isa = PBXGroup;
			children = (
				97C146FA1CF9000F007C117D /* Main.storyboard */,
				97C146FD1CF9000F007C117D /* Assets.xcassets */,
				97C146FF1CF9000F007C117D /* LaunchScreen.storyboard */,
				97C147021CF9000F007C117D /* Info.plist */,
				1498D2321E8E86230040F4C2 /* GeneratedPluginRegistrant.h */,
				1498D2331E8E89220040F4C2 /* GeneratedPluginRegistrant.m */,
				74858FAE1ED2DC5600515810 /* AppDelegate.swift */,
				74858FAD1ED2DC5600515810 /* Runner-Bridging-Header.h */,
			);
			path = Runner;
			sourceTree = "<group>";
		};
/* End PBXGroup section */

/* Begin PBXNativeTarget section */
		331C8080294A63A400263BE5 /* RunnerTests */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 331C8087294A63A400263BE5 /* Build configuration list for PBXNativeTarget "RunnerTests" */;
			buildPhases = (
				331C807D294A63A400263BE5 /* Sources */,
				331C807F294A63A400263BE5 /* Resources */,
			);
			buildRules = (
			);
			dependencies = (
				331C8086294A63A400263BE5 /* PBXTargetDependency */,
			);
			name = RunnerTests;
			productName = RunnerTests;
			productReference = 331C8081294A63A400263BE5 /* RunnerTests.xctest */;
			productType = "com.apple.product-type.bundle.unit-test";
		};
		97C146ED1CF9000F007C117D /* Runner */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 97C147051CF9000F007C117D /* Build configuration list for PBXNativeTarget "Runner" */;
			buildPhases = (
				9740EEB61CF901F6004384FC /* Run Script */,
				97C146EA1CF9000F007C117D /* Sources */,
				97C146EB1CF9000F007C117D /* Frameworks */,
				97C146EC1CF9000F007C117D /* Resources */,
				9705A1C41CF9048500538489 /* Embed Frameworks */,
				3B06AD1E1E4923F5004D2608 /* Thin Binary */,
			);
			buildRules = (
			);
			dependencies = (
			);
			name = Runner;
			productName = Runner;
			productReference = 97C146EE1CF9000F007C117D /* Runner.app */;
			productType = "com.apple.product-type.application";
		};
/* End PBXNativeTarget section */

/* Begin PBXProject section */
		97C146E61CF9000F007C117D /* Project object */ = {
			isa = PBXProject;
			attributes = {
				BuildIndependentTargetsInParallel = YES;
				LastUpgradeCheck = 1510;
				ORGANIZATIONNAME = "";
				TargetAttributes = {
					331C8080294A63A400263BE5 = {
						CreatedOnToolsVersion = 14.0;
						TestTargetID = 97C146ED1CF9000F007C117D;
					};
					97C146ED1CF9000F007C117D = {
						CreatedOnToolsVersion = 7.3.1;
						LastSwiftMigration = 1100;
					};
				};
			};
			buildConfigurationList = 97C146E91CF9000F007C117D /* Build configuration list for PBXProject "Runner" */;
			compatibilityVersion = "Xcode 9.3";
			developmentRegion = en;
			hasScannedForEncodings = 0;
			knownRegions = (
				en,
				Base,
			);
			mainGroup = 97C146E51CF9000F007C117D;
			productRefGroup = 97C146EF1CF9000F007C117D /* Products */;
			projectDirPath = "";
			projectRoot = "";
			targets = (
				97C146ED1CF9000F007C117D /* Runner */,
				331C8080294A63A400263BE5 /* RunnerTests */,
			);
		};
/* End PBXProject section */

/* Begin PBXResourcesBuildPhase section */
		331C807F294A63A400263BE5 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		97C146EC1CF9000F007C117D /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				97C147011CF9000F007C117D /* LaunchScreen.storyboard in Resources */,
				3B3967161E833CAA004F5970 /* AppFrameworkInfo.plist in Resources */,
				97C146FE1CF9000F007C117D /* Assets.xcassets in Resources */,
				97C146FC1CF9000F007C117D /* Main.storyboard in Resources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXResourcesBuildPhase section */

/* Begin PBXShellScriptBuildPhase section */
		3B06AD1E1E4923F5004D2608 /* Thin Binary */ = {
			isa = PBXShellScriptBuildPhase;
			alwaysOutOfDate = 1;
			buildActionMask = 2147483647;
			files = (
			);
			inputPaths = (
				"${TARGET_BUILD_DIR}/${INFOPLIST_PATH}",
			);
			name = "Thin Binary";
			outputPaths = (
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "/bin/sh \"$FLUTTER_ROOT/packages/flutter_tools/bin/xcode_backend.sh\" embed_and_thin";
		};
		9740EEB61CF901F6004384FC /* Run Script */ = {
			isa = PBXShellScriptBuildPhase;
			alwaysOutOfDate = 1;
			buildActionMask = 2147483647;
			files = (
			);
			inputPaths = (
			);
			name = "Run Script";
			outputPaths = (
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "/bin/sh \"$FLUTTER_ROOT/packages/flutter_tools/bin/xcode_backend.sh\" build";
		};
/* End PBXShellScriptBuildPhase section */

/* Begin PBXSourcesBuildPhase section */
		331C807D294A63A400263BE5 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				331C808B294A63AB00263BE5 /* RunnerTests.swift in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		97C146EA1CF9000F007C117D /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				74858FAF1ED2DC5600515810 /* AppDelegate.swift in Sources */,
				1498D2341E8E89220040F4C2 /* GeneratedPluginRegistrant.m in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXSourcesBuildPhase section */

/* Begin PBXTargetDependency section */
		331C8086294A63A400263BE5 /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = 97C146ED1CF9000F007C117D /* Runner */;
			targetProxy = 331C8085294A63A400263BE5 /* PBXContainerItemProxy */;
		};
/* End PBXTargetDependency section */

/* Begin PBXVariantGroup section */
		97C146FA1CF9000F007C117D /* Main.storyboard */ = {
			isa = PBXVariantGroup;
			children = (
				97C146FB1CF9000F007C117D /* Base */,
			);
			name = Main.storyboard;
			sourceTree = "<group>";
		};
		97C146FF1CF9000F007C117D /* LaunchScreen.storyboard */ = {
			isa = PBXVariantGroup;
			children = (
				97C147001CF9000F007C117D /* Base */,
			);
			name = LaunchScreen.storyboard;
			sourceTree = "<group>";
		};
/* End PBXVariantGroup section */

/* Begin XCBuildConfiguration section */
		249021D3217E4FDB00AE95B9 /* Profile */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++0x";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GCC_C_LANGUAGE_STANDARD = gnu99;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 12.0;
				MTL_ENABLE_DEBUG_INFO = NO;
				SDKROOT = iphoneos;
				SUPPORTED_PLATFORMS = iphoneos;
				TARGETED_DEVICE_FAMILY = "1,2";
				VALIDATE_PRODUCT = YES;
			};
			name = Profile;
		};
		249021D4217E4FDB00AE95B9 /* Profile */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 7AFA3C8E1D35360C0083082E /* Release.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CURRENT_PROJECT_VERSION = "$(FLUTTER_BUILD_NUMBER)";
				ENABLE_BITCODE = NO;
				INFOPLIST_FILE = Runner/Info.plist;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				PRODUCT_BUNDLE_IDENTIFIER = com.example.aboappV4;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_OBJC_BRIDGING_HEADER = "Runner/Runner-Bridging-Header.h";
				SWIFT_VERSION = 5.0;
				VERSIONING_SYSTEM = "apple-generic";
			};
			name = Profile;
		};
		331C8088294A63A400263BE5 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.example.aboappV4.RunnerTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_ACTIVE_COMPILATION_CONDITIONS = DEBUG;
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
				SWIFT_VERSION = 5.0;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/Runner.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/Runner";
			};
			name = Debug;
		};
		331C8089294A63A400263BE5 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.example.aboappV4.RunnerTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_VERSION = 5.0;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/Runner.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/Runner";
			};
			name = Release;
		};
		331C808A294A63A400263BE5 /* Profile */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.example.aboappV4.RunnerTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_VERSION = 5.0;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/Runner.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/Runner";
			};
			name = Profile;
		};
		97C147031CF9000F007C117D /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++0x";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = dwarf;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_TESTABILITY = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GCC_C_LANGUAGE_STANDARD = gnu99;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"DEBUG=1",
					"$(inherited)",
				);
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 12.0;
				MTL_ENABLE_DEBUG_INFO = YES;
				ONLY_ACTIVE_ARCH = YES;
				SDKROOT = iphoneos;
				TARGETED_DEVICE_FAMILY = "1,2";
			};
			name = Debug;
		};
		97C147041CF9000F007C117D /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++0x";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GCC_C_LANGUAGE_STANDARD = gnu99;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 12.0;
				MTL_ENABLE_DEBUG_INFO = NO;
				SDKROOT = iphoneos;
				SUPPORTED_PLATFORMS = iphoneos;
				SWIFT_COMPILATION_MODE = wholemodule;
				SWIFT_OPTIMIZATION_LEVEL = "-O";
				TARGETED_DEVICE_FAMILY = "1,2";
				VALIDATE_PRODUCT = YES;
			};
			name = Release;
		};
		97C147061CF9000F007C117D /* Debug */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 9740EEB21CF90195004384FC /* Debug.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CURRENT_PROJECT_VERSION = "$(FLUTTER_BUILD_NUMBER)";
				ENABLE_BITCODE = NO;
				INFOPLIST_FILE = Runner/Info.plist;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				PRODUCT_BUNDLE_IDENTIFIER = com.example.aboappV4;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_OBJC_BRIDGING_HEADER = "Runner/Runner-Bridging-Header.h";
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
				SWIFT_VERSION = 5.0;
				VERSIONING_SYSTEM = "apple-generic";
			};
			name = Debug;
		};
		97C147071CF9000F007C117D /* Release */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 7AFA3C8E1D35360C0083082E /* Release.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CURRENT_PROJECT_VERSION = "$(FLUTTER_BUILD_NUMBER)";
				ENABLE_BITCODE = NO;
				INFOPLIST_FILE = Runner/Info.plist;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				PRODUCT_BUNDLE_IDENTIFIER = com.example.aboappV4;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_OBJC_BRIDGING_HEADER = "Runner/Runner-Bridging-Header.h";
				SWIFT_VERSION = 5.0;
				VERSIONING_SYSTEM = "apple-generic";
			};
			name = Release;
		};
/* End XCBuildConfiguration section */

/* Begin XCConfigurationList section */
		331C8087294A63A400263BE5 /* Build configuration list for PBXNativeTarget "RunnerTests" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				331C8088294A63A400263BE5 /* Debug */,
				331C8089294A63A400263BE5 /* Release */,
				331C808A294A63A400263BE5 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		97C146E91CF9000F007C117D /* Build configuration list for PBXProject "Runner" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				97C147031CF9000F007C117D /* Debug */,
				97C147041CF9000F007C117D /* Release */,
				249021D3217E4FDB00AE95B9 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		97C147051CF9000F007C117D /* Build configuration list for PBXNativeTarget "Runner" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				97C147061CF9000F007C117D /* Debug */,
				97C147071CF9000F007C117D /* Release */,
				249021D4217E4FDB00AE95B9 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
/* End XCConfigurationList section */
	};
	rootObject = 97C146E61CF9000F007C117D /* Project object */;
}


===== FILE: AppDelegate.swift =====
===== PATH: ios/Runner/AppDelegate.swift =====

import Flutter
import UIKit

@main
@objc class AppDelegate: FlutterAppDelegate {
  override func application(
    _ application: UIApplication,
    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
  ) -> Bool {
    GeneratedPluginRegistrant.register(with: self)
    return super.application(application, didFinishLaunchingWithOptions: launchOptions)
  }
}


===== FILE: Contents.json =====
===== PATH: ios/Runner/Assets.xcassets/AppIcon.appiconset/Contents.json =====

{
  "images" : [
    {
      "size" : "20x20",
      "idiom" : "iphone",
      "filename" : "Icon-App-20x20@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "20x20",
      "idiom" : "iphone",
      "filename" : "Icon-App-20x20@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "40x40",
      "idiom" : "iphone",
      "filename" : "Icon-App-40x40@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "40x40",
      "idiom" : "iphone",
      "filename" : "Icon-App-40x40@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "60x60",
      "idiom" : "iphone",
      "filename" : "Icon-App-60x60@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "60x60",
      "idiom" : "iphone",
      "filename" : "Icon-App-60x60@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "20x20",
      "idiom" : "ipad",
      "filename" : "Icon-App-20x20@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "20x20",
      "idiom" : "ipad",
      "filename" : "Icon-App-20x20@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "29x29",
      "idiom" : "ipad",
      "filename" : "Icon-App-29x29@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "29x29",
      "idiom" : "ipad",
      "filename" : "Icon-App-29x29@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "40x40",
      "idiom" : "ipad",
      "filename" : "Icon-App-40x40@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "40x40",
      "idiom" : "ipad",
      "filename" : "Icon-App-40x40@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "76x76",
      "idiom" : "ipad",
      "filename" : "Icon-App-76x76@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "76x76",
      "idiom" : "ipad",
      "filename" : "Icon-App-76x76@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "83.5x83.5",
      "idiom" : "ipad",
      "filename" : "Icon-App-83.5x83.5@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "1024x1024",
      "idiom" : "ios-marketing",
      "filename" : "Icon-App-1024x1024@1x.png",
      "scale" : "1x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}


===== FILE: Contents.json =====
===== PATH: ios/Runner/Assets.xcassets/LaunchImage.imageset/Contents.json =====

{
  "images" : [
    {
      "idiom" : "universal",
      "filename" : "LaunchImage.png",
      "scale" : "1x"
    },
    {
      "idiom" : "universal",
      "filename" : "LaunchImage@2x.png",
      "scale" : "2x"
    },
    {
      "idiom" : "universal",
      "filename" : "LaunchImage@3x.png",
      "scale" : "3x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}


===== FILE: Info.plist =====
===== PATH: ios/Runner/Info.plist =====

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>$(DEVELOPMENT_LANGUAGE)</string>
	<key>CFBundleDisplayName</key>
	<string>Aboapp V4</string>
	<key>CFBundleExecutable</key>
	<string>$(EXECUTABLE_NAME)</string>
	<key>CFBundleIdentifier</key>
	<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>aboapp_v4</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>$(FLUTTER_BUILD_NAME)</string>
	<key>CFBundleSignature</key>
	<string>????</string>
	<key>CFBundleVersion</key>
	<string>$(FLUTTER_BUILD_NUMBER)</string>
	<key>LSRequiresIPhoneOS</key>
	<true/>
	<key>UILaunchStoryboardName</key>
	<string>LaunchScreen</string>
	<key>UIMainStoryboardFile</key>
	<string>Main</string>
	<key>UISupportedInterfaceOrientations</key>
	<array>
		<string>UIInterfaceOrientationPortrait</string>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
	</array>
	<key>UISupportedInterfaceOrientations~ipad</key>
	<array>
		<string>UIInterfaceOrientationPortrait</string>
		<string>UIInterfaceOrientationPortraitUpsideDown</string>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
	</array>
	<key>CADisableMinimumFrameDurationOnPhone</key>
	<true/>
	<key>UIApplicationSupportsIndirectInputEvents</key>
	<true/>
</dict>
</plist>


===== FILE: Runner-Bridging-Header.h =====
===== PATH: ios/Runner/Runner-Bridging-Header.h =====

#import "GeneratedPluginRegistrant.h"


===== FILE: app.dart =====
===== PATH: lib/app.dart =====

// lib/app.dart

import 'package:aboapp/core/di/injection.dart';
import 'package:aboapp/core/routing/app_router.dart';
// VEREINFACHT: Nur noch ein Theme importieren
import 'package:aboapp/core/theme/app_theme.dart';
import 'package:aboapp/features/settings/presentation/cubit/settings_cubit.dart';
import 'package:aboapp/features/statistics/presentation/cubit/statistics_cubit.dart';
import 'package:aboapp/features/subscriptions/presentation/cubit/subscription_cubit.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:aboapp/core/localization/app_localizations.dart';

class AboApp extends StatelessWidget {
  const AboApp({super.key});

  @override
  Widget build(BuildContext context) {
    final appRouter = getIt<AppRouter>();

    return MultiBlocProvider(
      providers: [
        BlocProvider<SettingsCubit>(
          create: (context) => getIt<SettingsCubit>()..loadSettings(),
        ),
        BlocProvider<SubscriptionCubit>(
          create: (context) => getIt<SubscriptionCubit>()..loadSubscriptions(),
        ),
        BlocProvider<StatisticsCubit>(
          create: (context) => getIt<StatisticsCubit>(),
        ),
      ],
      child: BlocBuilder<SettingsCubit, SettingsState>(
        builder: (context, settingsState) {
          return MaterialApp.router(
            title: 'AboApp V4',
            debugShowCheckedModeBanner: false,
            // VEREINFACHT: Wir verwenden jetzt immer das AppTheme.
            theme: AppTheme.lightTheme,
            darkTheme: AppTheme.darkTheme,
            themeMode: settingsState.themeMode,
            routerConfig: appRouter.config(),
            locale: settingsState.locale,
            supportedLocales: const [
              Locale('en', 'US'),
              Locale('de', 'DE'),
            ],
            localizationsDelegates: const [
              AppLocalizations.delegate,
              GlobalMaterialLocalizations.delegate,
              GlobalWidgetsLocalizations.delegate,
              GlobalCupertinoLocalizations.delegate,
            ],
            localeResolutionCallback: (locale, supportedLocales) {
              for (var supportedLocale in supportedLocales) {
                if (supportedLocale.languageCode == locale?.languageCode) {
                  return supportedLocale;
                }
              }
              return supportedLocales.first;
            },
          );
        },
      ),
    );
  }
}


===== FILE: injection.config.dart =====
===== PATH: lib/core/di/injection.config.dart =====

// dart format width=80
// GENERATED CODE - DO NOT MODIFY BY HAND

// **************************************************************************
// InjectableConfigGenerator
// **************************************************************************

// ignore_for_file: type=lint
// coverage:ignore-file

// ignore_for_file: no_leading_underscores_for_library_prefixes
import 'package:get_it/get_it.dart' as _i174;
import 'package:injectable/injectable.dart' as _i526;
import 'package:shared_preferences/shared_preferences.dart' as _i460;
import 'package:uuid/uuid.dart' as _i706;

import '../../features/settings/data/datasources/settings_local_datasource.dart'
    as _i723;
import '../../features/settings/data/repositories/settings_repository_impl.dart'
    as _i955;
import '../../features/settings/domain/repositories/settings_repository.dart'
    as _i674;
import '../../features/settings/domain/usecases/get_settings_usecase.dart'
    as _i1029;
import '../../features/settings/domain/usecases/save_currency_setting_usecase.dart'
    as _i851;
import '../../features/settings/domain/usecases/save_locale_setting_usecase.dart'
    as _i682;
import '../../features/settings/domain/usecases/save_salary_settings_usecase.dart'
    as _i969;
import '../../features/settings/domain/usecases/save_theme_setting_usecase.dart'
    as _i150;
import '../../features/settings/presentation/cubit/settings_cubit.dart'
    as _i792;
import '../../features/subscriptions/data/datasources/subscription_local_datasource.dart'
    as _i327;
import '../../features/subscriptions/data/repositories/subscription_repository_impl.dart'
    as _i944;
import '../../features/subscriptions/domain/repositories/subscription_repository.dart'
    as _i384;
import '../../features/subscriptions/domain/usecases/add_subscription_usecase.dart'
    as _i734;
import '../../features/subscriptions/domain/usecases/delete_subscription_usecase.dart'
    as _i170;
import '../../features/subscriptions/domain/usecases/get_all_subscriptions_usecase.dart'
    as _i899;
import '../../features/subscriptions/domain/usecases/update_subscription_usecase.dart'
    as _i684;
import '../../features/subscriptions/presentation/cubit/subscription_cubit.dart'
    as _i854;
import '../routing/app_router.dart' as _i282;
import 'injection.dart' as _i464;

// initializes the registration of main-scope dependencies inside of GetIt
Future<_i174.GetIt> $initGetIt(
  _i174.GetIt getIt, {
  String? environment,
  _i526.EnvironmentFilter? environmentFilter,
}) async {
  final gh = _i526.GetItHelper(
    getIt,
    environment,
    environmentFilter,
  );
  final registerExternalDependencies = _$RegisterExternalDependencies();
  await gh.singletonAsync<_i460.SharedPreferences>(
    () => registerExternalDependencies.sharedPreferences,
    preResolve: true,
  );
  gh.lazySingleton<_i706.Uuid>(() => registerExternalDependencies.uuid);
  gh.singleton<_i282.AppRouter>(
      () => _i282.AppRouter(gh<_i460.SharedPreferences>()));
  gh.lazySingleton<_i723.SettingsLocalDataSource>(
      () => _i723.SettingsLocalDataSourceImpl(gh<_i460.SharedPreferences>()));
  gh.lazySingleton<_i674.SettingsRepository>(
      () => _i955.SettingsRepositoryImpl(gh<_i723.SettingsLocalDataSource>()));
  gh.lazySingleton<_i327.SubscriptionLocalDataSource>(() =>
      _i327.SubscriptionLocalDataSourceImpl(gh<_i460.SharedPreferences>()));
  gh.lazySingleton<_i384.SubscriptionRepository>(() =>
      _i944.SubscriptionRepositoryImpl(
          localDataSource: gh<_i327.SubscriptionLocalDataSource>()));
  gh.lazySingleton<_i1029.GetSettingsUseCase>(
      () => _i1029.GetSettingsUseCase(gh<_i674.SettingsRepository>()));
  gh.lazySingleton<_i851.SaveCurrencySettingUseCase>(
      () => _i851.SaveCurrencySettingUseCase(gh<_i674.SettingsRepository>()));
  gh.lazySingleton<_i682.SaveLocaleSettingUseCase>(
      () => _i682.SaveLocaleSettingUseCase(gh<_i674.SettingsRepository>()));
  gh.lazySingleton<_i969.SaveSalarySettingsUseCase>(
      () => _i969.SaveSalarySettingsUseCase(gh<_i674.SettingsRepository>()));
  gh.lazySingleton<_i150.SaveThemeSettingUseCase>(
      () => _i150.SaveThemeSettingUseCase(gh<_i674.SettingsRepository>()));
  gh.factory<_i792.SettingsCubit>(() => _i792.SettingsCubit(
        gh<_i1029.GetSettingsUseCase>(),
        gh<_i150.SaveThemeSettingUseCase>(),
        gh<_i682.SaveLocaleSettingUseCase>(),
        gh<_i851.SaveCurrencySettingUseCase>(),
        gh<_i969.SaveSalarySettingsUseCase>(),
      ));
  gh.lazySingleton<_i734.AddSubscriptionUseCase>(
      () => _i734.AddSubscriptionUseCase(gh<_i384.SubscriptionRepository>()));
  gh.lazySingleton<_i170.DeleteSubscriptionUseCase>(() =>
      _i170.DeleteSubscriptionUseCase(gh<_i384.SubscriptionRepository>()));
  gh.lazySingleton<_i899.GetAllSubscriptionsUseCase>(() =>
      _i899.GetAllSubscriptionsUseCase(gh<_i384.SubscriptionRepository>()));
  gh.lazySingleton<_i684.UpdateSubscriptionUseCase>(() =>
      _i684.UpdateSubscriptionUseCase(gh<_i384.SubscriptionRepository>()));
  gh.factory<_i854.SubscriptionCubit>(() => _i854.SubscriptionCubit(
        gh<_i899.GetAllSubscriptionsUseCase>(),
        gh<_i734.AddSubscriptionUseCase>(),
        gh<_i684.UpdateSubscriptionUseCase>(),
        gh<_i170.DeleteSubscriptionUseCase>(),
        gh<_i706.Uuid>(),
      ));
  return getIt;
}

class _$RegisterExternalDependencies
    extends _i464.RegisterExternalDependencies {}


===== FILE: injection.dart =====
===== PATH: lib/core/di/injection.dart =====

// lib/core/di/injection.dart

import 'package:get_it/get_it.dart';
import 'package:injectable/injectable.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:uuid/uuid.dart';
import 'injection.config.dart';

final getIt = GetIt.instance;

@InjectableInit(
  initializerName: r'$initGetIt',
  preferRelativeImports: true,
  asExtension: false,
)
// Die Funktion muss async sein, da @preResolve die generierte
// init-Funktion asynchron macht.
Future<void> configureDependencies() async => await $initGetIt(getIt);

// Wir registrieren SharedPreferences jetzt hier im Modul,
// anstatt manuell in der configureDependencies-Funktion.
@module
abstract class RegisterExternalDependencies {
  @lazySingleton
  Uuid get uuid => const Uuid();

  // NEU: Asynchrone Factory für SharedPreferences.
  // @preResolve weist den Generator an, auf das Future zu warten.
  @preResolve
  @singleton
  Future<SharedPreferences> get sharedPreferences =>
      SharedPreferences.getInstance();
}


===== FILE: app_localizations.dart =====
===== PATH: lib/core/localization/app_localizations.dart =====

import 'dart:async';
import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

class AppLocalizations {
  final Locale locale;
  Map<String, String> _localizedStrings = {};

  AppLocalizations(this.locale);

  static AppLocalizations? of(BuildContext context) {
    return Localizations.of<AppLocalizations>(context, AppLocalizations);
  }

  static const LocalizationsDelegate<AppLocalizations> delegate = _AppLocalizationsDelegate();

  Future<bool> load() async {
    String jsonString = await rootBundle.loadString('assets/l10n/${locale.languageCode}.json');
    Map<String, dynamic> jsonMap = json.decode(jsonString);

    _localizedStrings = jsonMap.map((key, value) {
      return MapEntry(key, value.toString());
    });

    return true;
  }

  String translate(String key, {Map<String, String>? args}) {
    String? translation = _localizedStrings[key];
    if (translation == null) {
      // Fallback or error handling
      // print('Localization Error: Key "$key" not found for locale "${locale.languageCode}"'); // Avoid print
      return key; 
    }

    if (args != null && args.isNotEmpty) {
      args.forEach((argKey, argValue) {
        translation = translation!.replaceAll('{$argKey}', argValue);
      });
    }
    return translation!;
  }
}

class _AppLocalizationsDelegate extends LocalizationsDelegate<AppLocalizations> {
  const _AppLocalizationsDelegate();

  @override
  bool isSupported(Locale locale) {
    return ['en', 'de'].contains(locale.languageCode);
  }

  @override
  Future<AppLocalizations> load(Locale locale) async {
    AppLocalizations localizations = AppLocalizations(locale);
    await localizations.load();
    return localizations;
  }

  @override
  bool shouldReload(_AppLocalizationsDelegate old) => false;
}

===== FILE: app_router.dart =====
===== PATH: lib/core/routing/app_router.dart =====

// lib/core/routing/app_router.dart

import 'package:aboapp/features/onboarding/presentation/screens/onboarding_screen.dart';
import 'package:aboapp/features/subscriptions/domain/entities/subscription_entity.dart';
import 'package:aboapp/features/subscriptions/presentation/screens/add_edit_subscription_screen.dart';
import 'package:aboapp/main_container_screen.dart';
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:injectable/injectable.dart';
import 'package:shared_preferences/shared_preferences.dart';

abstract class AppRoutes {
  static const String onboarding = '/onboarding';
  static const String home = '/home';
  static const String statistics = '/statistics';
  static const String settings = '/settings';
  static const String addSubscription = 'add';
  static const String editSubscription = 'edit/:id';
}

@singleton
class AppRouter {
  final SharedPreferences _sharedPreferences;

  AppRouter(this._sharedPreferences);

  static final _rootNavigatorKey = GlobalKey<NavigatorState>();

  GoRouter config() {
    final bool onboardingComplete =
        _sharedPreferences.getBool('onboarding_complete') ?? false;

    return GoRouter(
      navigatorKey: _rootNavigatorKey,
      initialLocation:
          onboardingComplete ? AppRoutes.home : AppRoutes.onboarding,
      debugLogDiagnostics: true,
      routes: [
        GoRoute(
          path: AppRoutes.onboarding,
          name: AppRoutes.onboarding,
          builder: (context, state) => const OnboardingScreen(),
        ),
        ShellRoute(
          builder: (context, state, child) {
            return MainContainerScreen(location: state.uri.toString());
          },
          routes: [
            GoRoute(
              path: AppRoutes.home,
              name: AppRoutes.home,
              builder: (context, state) => const SizedBox.shrink(),
              routes: [
                _buildModalSubRoute(AppRoutes.addSubscription,
                    (context, state) => const AddEditSubscriptionScreen()),
                _buildModalSubRoute(AppRoutes.editSubscription,
                    (context, state) {
                  final subscription = state.extra as SubscriptionEntity?;
                  // The AddEditSubscriptionScreen expects the 'initialSubscription'
                  // parameter. We pass the subscription object received via `state.extra`.
                  return AddEditSubscriptionScreen(
                    initialSubscription: subscription,
                  );
                }),
              ],
            ),
            GoRoute(
              path: AppRoutes.statistics,
              name: AppRoutes.statistics,
              builder: (context, state) => const SizedBox.shrink(),
            ),
            GoRoute(
              path: AppRoutes.settings,
              name: AppRoutes.settings,
              builder: (context, state) => const SizedBox.shrink(),
            ),
          ],
        ),
      ],
      errorBuilder: (context, state) => Scaffold(
        appBar: AppBar(title: const Text('Page Not Found')),
        body: Center(child: Text('Error: \n${state.error}')),
      ),
    );
  }

  static GoRoute _buildModalSubRoute(
      String path, Widget Function(BuildContext, GoRouterState) builder) {
    return GoRoute(
      path: path,
      name: path,
      parentNavigatorKey: _rootNavigatorKey,
      builder: builder,
    );
  }
}


===== FILE: app_colors.dart =====
===== PATH: lib/core/theme/app_colors.dart =====

import 'package:flutter/material.dart';

// This class is not meant to be instantiated.
// It holds static color definitions for the app.
abstract class AppColors {
  // Primary Palette
  static const Color primary = Color(0xFF8B5CF6); // Purple
  static const Color primaryLight = Color(0xFFA78BFA);
  static const Color primaryDark = Color(0xFF7C3AED);
  static const Color onPrimary = Colors.white;

  // Accent/Secondary Palette (Can be same as primary or different)
  static const Color accent = Color(0xFFEC4899); // Pink, as an example accent
  static const Color onAccent = Colors.white;

  // Background & Surface Colors
  static const Color backgroundLight = Color(0xFFF9FAFB); // Off-white
  static const Color surfaceLight = Colors.white;
  static const Color onSurfaceLight = Color(0xFF1F2937); // Dark Gray
  static const Color onSurfaceVariantLight = Color(0xFF6B7280); // Medium Gray

  static const Color backgroundDark = Color(0xFF111827); // Very Dark Blue/Gray
  static const Color surfaceDark = Color(0xFF1F2937); // Dark Gray
  static const Color onSurfaceDark = Color(0xFFF3F4F6); // Light Gray
  static const Color onSurfaceVariantDark = Color(0xFF9CA3AF); // Medium-Light Gray

  // Semantic Colors
  static const Color error = Color(0xFFEF4444); // Red
  static const Color onError = Colors.white;
  static const Color success = Color(0xFF10B981); // Green
  static const Color onSuccess = Colors.white;
  static const Color warning = Color(0xFFF59E0B); // Amber
  static const Color onWarning = Colors.black; // Or white depending on contrast
  static const Color info = Color(0xFF3B82F6); // Blue
  static const Color onInfo = Colors.white;

  // Neutral/Border Colors
  static const Color borderLight = Color(0xFFE5E7EB);
  static const Color borderDark = Color(0xFF374151);

  // Subscription Category Colors (example, can be moved or expanded)
  static const Color catStreaming = Color(0xFFEF4444); // Red
  static const Color catSoftware = Color(0xFF8B5CF6); // Purple (same as primary)
  static const Color catGaming = Color(0xFF10B981);   // Green
  static const Color catFitness = Color(0xFFF59E0B);  // Amber
  static const Color catMusic = Color(0xFF3B82F6);    // Blue
  static const Color catNews = Color(0xFF6366F1);     // Indigo
  static const Color catCloud = Color(0xFF06B6D4);    // Cyan
  static const Color catOther = Color(0xFF6B7280);    // Gray
}

===== FILE: app_theme.dart =====
===== PATH: lib/core/theme/app_theme.dart =====

// lib/core/theme/app_theme.dart

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:aboapp/core/theme/app_typography.dart';

// VEREINFACHT: Nur noch eine Theme-Klasse für die gesamte App.
abstract class AppTheme {
  static const Color _primary =
      Color(0xFF000000); // Accent is Black in Light Mode
  static const Color _primaryDark =
      Color(0xFFFFFFFF); // Accent is White in Dark Mode

  // --- Light Mode Colors - MIT MEHR KONTRAST ---
  static const Color _backgroundLight = Color(0xFFF2F2F7);
  static const Color _surfaceLight = Colors.white;
  static const Color _onSurfaceLight = Color(0xFF121212);
  static const Color _onSurfaceVariantLight = Color(0xFF3C3C43);
  static const Color _borderLight = Color(0xFFE5E5E5);

  // --- Dark Mode Colors ---
  static const Color _backgroundDark = Color(0xFF000000);
  static const Color _surfaceDark = Color(0xFF1C1C1E);
  static const Color _onSurfaceDark = Color(0xFFE5E5EA);
  static const Color _onSurfaceVariantDark = Color(0xFF8A8A8E);

  static final _cardShapeLight = RoundedRectangleBorder(
    borderRadius: const BorderRadius.all(Radius.circular(20.0)),
    side: BorderSide(color: _borderLight.withOpacity(0.7), width: 1.0),
  );

  static const _cardShapeDark = RoundedRectangleBorder(
    borderRadius: BorderRadius.all(Radius.circular(20.0)),
  );

  static ThemeData get lightTheme {
    return _baseTheme(
      brightness: Brightness.light,
      backgroundColor: _backgroundLight,
      scaffoldColor: _backgroundLight,
      surfaceColor: _surfaceLight,
      onSurfaceColor: _onSurfaceLight,
      onSurfaceVariantColor: _onSurfaceVariantLight,
      primaryColor: _primary,
      onPrimaryColor: _surfaceLight,
      appBarColor: _backgroundLight,
      cardShape: _cardShapeLight,
      borderColor: _borderLight,
    );
  }

  static ThemeData get darkTheme {
    return _baseTheme(
      brightness: Brightness.dark,
      backgroundColor: _backgroundDark,
      scaffoldColor: _backgroundDark,
      surfaceColor: _surfaceDark,
      onSurfaceColor: _onSurfaceDark,
      onSurfaceVariantColor: _onSurfaceVariantDark,
      primaryColor: _primaryDark,
      onPrimaryColor: _backgroundDark,
      appBarColor: _backgroundDark,
      cardShape: _cardShapeDark,
      borderColor: Colors.transparent,
    );
  }

  static ThemeData _baseTheme({
    required Brightness brightness,
    required Color backgroundColor,
    required Color scaffoldColor,
    required Color surfaceColor,
    required Color onSurfaceColor,
    required Color onSurfaceVariantColor,
    required Color primaryColor,
    required Color onPrimaryColor,
    required Color appBarColor,
    required ShapeBorder cardShape,
    required Color borderColor,
  }) {
    final textTheme = _buildTextTheme(
        base: ThemeData(brightness: brightness).textTheme,
        onSurfaceColor: onSurfaceColor);

    return ThemeData(
      useMaterial3: true,
      brightness: brightness,
      fontFamily: AppTypography.fontFamily,
      scaffoldBackgroundColor: scaffoldColor,
      primaryColor: primaryColor,
      colorScheme: ColorScheme(
        brightness: brightness,
        primary: primaryColor,
        onPrimary: onPrimaryColor,
        secondary: primaryColor,
        onSecondary: onPrimaryColor,
        surface: surfaceColor,
        onSurface: onSurfaceColor,
        background: backgroundColor,
        onBackground: onSurfaceColor,
        error: Colors.red.shade400,
        onError: Colors.white,
      ),
      appBarTheme: AppBarTheme(
        elevation: 0,
        backgroundColor: appBarColor,
        foregroundColor: onSurfaceColor,
        systemOverlayStyle: brightness == Brightness.light
            ? SystemUiOverlayStyle.dark
            : SystemUiOverlayStyle.light,
        titleTextStyle: textTheme.headlineSmall,
        iconTheme: IconThemeData(color: onSurfaceColor),
      ),
      cardTheme: CardTheme(
        elevation: 0,
        color: surfaceColor,
        shape: cardShape,
        margin: const EdgeInsets.symmetric(vertical: 8.0, horizontal: 16.0),
      ),
      floatingActionButtonTheme: FloatingActionButtonThemeData(
        backgroundColor: onSurfaceColor,
        foregroundColor: backgroundColor,
        elevation: 0,
        highlightElevation: 0,
        shape: const CircleBorder(),
      ),
      bottomAppBarTheme: BottomAppBarTheme(
        color: surfaceColor,
        elevation: 0,
        shape: const CircularNotchedRectangle(),
      ),
      inputDecorationTheme: InputDecorationTheme(
        filled: true,
        fillColor: surfaceColor,
        contentPadding:
            const EdgeInsets.symmetric(horizontal: 20, vertical: 16),
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12.0),
          borderSide: BorderSide(color: borderColor, width: 1.0),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12.0),
          borderSide: BorderSide(color: borderColor, width: 1.0),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12.0),
          borderSide: BorderSide(color: primaryColor, width: 1.5),
        ),
      ),
      textTheme: textTheme,
    );
  }

  static TextTheme _buildTextTheme(
      {required TextTheme base, required Color onSurfaceColor}) {
    return base
        .copyWith(
          displayMedium: AppTypography.displayMedium
              .copyWith(color: onSurfaceColor, fontWeight: FontWeight.bold),
          headlineSmall: AppTypography.headlineSmall
              .copyWith(color: onSurfaceColor, fontWeight: FontWeight.w600),
          titleLarge: AppTypography.titleLarge
              .copyWith(color: onSurfaceColor, fontWeight: FontWeight.w600),
          titleMedium: AppTypography.titleMedium
              .copyWith(color: onSurfaceColor, fontWeight: FontWeight.w600),
          bodyLarge: AppTypography.bodyLarge.copyWith(color: onSurfaceColor),
          bodyMedium: AppTypography.bodyMedium
              .copyWith(color: onSurfaceColor.withOpacity(0.8)),
        )
        .apply(
          bodyColor: onSurfaceColor.withOpacity(0.8),
          displayColor: onSurfaceColor,
        );
  }
}


===== FILE: app_typography.dart =====
===== PATH: lib/core/theme/app_typography.dart =====

import 'package:flutter/material.dart';

// This class is not meant to be instantiated.
// It holds static TextStyle definitions for the app, based on Material Design 3.
// The font family 'Inter' is assumed to be set in pubspec.yaml and main theme.
abstract class AppTypography {
  static const String fontFamily = 'Inter';

  // Display Styles
  static const TextStyle displayLarge = TextStyle(
    fontFamily: fontFamily,
    fontSize: 57,
    fontWeight: FontWeight.w400,
    letterSpacing: -0.25,
    height: 1.12, // 64px line height
  );
  static const TextStyle displayMedium = TextStyle(
    fontFamily: fontFamily,
    fontSize: 45,
    fontWeight: FontWeight.w400,
    letterSpacing: 0,
    height: 1.15, // 52px line height
  );
  static const TextStyle displaySmall = TextStyle(
    fontFamily: fontFamily,
    fontSize: 36,
    fontWeight: FontWeight.w400,
    letterSpacing: 0,
    height: 1.22, // 44px line height
  );

  // Headline Styles
  static const TextStyle headlineLarge = TextStyle(
    fontFamily: fontFamily,
    fontSize: 32,
    fontWeight: FontWeight.w400,
    letterSpacing: 0,
    height: 1.25, // 40px line height
  );
  static const TextStyle headlineMedium = TextStyle(
    fontFamily: fontFamily,
    fontSize: 28,
    fontWeight: FontWeight.w400,
    letterSpacing: 0,
    height: 1.28, // 36px line height
  );
  static const TextStyle headlineSmall = TextStyle(
    fontFamily: fontFamily,
    fontSize: 24,
    fontWeight: FontWeight.w400,
    letterSpacing: 0,
    height: 1.33, // 32px line height
  );

  // Title Styles
  static const TextStyle titleLarge = TextStyle(
    fontFamily: fontFamily,
    fontSize: 22,
    fontWeight: FontWeight.w500, // Medium weight for titles
    letterSpacing: 0,
    height: 1.27, // 28px line height
  );
  static const TextStyle titleMedium = TextStyle(
    fontFamily: fontFamily,
    fontSize: 16,
    fontWeight: FontWeight.w500,
    letterSpacing: 0.15,
    height: 1.5, // 24px line height
  );
  static const TextStyle titleSmall = TextStyle(
    fontFamily: fontFamily,
    fontSize: 14,
    fontWeight: FontWeight.w500,
    letterSpacing: 0.1,
    height: 1.43, // 20px line height
  );

  // Label Styles
  static const TextStyle labelLarge = TextStyle(
    fontFamily: fontFamily,
    fontSize: 14,
    fontWeight: FontWeight.w500,
    letterSpacing: 0.1,
    height: 1.43, // 20px line height
  );
  static const TextStyle labelMedium = TextStyle(
    fontFamily: fontFamily,
    fontSize: 12,
    fontWeight: FontWeight.w500,
    letterSpacing: 0.5,
    height: 1.33, // 16px line height
  );
  static const TextStyle labelSmall = TextStyle(
    fontFamily: fontFamily,
    fontSize: 11,
    fontWeight: FontWeight.w500,
    letterSpacing: 0.5,
    height: 1.45, // 16px line height
  );

  // Body Styles
  static const TextStyle bodyLarge = TextStyle(
    fontFamily: fontFamily,
    fontSize: 16,
    fontWeight: FontWeight.w400,
    letterSpacing: 0.5,
    height: 1.5, // 24px line height
  );
  static const TextStyle bodyMedium = TextStyle(
    fontFamily: fontFamily,
    fontSize: 14,
    fontWeight: FontWeight.w400,
    letterSpacing: 0.25,
    height: 1.43, // 20px line height
  );
  static const TextStyle bodySmall = TextStyle(
    fontFamily: fontFamily,
    fontSize: 12,
    fontWeight: FontWeight.w400,
    letterSpacing: 0.4,
    height: 1.33, // 16px line height
  );
}

===== FILE: classic_theme.dart =====
===== PATH: lib/core/theme/classic_theme.dart =====

// lib/core/theme/classic_theme.dart

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:aboapp/core/theme/app_colors.dart';
import 'package:aboapp/core/theme/app_typography.dart';

abstract class ClassicTheme {
  static ThemeData get lightTheme {
    return ThemeData(
      useMaterial3: true,
      brightness: Brightness.light,
      fontFamily: AppTypography.fontFamily,
      primaryColor: AppColors.primary,
      scaffoldBackgroundColor: AppColors.backgroundLight,
      colorScheme: const ColorScheme(
        brightness: Brightness.light,
        primary: AppColors.primary,
        onPrimary: AppColors.onPrimary,
        primaryContainer: AppColors.primaryLight,
        onPrimaryContainer: AppColors.primaryDark,
        secondary: AppColors.accent,
        onSecondary: AppColors.onAccent,
        secondaryContainer: Color(0xFFFDE2EC),
        onSecondaryContainer: Color(0xFF7C2454),
        tertiary: AppColors.info,
        onTertiary: AppColors.onInfo,
        tertiaryContainer: Color(0xFFD8E6FD),
        onTertiaryContainer: Color(0xFF0F4C81),
        error: AppColors.error,
        onError: AppColors.onError,
        errorContainer: Color(0xFFFFDAD6),
        onErrorContainer: Color(0xFF410002),
        surface: AppColors.backgroundLight,
        onSurface: AppColors.onSurfaceLight,
        surfaceContainerHighest: AppColors.surfaceLight,
        onSurfaceVariant: AppColors.onSurfaceVariantLight,
        outline: AppColors.borderLight,
        outlineVariant: Color(0xFFCAC4D0),
        shadow: Color(0x1A000000),
        scrim: Color(0x4D000000),
        inverseSurface: AppColors.surfaceDark,
        onInverseSurface: AppColors.onSurfaceDark,
        inversePrimary: AppColors.primaryDark,
        surfaceTint: AppColors.primary,
      ),
      textTheme: _buildTextTheme(
          base: ThemeData.light().textTheme,
          onSurfaceColor: AppColors.onSurfaceLight),
      appBarTheme: const AppBarTheme(
        elevation: 0,
        backgroundColor: AppColors.backgroundLight,
        foregroundColor: AppColors.onSurfaceLight,
        systemOverlayStyle: SystemUiOverlayStyle.dark,
        titleTextStyle: AppTypography.titleLarge,
        iconTheme: IconThemeData(color: AppColors.onSurfaceLight),
      ),
      cardTheme: CardTheme(
        elevation: 1.0,
        color: AppColors.surfaceLight,
        surfaceTintColor: Colors.transparent,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(12.0),
          side: const BorderSide(color: AppColors.borderLight, width: 0.5),
        ),
        margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          backgroundColor: AppColors.primary,
          foregroundColor: AppColors.onPrimary,
          textStyle: AppTypography.labelLarge,
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
          shape:
              RoundedRectangleBorder(borderRadius: BorderRadius.circular(24.0)),
          elevation: 2.0,
        ),
      ),
      textButtonTheme: TextButtonThemeData(
        style: TextButton.styleFrom(
          foregroundColor: AppColors.primary,
          textStyle:
              AppTypography.labelLarge.copyWith(fontWeight: FontWeight.w600),
          shape:
              RoundedRectangleBorder(borderRadius: BorderRadius.circular(24.0)),
        ),
      ),
      inputDecorationTheme: InputDecorationTheme(
        filled: true,
        fillColor: AppColors.surfaceLight.withOpacity(0.5),
        contentPadding:
            const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12.0),
          borderSide: const BorderSide(color: AppColors.borderLight),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12.0),
          borderSide: const BorderSide(color: AppColors.borderLight),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12.0),
          borderSide: const BorderSide(color: AppColors.primary, width: 2.0),
        ),
        errorBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12.0),
          borderSide: const BorderSide(color: AppColors.error, width: 1.5),
        ),
        focusedErrorBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12.0),
          borderSide: const BorderSide(color: AppColors.error, width: 2.0),
        ),
        labelStyle: AppTypography.bodyMedium
            .copyWith(color: AppColors.onSurfaceVariantLight),
        hintStyle: AppTypography.bodyMedium
            .copyWith(color: AppColors.onSurfaceVariantLight.withOpacity(0.7)),
        floatingLabelStyle:
            AppTypography.bodySmall.copyWith(color: AppColors.primary),
      ),
      chipTheme: ChipThemeData(
        backgroundColor: AppColors.borderLight,
        selectedColor: AppColors.primary,
        labelStyle: AppTypography.labelMedium
            .copyWith(color: AppColors.onSurfaceVariantLight),
        secondaryLabelStyle:
            AppTypography.labelMedium.copyWith(color: AppColors.onPrimary),
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
        shape:
            RoundedRectangleBorder(borderRadius: BorderRadius.circular(20.0)),
        iconTheme: const IconThemeData(
            color: AppColors.onSurfaceVariantLight, size: 18),
      ),
      floatingActionButtonTheme: const FloatingActionButtonThemeData(
        backgroundColor: AppColors.primary,
        foregroundColor: AppColors.onPrimary,
        elevation: 4.0,
      ),
      bottomNavigationBarTheme: BottomNavigationBarThemeData(
        backgroundColor: AppColors.surfaceLight,
        selectedItemColor: AppColors.primary,
        unselectedItemColor: AppColors.onSurfaceVariantLight,
        selectedLabelStyle: AppTypography.labelSmall,
        unselectedLabelStyle: AppTypography.labelSmall,
        elevation: 2.0,
        type: BottomNavigationBarType.fixed,
      ),
    );
  }

  static ThemeData get darkTheme {
    return ThemeData(
      useMaterial3: true,
      brightness: Brightness.dark,
      fontFamily: AppTypography.fontFamily,
      primaryColor: AppColors.primary,
      scaffoldBackgroundColor: AppColors.backgroundDark,
      colorScheme: const ColorScheme(
        brightness: Brightness.dark,
        primary: AppColors.primaryLight,
        onPrimary: AppColors.primaryDark,
        primaryContainer: AppColors.primaryDark,
        onPrimaryContainer: AppColors.primaryLight,
        secondary: AppColors.accent,
        onSecondary: AppColors.onAccent,
        secondaryContainer: Color(0xFF7C2454),
        onSecondaryContainer: Color(0xFFFDE2EC),
        tertiary: AppColors.info,
        onTertiary: AppColors.onInfo,
        tertiaryContainer: Color(0xFF0F4C81),
        onTertiaryContainer: Color(0xFFD8E6FD),
        error: AppColors.error,
        onError: AppColors.onError,
        errorContainer: Color(0xFF93000A),
        onErrorContainer: Color(0xFFFFDAD6),
        surface: AppColors.backgroundDark,
        onSurface: AppColors.onSurfaceDark,
        surfaceContainerHighest: AppColors.surfaceDark,
        onSurfaceVariant: AppColors.onSurfaceVariantDark,
        outline: AppColors.borderDark,
        outlineVariant: Color(0xFF49454F),
        shadow: Color(0x33000000),
        scrim: Color(0x66000000),
        inverseSurface: AppColors.surfaceLight,
        onInverseSurface: AppColors.onSurfaceLight,
        inversePrimary: AppColors.primary,
        surfaceTint: AppColors.primaryLight,
      ),
      textTheme: _buildTextTheme(
          base: ThemeData.dark().textTheme,
          onSurfaceColor: AppColors.onSurfaceDark),
      appBarTheme: const AppBarTheme(
        elevation: 0,
        backgroundColor: AppColors.backgroundDark,
        foregroundColor: AppColors.onSurfaceDark,
        systemOverlayStyle: SystemUiOverlayStyle.light,
        titleTextStyle: AppTypography.titleLarge,
        iconTheme: IconThemeData(color: AppColors.onSurfaceDark),
      ),
      cardTheme: CardTheme(
        elevation: 1.0,
        color: AppColors.surfaceDark,
        surfaceTintColor: Colors.transparent,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(12.0),
          side: const BorderSide(color: AppColors.borderDark, width: 0.5),
        ),
        margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          backgroundColor: AppColors.primaryLight,
          foregroundColor: AppColors.primaryDark,
          textStyle: AppTypography.labelLarge,
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
          shape:
              RoundedRectangleBorder(borderRadius: BorderRadius.circular(24.0)),
          elevation: 2.0,
        ),
      ),
      textButtonTheme: TextButtonThemeData(
        style: TextButton.styleFrom(
          foregroundColor: AppColors.primaryLight,
          textStyle:
              AppTypography.labelLarge.copyWith(fontWeight: FontWeight.w600),
          shape:
              RoundedRectangleBorder(borderRadius: BorderRadius.circular(24.0)),
        ),
      ),
      inputDecorationTheme: InputDecorationTheme(
        filled: true,
        fillColor: AppColors.surfaceDark.withOpacity(0.5),
        contentPadding:
            const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12.0),
          borderSide: const BorderSide(color: AppColors.borderDark),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12.0),
          borderSide: const BorderSide(color: AppColors.borderDark),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12.0),
          borderSide:
              const BorderSide(color: AppColors.primaryLight, width: 2.0),
        ),
        errorBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12.0),
          borderSide: const BorderSide(color: AppColors.error, width: 1.5),
        ),
        focusedErrorBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12.0),
          borderSide: const BorderSide(color: AppColors.error, width: 2.0),
        ),
        labelStyle: AppTypography.bodyMedium
            .copyWith(color: AppColors.onSurfaceVariantDark),
        hintStyle: AppTypography.bodyMedium
            .copyWith(color: AppColors.onSurfaceVariantDark.withOpacity(0.7)),
        floatingLabelStyle:
            AppTypography.bodySmall.copyWith(color: AppColors.primaryLight),
      ),
      chipTheme: ChipThemeData(
        backgroundColor: AppColors.borderDark,
        selectedColor: AppColors.primaryLight,
        labelStyle: AppTypography.labelMedium
            .copyWith(color: AppColors.onSurfaceVariantDark),
        secondaryLabelStyle:
            AppTypography.labelMedium.copyWith(color: AppColors.primaryDark),
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
        shape:
            RoundedRectangleBorder(borderRadius: BorderRadius.circular(20.0)),
        iconTheme: const IconThemeData(
            color: AppColors.onSurfaceVariantDark, size: 18),
      ),
      floatingActionButtonTheme: const FloatingActionButtonThemeData(
        backgroundColor: AppColors.primaryLight,
        foregroundColor: AppColors.primaryDark,
        elevation: 4.0,
      ),
      bottomNavigationBarTheme: BottomNavigationBarThemeData(
        backgroundColor: AppColors.surfaceDark,
        selectedItemColor: AppColors.primaryLight,
        unselectedItemColor: AppColors.onSurfaceVariantDark,
        selectedLabelStyle: AppTypography.labelSmall,
        unselectedLabelStyle: AppTypography.labelSmall,
        elevation: 2.0,
        type: BottomNavigationBarType.fixed,
      ),
    );
  }

  static TextTheme _buildTextTheme(
      {required TextTheme base, required Color onSurfaceColor}) {
    return base
        .copyWith(
          displayLarge:
              AppTypography.displayLarge.copyWith(color: onSurfaceColor),
          displayMedium:
              AppTypography.displayMedium.copyWith(color: onSurfaceColor),
          displaySmall:
              AppTypography.displaySmall.copyWith(color: onSurfaceColor),
          headlineLarge:
              AppTypography.headlineLarge.copyWith(color: onSurfaceColor),
          headlineMedium:
              AppTypography.headlineMedium.copyWith(color: onSurfaceColor),
          headlineSmall:
              AppTypography.headlineSmall.copyWith(color: onSurfaceColor),
          titleLarge: AppTypography.titleLarge.copyWith(color: onSurfaceColor),
          titleMedium:
              AppTypography.titleMedium.copyWith(color: onSurfaceColor),
          titleSmall: AppTypography.titleSmall.copyWith(color: onSurfaceColor),
          bodyLarge: AppTypography.bodyLarge.copyWith(color: onSurfaceColor),
          bodyMedium: AppTypography.bodyMedium.copyWith(color: onSurfaceColor),
          bodySmall: AppTypography.bodySmall.copyWith(color: onSurfaceColor),
          labelLarge: AppTypography.labelLarge.copyWith(color: onSurfaceColor),
          labelMedium:
              AppTypography.labelMedium.copyWith(color: onSurfaceColor),
          labelSmall: AppTypography.labelSmall.copyWith(color: onSurfaceColor),
        )
        .apply(
          bodyColor: onSurfaceColor,
          displayColor: onSurfaceColor,
        );
  }
}

extension SemanticThemeColors on ThemeData {
  // Classic
  Color get success =>
      brightness == Brightness.light ? AppColors.success : AppColors.success;
  Color get onSuccess => brightness == Brightness.light
      ? AppColors.onSuccess
      : AppColors.onSuccess;
  Color get warning =>
      brightness == Brightness.light ? AppColors.warning : AppColors.warning;
  Color get onWarning => brightness == Brightness.light
      ? AppColors.onWarning
      : AppColors.onWarning;
  Color get info =>
      brightness == Brightness.light ? AppColors.info : AppColors.info;
  Color get onInfo =>
      brightness == Brightness.light ? AppColors.onInfo : AppColors.onInfo;
}


===== FILE: modern_theme.dart =====
===== PATH: lib/core/theme/modern_theme.dart =====

// lib/main_container_screen.dart

import 'package:aboapp/core/routing/app_router.dart';
import 'package:aboapp/features/settings/presentation/cubit/screens/settings_screen.dart';
import 'package:aboapp/features/statistics/presentation/screens/statistics_screen.dart';
import 'package:aboapp/features/subscriptions/presentation/screens/home_screen.dart';
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:aboapp/core/utils/haptic_feedback.dart' as app_haptics;

class MainContainerScreen extends StatefulWidget {
  final String location;
  const MainContainerScreen({super.key, required this.location});

  @override
  State<MainContainerScreen> createState() => _MainContainerScreenState();
}

class _MainContainerScreenState extends State<MainContainerScreen> {
  late final PageController _pageController;
  int _currentIndex = 0;

  @override
  void initState() {
    super.initState();
    _currentIndex = _calculatePageIndex(widget.location);
    _pageController = PageController(initialPage: _currentIndex);
  }

  @override
  void didUpdateWidget(covariant MainContainerScreen oldWidget) {
    super.didUpdateWidget(oldWidget);
    final newIndex = _calculatePageIndex(widget.location);
    if (newIndex != _currentIndex) {
      setState(() {
        _currentIndex = newIndex;
      });
      if (_pageController.hasClients &&
          _pageController.page?.round() != newIndex) {
        _pageController.jumpToPage(newIndex);
      }
    }
  }

  @override
  void dispose() {
    _pageController.dispose();
    super.dispose();
  }

  int _calculatePageIndex(String location) {
    if (location.startsWith(AppRoutes.statistics)) return 1;
    if (location.startsWith(AppRoutes.settings)) return 2;
    return 0;
  }

  void _onPageChanged(int index) {
    if (_currentIndex == index) return;
    _updateRoute(index);
  }

  void _updateRoute(int index) {
    setState(() => _currentIndex = index);
    switch (index) {
      case 0:
        context.go(AppRoutes.home);
        break;
      case 1:
        context.go(AppRoutes.statistics);
        break;
      case 2:
        context.go(AppRoutes.settings);
        break;
    }
  }

  void _onBottomNavItemTapped(int index) {
    if (_currentIndex == index) return;
    app_haptics.HapticFeedback.selectionClick();
    _pageController.animateToPage(
      index,
      duration: const Duration(milliseconds: 300),
      curve: Curves.easeInOut,
    );
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Scaffold(
      body: PageView(
        controller: _pageController,
        onPageChanged: _onPageChanged,
        children: const <Widget>[
          HomeScreen(),
          StatisticsScreen(),
          SettingsScreen(),
        ],
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          app_haptics.HapticFeedback.lightImpact();
          context.pushNamed(AppRoutes.addSubscription);
        },
        tooltip: 'Add Subscription',
        child: const Icon(Icons.add),
      ),
      floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked,
      bottomNavigationBar: BottomAppBar(
        notchMargin: 8.0,
        // FIX: Das Row-Widget wird in einen Container mit oberem Rand gewickelt.
        child: Container(
          decoration: BoxDecoration(
              border: Border(
                  top: BorderSide(
                      color: theme.dividerColor.withOpacity(0.5), width: 1.0))),
          child: Row(
            mainAxisSize: MainAxisSize.max,
            mainAxisAlignment: MainAxisAlignment.spaceAround,
            children: <Widget>[
              _buildBottomNavItem(
                  context: context,
                  icon: Icons.home_filled,
                  label: 'Home',
                  index: 0),
              _buildBottomNavItem(
                  context: context,
                  icon: Icons.pie_chart_rounded,
                  label: 'Stats',
                  index: 1),
              const SizedBox(width: 48), // The notch space
              _buildBottomNavItem(
                  context: context,
                  icon: Icons.settings_rounded,
                  label: 'Settings',
                  index: 2),
              _buildBottomNavItem(
                  context: context,
                  icon: Icons.person_rounded,
                  label: 'Profile',
                  index: 3), // Example for future use
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildBottomNavItem({
    required BuildContext context,
    required IconData icon,
    required String label,
    required int index,
  }) {
    final theme = Theme.of(context);
    final isSelected = _currentIndex == index;
    final bool isDisabled = index > 2; // Profil-Icon ist deaktiviert

    // Die Farben werden jetzt direkt vom überarbeiteten Theme korrekt übernommen.
    final color = isDisabled
        ? theme.colorScheme.onSurface.withOpacity(0.3)
        : isSelected
            ? theme.colorScheme.primary
            : theme.colorScheme.onSurfaceVariant;

    return Expanded(
      child: InkWell(
        onTap: isDisabled ? null : () => _onBottomNavItemTapped(index),
        customBorder: const CircleBorder(),
        child: Padding(
          padding: const EdgeInsets.symmetric(vertical: 8.0),
          child: Icon(icon, color: color, size: 28),
        ),
      ),
    );
  }
}


===== FILE: color_serializer.dart =====
===== PATH: lib/core/utils/color_serializer.dart =====

import 'package:flutter/material.dart';
import 'package:json_annotation/json_annotation.dart';

class ColorSerializer implements JsonConverter<Color?, int?> {
  const ColorSerializer();

  @override
  Color? fromJson(int? json) {
    return json == null ? null : Color(json);
  }

  @override
  int? toJson(Color? color) {
    return color?.value;
  }
}

===== FILE: currency_formatter.dart =====
===== PATH: lib/core/utils/currency_formatter.dart =====

import 'package:intl/intl.dart';
import 'package:flutter/material.dart'; // For Locale

class CurrencyFormatter {
  static String format(
    double amount, {
    required String currencyCode, 
    Locale? locale,             
    int? decimalDigits,         
  }) {
    String localeString;
    if (locale != null) {
      localeString = locale.toLanguageTag().replaceAll('-', '_');
    } else {
      switch (currencyCode.toUpperCase()) {
        case 'USD':
        case 'CAD':
        case 'AUD':
          localeString = 'en_US';
          break;
        case 'EUR':
          localeString = 'de_DE'; 
          break;
        case 'GBP':
          localeString = 'en_GB';
          break;
        case 'JPY':
          localeString = 'ja_JP';
          break;
        case 'CHF':
          localeString = 'de_CH';
          break;
        default:
          localeString = 'en_US'; 
      }
    }

    try {
      final format = NumberFormat.currency(
        locale: localeString,
        symbol: getCurrencySymbol(currencyCode), 
        decimalDigits: decimalDigits ?? _getDefaultDecimalDigits(currencyCode),
      );
      return format.format(amount);
    } catch (e) {
      // print("Currency formatting error for $currencyCode with locale $localeString: $e"); // Avoid print
      return '${getCurrencySymbol(currencyCode)}${amount.toStringAsFixed(decimalDigits ?? 2)}';
    }
  }

  static String getCurrencySymbol(String currencyCode) {
    final Map<String, String> symbols = {
      'USD': '\$',
      'EUR': '€',
      'GBP': '£',
      'JPY': '¥',
      'CHF': 'CHF', 
      'CAD': 'CA\$',
      'AUD': 'A\$',
    };
    return symbols[currencyCode.toUpperCase()] ?? currencyCode;
  }

  static int _getDefaultDecimalDigits(String currencyCode) {
    switch (currencyCode.toUpperCase()) {
      case 'JPY':
        return 0; 
      case 'USD':
      case 'EUR':
      case 'GBP':
      case 'CHF':
      case 'CAD':
      case 'AUD':
      default:
        return 2;
    }
  }

  static double? tryParse(String formattedAmount) {
    String cleaned = formattedAmount
        .replaceAll(RegExp(r'[$\€£¥CHF]'), '') 
        .replaceAll(',', '') 
        .trim();
    return double.tryParse(cleaned);
  }
}

===== FILE: date_formatter.dart =====
===== PATH: lib/core/utils/date_formatter.dart =====

import 'package:intl/intl.dart';
import 'package:flutter/material.dart'; // For Locale

class DateFormatter {
  static String formatDate(DateTime? date, {Locale? locale}) {
    if (date == null) return 'N/A'; 
    final String localeString = locale?.toLanguageTag().replaceAll('-', '_') ?? 'en_US'; 
    return DateFormat('dd MMM, yyyy', localeString).format(date);
  }

  static String formatShortDate(DateTime? date, {Locale? locale}) {
    if (date == null) return 'N/A';
    final String localeString = locale?.toLanguageTag().replaceAll('-', '_') ?? 'en_US';
    return DateFormat.yMd(localeString).format(date); 
  }
  
  static String formatMonthYear(DateTime? date, {Locale? locale}) {
    if (date == null) return 'N/A';
    final String localeString = locale?.toLanguageTag().replaceAll('-', '_') ?? 'en_US';
    return DateFormat.yMMMM(localeString).format(date); 
  }

  static String formatDaysUntil(DateTime date, {Locale? locale, String? overdueText, String? todayText, String? tomorrowText, String? daysAgoText, String? daysFutureText}) {
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    final targetDay = DateTime(date.year, date.month, date.day);
    final differenceInDays = targetDay.difference(today).inDays;

    // final String currentOverdueText = overdueText ?? '{days} days ago'; // Variable was unused
    final currentTodayText = todayText ?? 'Today';
    final currentTomorrowText = tomorrowText ?? 'Tomorrow';
    final currentDaysAgoText = daysAgoText ?? '{days} days ago'; 
    final currentDaysFutureText = daysFutureText ?? 'in {days} days';

    if (differenceInDays < 0) {
      return currentDaysAgoText.replaceAll('{days}', differenceInDays.abs().toString());
    } else if (differenceInDays == 0) {
      return currentTodayText;
    } else if (differenceInDays == 1) {
      return currentTomorrowText;
    } else {
      return currentDaysFutureText.replaceAll('{days}', differenceInDays.toString());
    }
  }

  static String formatTime(DateTime? time, {Locale? locale}) {
    if (time == null) return 'N/A';
    final String localeString = locale?.toLanguageTag().replaceAll('-', '_') ?? 'en_US';
    return DateFormat.jm(localeString).format(time); 
  }

  static String formatDateTime(DateTime? dateTime, {Locale? locale}) {
    if (dateTime == null) return 'N/A';
    final String localeString = locale?.toLanguageTag().replaceAll('-', '_') ?? 'en_US';
    return DateFormat.yMMMMEEEEd(localeString).add_jm().format(dateTime); 
  }
}

===== FILE: haptic_feedback.dart =====
===== PATH: lib/core/utils/haptic_feedback.dart =====

import 'package:flutter/services.dart';

/// A utility class for providing haptic feedback.
/// This wraps the standard Flutter HapticFeedback methods for consistent use.
class HapticFeedback {
  HapticFeedback._(); // Private constructor to prevent instantiation.

  /// Provides a light haptic feedback.
  /// Typically used for minor interactions or successes.
  static Future<void> lightImpact() async {
    await SystemChannels.platform.invokeMethod<void>('HapticFeedback.vibrate', 'HapticFeedbackType.lightImpact');
    // Or using the direct method if you prefer and it suits your Flutter version's direct support:
    // await SystemSound.play(SystemSoundType.click); // This is more of a sound, but often used similarly
    // await HapticFeedback.lightImpact(); // Use this if your Flutter version has it directly and it's reliable.
  }

  /// Provides a medium haptic feedback.
  /// Suitable for more significant actions or confirmations.
  static Future<void> mediumImpact() async {
    await SystemChannels.platform.invokeMethod<void>('HapticFeedback.vibrate', 'HapticFeedbackType.mediumImpact');
    // await HapticFeedback.mediumImpact();
  }

  /// Provides a heavy haptic feedback.
  /// Best reserved for critical actions or errors.
  static Future<void> heavyImpact() async {
    await SystemChannels.platform.invokeMethod<void>('HapticFeedback.vibrate', 'HapticFeedbackType.heavyImpact');
    // await HapticFeedback.heavyImpact();
  }

  /// Provides a haptic feedback for a selection change.
  /// Commonly used in pickers or when an item selection changes.
  static Future<void> selectionClick() async {
    await SystemChannels.platform.invokeMethod<void>('HapticFeedback.vibrate', 'HapticFeedbackType.selectionClick');
    // await HapticFeedback.selectionClick();
  }

  /// Provides a warning haptic feedback pattern (not standard on all platforms).
  /// If specific warning patterns are needed, they might require platform-specific implementations
  /// or a plugin that offers more advanced haptics.
  /// For a simple alternative, you might use heavyImpact or a custom short vibration sequence.
  static Future<void> warningImpact() async {
    // iOS often has specific notification feedback types (success, warning, error)
    // Android is more generic. Heavy impact can serve as a general strong feedback.
    await heavyImpact(); 
  }
}

===== FILE: onboarding_screen.dart =====
===== PATH: lib/features/onboarding/presentation/screens/onboarding_screen.dart =====

// lib/features/onboarding/presentation/screens/onboarding_screen.dart

import 'package:aboapp/core/routing/app_router.dart';
import 'package:aboapp/features/onboarding/presentation/widgets/onboarding_page_content_widget.dart';
import 'package:aboapp/features/onboarding/presentation/widgets/page_indicator_widget.dart';
import 'package:aboapp/features/onboarding/presentation/widgets/salary_onboarding_page.dart';
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:aboapp/core/di/injection.dart';

class OnboardingScreen extends StatefulWidget {
  const OnboardingScreen({super.key});

  @override
  State<OnboardingScreen> createState() => _OnboardingScreenState();
}

class _OnboardingScreenData {
  final String titleKey;
  final String descriptionKey;
  final IconData iconData;
  final Color iconColor;
  final Widget? customContent;

  _OnboardingScreenData({
    required this.titleKey,
    required this.descriptionKey,
    required this.iconData,
    required this.iconColor,
    this.customContent,
  });
}

class _OnboardingScreenState extends State<OnboardingScreen> {
  final PageController _pageController = PageController();
  int _currentPageIndex = 0;
  final GlobalKey<SalaryOnboardingPageState> _salaryPageKey = GlobalKey();
  late final List<_OnboardingScreenData> _onboardingPages;

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    _onboardingPages = [
      _OnboardingScreenData(
        titleKey: 'Welcome to AboApp',
        descriptionKey: 'Easily manage all your subscriptions in one place.',
        iconData: Icons.account_balance_wallet_outlined,
        iconColor: Theme.of(context).colorScheme.primary,
      ),
      _OnboardingScreenData(
        titleKey: 'Add Subscriptions',
        descriptionKey:
            'Track your recurring payments and never miss a due date.',
        iconData: Icons.add_circle_outline_rounded,
        iconColor: Colors.green.shade600,
      ),
      _OnboardingScreenData(
        titleKey: 'Salary Insights',
        descriptionKey:
            'Enter your salary to see how much you spend on subscriptions.',
        iconData: Icons.insights_rounded,
        iconColor: Colors.blue.shade600,
        customContent: SalaryOnboardingPage(key: _salaryPageKey),
      ),
      _OnboardingScreenData(
        titleKey: 'Get Notified',
        descriptionKey: 'Receive reminders before your next billing date.',
        iconData: Icons.notifications_active_outlined,
        iconColor: Colors.purple.shade600,
      ),
    ];
  }

  @override
  void dispose() {
    _pageController.dispose();
    super.dispose();
  }

  Future<void> _completeOnboarding() async {
    _salaryPageKey.currentState?.saveSettings();
    final prefs = getIt<SharedPreferences>();
    await prefs.setBool('onboarding_complete', true);
    if (mounted) {
      context.goNamed(AppRoutes.home);
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isLastPage = _currentPageIndex == _onboardingPages.length - 1;

    return Scaffold(
      body: SafeArea(
        child: Column(
          children: <Widget>[
            Align(
              alignment: Alignment.topRight,
              child: Padding(
                padding: const EdgeInsets.only(top: 8.0, right: 16.0),
                child: TextButton(
                  onPressed: _completeOnboarding,
                  child: Text(isLastPage ? 'Done' : 'Skip',
                      style: TextStyle(color: theme.colorScheme.primary)),
                ),
              ),
            ),
            Expanded(
              child: PageView.builder(
                controller: _pageController,
                itemCount: _onboardingPages.length,
                onPageChanged: (index) {
                  setState(() {
                    _currentPageIndex = index;
                  });
                },
                itemBuilder: (context, index) {
                  final pageData = _onboardingPages[index];
                  if (pageData.customContent != null) {
                    return pageData.customContent!;
                  }
                  return OnboardingPageContentWidget(
                    title: pageData.titleKey,
                    description: pageData.descriptionKey,
                    iconData: pageData.iconData,
                    iconColor: pageData.iconColor,
                  );
                },
              ),
            ),
            Padding(
              padding: const EdgeInsets.symmetric(vertical: 24.0),
              child: PageIndicatorWidget(
                currentPageIndex: _currentPageIndex,
                pageCount: _onboardingPages.length,
                activeColor: theme.colorScheme.primary,
                inactiveColor: theme.colorScheme.onSurface.withOpacity(0.2),
              ),
            ),
            Padding(
              padding:
                  const EdgeInsets.symmetric(horizontal: 24.0, vertical: 16.0),
              child: SizedBox(
                width: double.infinity,
                child: ElevatedButton(
                  style: ElevatedButton.styleFrom(
                    padding: const EdgeInsets.symmetric(vertical: 16.0),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(30.0),
                    ),
                  ),
                  onPressed: () {
                    if (!isLastPage) {
                      _pageController.nextPage(
                        duration: const Duration(milliseconds: 400),
                        curve: Curves.easeInOut,
                      );
                    } else {
                      _completeOnboarding();
                    }
                  },
                  child: Text(
                    isLastPage ? 'Get Started' : 'Next',
                    style: theme.textTheme.labelLarge
                        ?.copyWith(fontWeight: FontWeight.bold),
                  ),
                ),
              ),
            ),
            const SizedBox(height: 16),
          ],
        ),
      ),
    );
  }
}


===== FILE: onboarding_page_content_widget.dart =====
===== PATH: lib/features/onboarding/presentation/widgets/onboarding_page_content_widget.dart =====

import 'package:flutter/material.dart';

class OnboardingPageContentWidget extends StatelessWidget {
  final String title;
  final String description;
  final IconData iconData; // Using IconData for simplicity
  final Color iconColor;   // Color for the icon and its background accent

  const OnboardingPageContentWidget({
    super.key,
    required this.title,
    required this.description,
    required this.iconData,
    required this.iconColor,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final screenSize = MediaQuery.of(context).size;

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 32.0, vertical: 24.0),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        crossAxisAlignment: CrossAxisAlignment.center,
        children: <Widget>[
          Container(
            width: screenSize.width * 0.4, // Responsive icon container
            height: screenSize.width * 0.4,
            decoration: BoxDecoration(
              color: iconColor.withOpacity(0.15), // Subtle background
              shape: BoxShape.circle,
            ),
            child: Icon(
              iconData,
              size: screenSize.width * 0.2, // Responsive icon size
              color: iconColor,
            ),
          ),
          const SizedBox(height: 48.0),
          Text(
            title,
            textAlign: TextAlign.center,
            style: theme.textTheme.headlineSmall?.copyWith(
              fontWeight: FontWeight.bold,
              color: theme.colorScheme.onBackground,
            ),
          ),
          const SizedBox(height: 16.0),
          Text(
            description,
            textAlign: TextAlign.center,
            style: theme.textTheme.bodyLarge?.copyWith(
              color: theme.colorScheme.onSurfaceVariant,
              height: 1.5, // Improved line spacing
            ),
          ),
        ],
      ),
    );
  }
}

===== FILE: page_indicator_widget.dart =====
===== PATH: lib/features/onboarding/presentation/widgets/page_indicator_widget.dart =====

import 'package:flutter/material.dart';

class PageIndicatorWidget extends StatelessWidget {
  final int currentPageIndex;
  final int pageCount;
  final Color activeColor;
  final Color inactiveColor;

  const PageIndicatorWidget({
    super.key,
    required this.currentPageIndex,
    required this.pageCount,
    required this.activeColor,
    required this.inactiveColor,
  });

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      children: List.generate(pageCount, (index) {
        return AnimatedContainer(
          duration: const Duration(milliseconds: 300),
          curve: Curves.easeOutCubic,
          margin: const EdgeInsets.symmetric(horizontal: 4.0),
          width: currentPageIndex == index ? 24.0 : 8.0, // Active indicator is wider
          height: 8.0,
          decoration: BoxDecoration(
            color: currentPageIndex == index ? activeColor : inactiveColor,
            borderRadius: BorderRadius.circular(4.0),
          ),
        );
      }),
    );
  }
}

===== FILE: salary_onboarding_page.dart =====
===== PATH: lib/features/onboarding/presentation/widgets/salary_onboarding_page.dart =====

// lib/features/onboarding/presentation/widgets/salary_onboarding_page.dart
import 'package:aboapp/features/settings/domain/entities/settings_entity.dart';
import 'package:aboapp/features/settings/presentation/cubit/settings_cubit.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

class SalaryOnboardingPage extends StatefulWidget {
  const SalaryOnboardingPage({super.key});

  @override
  State<SalaryOnboardingPage> createState() => SalaryOnboardingPageState();
}

class SalaryOnboardingPageState extends State<SalaryOnboardingPage> {
  final _salaryController = TextEditingController();
  SalaryCycle _salaryCycle = SalaryCycle.monthly;
  bool _hasThirteenthSalary = false;

  void saveSettings() {
    final salary = double.tryParse(_salaryController.text.replaceAll(',', '.'));
    if (salary != null && salary > 0) {
      context.read<SettingsCubit>().updateSalarySettings(
            salary: salary,
            salaryCycle: _salaryCycle,
            hasThirteenthSalary: _hasThirteenthSalary,
          );
    }
  }

  @override
  void dispose() {
    _salaryController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 32.0, vertical: 24.0),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          Icon(Icons.insights_rounded, size: 80, color: Colors.blue.shade600),
          const SizedBox(height: 24),
          Text(
            "Optional: Salary Insights",
            textAlign: TextAlign.center,
            style: theme.textTheme.headlineSmall
                ?.copyWith(fontWeight: FontWeight.bold),
          ),
          const SizedBox(height: 12),
          Text(
            "Enter your salary to see what percentage of it goes to subscriptions. This is optional and stored only on your device.",
            textAlign: TextAlign.center,
            style: theme.textTheme.bodyLarge
                ?.copyWith(color: theme.colorScheme.onSurfaceVariant),
          ),
          const SizedBox(height: 32),
          TextFormField(
            controller: _salaryController,
            decoration: InputDecoration(
              labelText: "Salary Amount",
              hintText: "e.g., 5000",
              prefixIcon: Icon(Icons.attach_money_rounded),
            ),
            keyboardType: const TextInputType.numberWithOptions(decimal: true),
            inputFormatters: [
              FilteringTextInputFormatter.allow(RegExp(r'[\d,.]'))
            ],
          ),
          const SizedBox(height: 16),
          SegmentedButton<SalaryCycle>(
            segments: const [
              ButtonSegment(
                  value: SalaryCycle.monthly,
                  label: Text("Monthly"),
                  icon: Icon(Icons.calendar_view_month)),
              ButtonSegment(
                  value: SalaryCycle.yearly,
                  label: Text("Yearly"),
                  icon: Icon(Icons.calendar_today)),
            ],
            selected: {_salaryCycle},
            onSelectionChanged: (newSelection) {
              setState(() {
                _salaryCycle = newSelection.first;
              });
            },
          ),
          const SizedBox(height: 8),
          if (_salaryCycle == SalaryCycle.monthly)
            SwitchListTile.adaptive(
              title: const Text("I receive a 13th salary"),
              value: _hasThirteenthSalary,
              onChanged: (value) {
                setState(() {
                  _hasThirteenthSalary = value;
                });
              },
              contentPadding: EdgeInsets.zero,
            ),
        ],
      ),
    );
  }
}


===== FILE: settings_local_datasource.dart =====
===== PATH: lib/features/settings/data/datasources/settings_local_datasource.dart =====

// lib/features/settings/data/datasources/settings_local_datasource.dart

import 'dart:convert';
import 'package:aboapp/features/settings/data/models/settings_model.dart';
import 'package:aboapp/features/settings/domain/entities/settings_entity.dart';
import 'package:flutter/material.dart';
import 'package:injectable/injectable.dart';
import 'package:shared_preferences/shared_preferences.dart';

abstract class SettingsLocalDataSource {
  Future<SettingsModel> getSettings();
  Future<void> saveThemeMode(ThemeMode themeMode);
  Future<void> saveLocale(Locale locale);
  Future<void> saveCurrencyCode(String currencyCode);
  // NEU
  Future<void> saveSalarySettings({
    required double? salary,
    required SalaryCycle salaryCycle,
    required bool hasThirteenthSalary,
  });
}

const String settingsKey = 'APP_SETTINGS';

@LazySingleton(as: SettingsLocalDataSource)
class SettingsLocalDataSourceImpl implements SettingsLocalDataSource {
  final SharedPreferences sharedPreferences;

  SettingsLocalDataSourceImpl(this.sharedPreferences);

  @override
  Future<SettingsModel> getSettings() async {
    final jsonString = sharedPreferences.getString(settingsKey);
    if (jsonString != null) {
      try {
        return SettingsModel.fromJson(
            jsonDecode(jsonString) as Map<String, dynamic>);
      } catch (e) {
        await sharedPreferences.remove(settingsKey);
        return SettingsModel.fromEntity(SettingsEntity.defaultSettings());
      }
    } else {
      return SettingsModel.fromEntity(SettingsEntity.defaultSettings());
    }
  }

  Future<void> _saveSettingsModel(SettingsModel settings) async {
    await sharedPreferences.setString(
        settingsKey, jsonEncode(settings.toJson()));
  }

  @override
  Future<void> saveThemeMode(ThemeMode themeMode) async {
    final currentSettings = await getSettings();
    await _saveSettingsModel(currentSettings.copyWith(themeMode: themeMode));
  }

  @override
  Future<void> saveLocale(Locale locale) async {
    final currentSettings = await getSettings();
    await _saveSettingsModel(currentSettings.copyWith(locale: locale));
  }

  @override
  Future<void> saveCurrencyCode(String currencyCode) async {
    final currentSettings = await getSettings();
    await _saveSettingsModel(
        currentSettings.copyWith(currencyCode: currencyCode));
  }

  // NEU
  @override
  Future<void> saveSalarySettings(
      {required double? salary,
      required SalaryCycle salaryCycle,
      required bool hasThirteenthSalary}) async {
    final currentSettings = await getSettings();
    await _saveSettingsModel(currentSettings.copyWith(
      salary: salary,
      salaryCycle: salaryCycle,
      hasThirteenthSalary: hasThirteenthSalary,
    ));
  }
}


===== FILE: settings_model.dart =====
===== PATH: lib/features/settings/data/models/settings_model.dart =====

// lib/features/settings/data/models/settings_model.dart

import 'package:aboapp/features/settings/domain/entities/settings_entity.dart';
import 'package:flutter/material.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

part 'settings_model.freezed.dart';
part 'settings_model.g.dart';

// --- Custom converters ---
class SalaryCycleConverter implements JsonConverter<SalaryCycle, String> {
  const SalaryCycleConverter();
  @override
  SalaryCycle fromJson(String json) =>
      SalaryCycle.values.firstWhere((e) => e.toString() == json,
          orElse: () => SalaryCycle.monthly);
  @override
  String toJson(SalaryCycle object) => object.toString();
}

class ThemeModeConverter implements JsonConverter<ThemeMode, String> {
  const ThemeModeConverter();
  @override
  ThemeMode fromJson(String json) => ThemeMode.values
      .firstWhere((e) => e.toString() == json, orElse: () => ThemeMode.system);
  @override
  String toJson(ThemeMode object) => object.toString();
}

class LocaleConverter implements JsonConverter<Locale, String> {
  const LocaleConverter();
  @override
  Locale fromJson(String json) {
    final parts = json.split('_');
    return parts.length == 2 ? Locale(parts[0], parts[1]) : Locale(parts[0]);
  }

  @override
  String toJson(Locale object) => object.toLanguageTag().replaceAll('-', '_');
}
// --- End of converters ---

@freezed
class SettingsModel with _$SettingsModel {
  const SettingsModel._();

  const factory SettingsModel({
    @ThemeModeConverter() required ThemeMode themeMode,
    @LocaleConverter() required Locale locale,
    required String currencyCode,
    // --- NEUE FELDER ---
    double? salary,
    @SalaryCycleConverter()
    @Default(SalaryCycle.monthly)
    SalaryCycle salaryCycle,
    @Default(false) bool hasThirteenthSalary,
  }) = _SettingsModel;

  factory SettingsModel.fromJson(Map<String, dynamic> json) =>
      _$SettingsModelFromJson(json);

  factory SettingsModel.fromEntity(SettingsEntity entity) {
    return SettingsModel(
      themeMode: entity.themeMode,
      locale: entity.locale,
      currencyCode: entity.currencyCode,
      salary: entity.salary,
      salaryCycle: entity.salaryCycle,
      hasThirteenthSalary: entity.hasThirteenthSalary,
    );
  }

  SettingsEntity toEntity() {
    return SettingsEntity(
      themeMode: themeMode,
      locale: locale,
      currencyCode: currencyCode,
      salary: salary,
      salaryCycle: salaryCycle,
      hasThirteenthSalary: hasThirteenthSalary,
    );
  }
}


===== FILE: settings_model.freezed.dart =====
===== PATH: lib/features/settings/data/models/settings_model.freezed.dart =====

// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'settings_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

SettingsModel _$SettingsModelFromJson(Map<String, dynamic> json) {
  return _SettingsModel.fromJson(json);
}

/// @nodoc
mixin _$SettingsModel {
  @ThemeModeConverter()
  ThemeMode get themeMode => throw _privateConstructorUsedError;
  @LocaleConverter()
  Locale get locale => throw _privateConstructorUsedError;
  String get currencyCode =>
      throw _privateConstructorUsedError; // --- NEUE FELDER ---
  double? get salary => throw _privateConstructorUsedError;
  @SalaryCycleConverter()
  SalaryCycle get salaryCycle => throw _privateConstructorUsedError;
  bool get hasThirteenthSalary => throw _privateConstructorUsedError;

  /// Serializes this SettingsModel to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of SettingsModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SettingsModelCopyWith<SettingsModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SettingsModelCopyWith<$Res> {
  factory $SettingsModelCopyWith(
          SettingsModel value, $Res Function(SettingsModel) then) =
      _$SettingsModelCopyWithImpl<$Res, SettingsModel>;
  @useResult
  $Res call(
      {@ThemeModeConverter() ThemeMode themeMode,
      @LocaleConverter() Locale locale,
      String currencyCode,
      double? salary,
      @SalaryCycleConverter() SalaryCycle salaryCycle,
      bool hasThirteenthSalary});
}

/// @nodoc
class _$SettingsModelCopyWithImpl<$Res, $Val extends SettingsModel>
    implements $SettingsModelCopyWith<$Res> {
  _$SettingsModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SettingsModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? themeMode = null,
    Object? locale = null,
    Object? currencyCode = null,
    Object? salary = freezed,
    Object? salaryCycle = null,
    Object? hasThirteenthSalary = null,
  }) {
    return _then(_value.copyWith(
      themeMode: null == themeMode
          ? _value.themeMode
          : themeMode // ignore: cast_nullable_to_non_nullable
              as ThemeMode,
      locale: null == locale
          ? _value.locale
          : locale // ignore: cast_nullable_to_non_nullable
              as Locale,
      currencyCode: null == currencyCode
          ? _value.currencyCode
          : currencyCode // ignore: cast_nullable_to_non_nullable
              as String,
      salary: freezed == salary
          ? _value.salary
          : salary // ignore: cast_nullable_to_non_nullable
              as double?,
      salaryCycle: null == salaryCycle
          ? _value.salaryCycle
          : salaryCycle // ignore: cast_nullable_to_non_nullable
              as SalaryCycle,
      hasThirteenthSalary: null == hasThirteenthSalary
          ? _value.hasThirteenthSalary
          : hasThirteenthSalary // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SettingsModelImplCopyWith<$Res>
    implements $SettingsModelCopyWith<$Res> {
  factory _$$SettingsModelImplCopyWith(
          _$SettingsModelImpl value, $Res Function(_$SettingsModelImpl) then) =
      __$$SettingsModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@ThemeModeConverter() ThemeMode themeMode,
      @LocaleConverter() Locale locale,
      String currencyCode,
      double? salary,
      @SalaryCycleConverter() SalaryCycle salaryCycle,
      bool hasThirteenthSalary});
}

/// @nodoc
class __$$SettingsModelImplCopyWithImpl<$Res>
    extends _$SettingsModelCopyWithImpl<$Res, _$SettingsModelImpl>
    implements _$$SettingsModelImplCopyWith<$Res> {
  __$$SettingsModelImplCopyWithImpl(
      _$SettingsModelImpl _value, $Res Function(_$SettingsModelImpl) _then)
      : super(_value, _then);

  /// Create a copy of SettingsModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? themeMode = null,
    Object? locale = null,
    Object? currencyCode = null,
    Object? salary = freezed,
    Object? salaryCycle = null,
    Object? hasThirteenthSalary = null,
  }) {
    return _then(_$SettingsModelImpl(
      themeMode: null == themeMode
          ? _value.themeMode
          : themeMode // ignore: cast_nullable_to_non_nullable
              as ThemeMode,
      locale: null == locale
          ? _value.locale
          : locale // ignore: cast_nullable_to_non_nullable
              as Locale,
      currencyCode: null == currencyCode
          ? _value.currencyCode
          : currencyCode // ignore: cast_nullable_to_non_nullable
              as String,
      salary: freezed == salary
          ? _value.salary
          : salary // ignore: cast_nullable_to_non_nullable
              as double?,
      salaryCycle: null == salaryCycle
          ? _value.salaryCycle
          : salaryCycle // ignore: cast_nullable_to_non_nullable
              as SalaryCycle,
      hasThirteenthSalary: null == hasThirteenthSalary
          ? _value.hasThirteenthSalary
          : hasThirteenthSalary // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$SettingsModelImpl extends _SettingsModel {
  const _$SettingsModelImpl(
      {@ThemeModeConverter() required this.themeMode,
      @LocaleConverter() required this.locale,
      required this.currencyCode,
      this.salary,
      @SalaryCycleConverter() this.salaryCycle = SalaryCycle.monthly,
      this.hasThirteenthSalary = false})
      : super._();

  factory _$SettingsModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$SettingsModelImplFromJson(json);

  @override
  @ThemeModeConverter()
  final ThemeMode themeMode;
  @override
  @LocaleConverter()
  final Locale locale;
  @override
  final String currencyCode;
// --- NEUE FELDER ---
  @override
  final double? salary;
  @override
  @JsonKey()
  @SalaryCycleConverter()
  final SalaryCycle salaryCycle;
  @override
  @JsonKey()
  final bool hasThirteenthSalary;

  @override
  String toString() {
    return 'SettingsModel(themeMode: $themeMode, locale: $locale, currencyCode: $currencyCode, salary: $salary, salaryCycle: $salaryCycle, hasThirteenthSalary: $hasThirteenthSalary)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SettingsModelImpl &&
            (identical(other.themeMode, themeMode) ||
                other.themeMode == themeMode) &&
            (identical(other.locale, locale) || other.locale == locale) &&
            (identical(other.currencyCode, currencyCode) ||
                other.currencyCode == currencyCode) &&
            (identical(other.salary, salary) || other.salary == salary) &&
            (identical(other.salaryCycle, salaryCycle) ||
                other.salaryCycle == salaryCycle) &&
            (identical(other.hasThirteenthSalary, hasThirteenthSalary) ||
                other.hasThirteenthSalary == hasThirteenthSalary));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, themeMode, locale, currencyCode,
      salary, salaryCycle, hasThirteenthSalary);

  /// Create a copy of SettingsModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SettingsModelImplCopyWith<_$SettingsModelImpl> get copyWith =>
      __$$SettingsModelImplCopyWithImpl<_$SettingsModelImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$SettingsModelImplToJson(
      this,
    );
  }
}

abstract class _SettingsModel extends SettingsModel {
  const factory _SettingsModel(
      {@ThemeModeConverter() required final ThemeMode themeMode,
      @LocaleConverter() required final Locale locale,
      required final String currencyCode,
      final double? salary,
      @SalaryCycleConverter() final SalaryCycle salaryCycle,
      final bool hasThirteenthSalary}) = _$SettingsModelImpl;
  const _SettingsModel._() : super._();

  factory _SettingsModel.fromJson(Map<String, dynamic> json) =
      _$SettingsModelImpl.fromJson;

  @override
  @ThemeModeConverter()
  ThemeMode get themeMode;
  @override
  @LocaleConverter()
  Locale get locale;
  @override
  String get currencyCode; // --- NEUE FELDER ---
  @override
  double? get salary;
  @override
  @SalaryCycleConverter()
  SalaryCycle get salaryCycle;
  @override
  bool get hasThirteenthSalary;

  /// Create a copy of SettingsModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SettingsModelImplCopyWith<_$SettingsModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}


===== FILE: settings_model.g.dart =====
===== PATH: lib/features/settings/data/models/settings_model.g.dart =====

// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'settings_model.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$SettingsModelImpl _$$SettingsModelImplFromJson(Map<String, dynamic> json) =>
    _$SettingsModelImpl(
      themeMode:
          const ThemeModeConverter().fromJson(json['themeMode'] as String),
      locale: const LocaleConverter().fromJson(json['locale'] as String),
      currencyCode: json['currencyCode'] as String,
      salary: (json['salary'] as num?)?.toDouble(),
      salaryCycle: json['salaryCycle'] == null
          ? SalaryCycle.monthly
          : const SalaryCycleConverter()
              .fromJson(json['salaryCycle'] as String),
      hasThirteenthSalary: json['hasThirteenthSalary'] as bool? ?? false,
    );

Map<String, dynamic> _$$SettingsModelImplToJson(_$SettingsModelImpl instance) =>
    <String, dynamic>{
      'themeMode': const ThemeModeConverter().toJson(instance.themeMode),
      'locale': const LocaleConverter().toJson(instance.locale),
      'currencyCode': instance.currencyCode,
      'salary': instance.salary,
      'salaryCycle': const SalaryCycleConverter().toJson(instance.salaryCycle),
      'hasThirteenthSalary': instance.hasThirteenthSalary,
    };


===== FILE: settings_repository_impl.dart =====
===== PATH: lib/features/settings/data/repositories/settings_repository_impl.dart =====

// lib/features/settings/data/repositories/settings_repository_impl.dart

import 'package:aboapp/features/settings/data/datasources/settings_local_datasource.dart';
import 'package:aboapp/features/settings/domain/entities/settings_entity.dart';
import 'package:aboapp/features/settings/domain/repositories/settings_repository.dart';
import 'package:flutter/material.dart';
import 'package:injectable/injectable.dart';

@LazySingleton(as: SettingsRepository)
class SettingsRepositoryImpl implements SettingsRepository {
  final SettingsLocalDataSource localDataSource;

  SettingsRepositoryImpl(this.localDataSource);

  @override
  Future<SettingsEntity> getSettings() async {
    try {
      final settingsModel = await localDataSource.getSettings();
      return settingsModel.toEntity();
    } catch (e) {
      return SettingsEntity.defaultSettings();
    }
  }

  @override
  Future<void> saveThemeMode(ThemeMode themeMode) async {
    await localDataSource.saveThemeMode(themeMode);
  }

  @override
  Future<void> saveLocale(Locale locale) async {
    await localDataSource.saveLocale(locale);
  }

  @override
  Future<void> saveCurrencyCode(String currencyCode) async {
    await localDataSource.saveCurrencyCode(currencyCode);
  }

  // NEU
  @override
  Future<void> saveSalarySettings(
      {required double? salary,
      required SalaryCycle salaryCycle,
      required bool hasThirteenthSalary}) async {
    await localDataSource.saveSalarySettings(
      salary: salary,
      salaryCycle: salaryCycle,
      hasThirteenthSalary: hasThirteenthSalary,
    );
  }
}


===== FILE: settings_entity.dart =====
===== PATH: lib/features/settings/domain/entities/settings_entity.dart =====

// lib/features/settings/domain/entities/settings_entity.dart
import 'package:flutter/material.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

part 'settings_entity.freezed.dart';

// NEU: Enum zur Unterscheidung des Gehaltszyklus
enum SalaryCycle { monthly, yearly }

@freezed
class SettingsEntity with _$SettingsEntity {
  const factory SettingsEntity({
    required ThemeMode themeMode,
    required Locale locale,
    required String currencyCode,
    // --- NEUE FELDER FÜR GEHALT ---
    double? salary,
    @Default(SalaryCycle.monthly) SalaryCycle salaryCycle,
    @Default(false) bool hasThirteenthSalary,
  }) = _SettingsEntity;

  factory SettingsEntity.defaultSettings() => const SettingsEntity(
        themeMode: ThemeMode.system,
        locale: Locale('en', 'US'),
        currencyCode: 'USD',
        salary: null,
        salaryCycle: SalaryCycle.monthly,
        hasThirteenthSalary: false,
      );
}


===== FILE: settings_entity.freezed.dart =====
===== PATH: lib/features/settings/domain/entities/settings_entity.freezed.dart =====

// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'settings_entity.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$SettingsEntity {
  ThemeMode get themeMode => throw _privateConstructorUsedError;
  Locale get locale => throw _privateConstructorUsedError;
  String get currencyCode =>
      throw _privateConstructorUsedError; // --- NEUE FELDER FÜR GEHALT ---
  double? get salary => throw _privateConstructorUsedError;
  SalaryCycle get salaryCycle => throw _privateConstructorUsedError;
  bool get hasThirteenthSalary => throw _privateConstructorUsedError;

  /// Create a copy of SettingsEntity
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SettingsEntityCopyWith<SettingsEntity> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SettingsEntityCopyWith<$Res> {
  factory $SettingsEntityCopyWith(
          SettingsEntity value, $Res Function(SettingsEntity) then) =
      _$SettingsEntityCopyWithImpl<$Res, SettingsEntity>;
  @useResult
  $Res call(
      {ThemeMode themeMode,
      Locale locale,
      String currencyCode,
      double? salary,
      SalaryCycle salaryCycle,
      bool hasThirteenthSalary});
}

/// @nodoc
class _$SettingsEntityCopyWithImpl<$Res, $Val extends SettingsEntity>
    implements $SettingsEntityCopyWith<$Res> {
  _$SettingsEntityCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SettingsEntity
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? themeMode = null,
    Object? locale = null,
    Object? currencyCode = null,
    Object? salary = freezed,
    Object? salaryCycle = null,
    Object? hasThirteenthSalary = null,
  }) {
    return _then(_value.copyWith(
      themeMode: null == themeMode
          ? _value.themeMode
          : themeMode // ignore: cast_nullable_to_non_nullable
              as ThemeMode,
      locale: null == locale
          ? _value.locale
          : locale // ignore: cast_nullable_to_non_nullable
              as Locale,
      currencyCode: null == currencyCode
          ? _value.currencyCode
          : currencyCode // ignore: cast_nullable_to_non_nullable
              as String,
      salary: freezed == salary
          ? _value.salary
          : salary // ignore: cast_nullable_to_non_nullable
              as double?,
      salaryCycle: null == salaryCycle
          ? _value.salaryCycle
          : salaryCycle // ignore: cast_nullable_to_non_nullable
              as SalaryCycle,
      hasThirteenthSalary: null == hasThirteenthSalary
          ? _value.hasThirteenthSalary
          : hasThirteenthSalary // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SettingsEntityImplCopyWith<$Res>
    implements $SettingsEntityCopyWith<$Res> {
  factory _$$SettingsEntityImplCopyWith(_$SettingsEntityImpl value,
          $Res Function(_$SettingsEntityImpl) then) =
      __$$SettingsEntityImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {ThemeMode themeMode,
      Locale locale,
      String currencyCode,
      double? salary,
      SalaryCycle salaryCycle,
      bool hasThirteenthSalary});
}

/// @nodoc
class __$$SettingsEntityImplCopyWithImpl<$Res>
    extends _$SettingsEntityCopyWithImpl<$Res, _$SettingsEntityImpl>
    implements _$$SettingsEntityImplCopyWith<$Res> {
  __$$SettingsEntityImplCopyWithImpl(
      _$SettingsEntityImpl _value, $Res Function(_$SettingsEntityImpl) _then)
      : super(_value, _then);

  /// Create a copy of SettingsEntity
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? themeMode = null,
    Object? locale = null,
    Object? currencyCode = null,
    Object? salary = freezed,
    Object? salaryCycle = null,
    Object? hasThirteenthSalary = null,
  }) {
    return _then(_$SettingsEntityImpl(
      themeMode: null == themeMode
          ? _value.themeMode
          : themeMode // ignore: cast_nullable_to_non_nullable
              as ThemeMode,
      locale: null == locale
          ? _value.locale
          : locale // ignore: cast_nullable_to_non_nullable
              as Locale,
      currencyCode: null == currencyCode
          ? _value.currencyCode
          : currencyCode // ignore: cast_nullable_to_non_nullable
              as String,
      salary: freezed == salary
          ? _value.salary
          : salary // ignore: cast_nullable_to_non_nullable
              as double?,
      salaryCycle: null == salaryCycle
          ? _value.salaryCycle
          : salaryCycle // ignore: cast_nullable_to_non_nullable
              as SalaryCycle,
      hasThirteenthSalary: null == hasThirteenthSalary
          ? _value.hasThirteenthSalary
          : hasThirteenthSalary // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$SettingsEntityImpl implements _SettingsEntity {
  const _$SettingsEntityImpl(
      {required this.themeMode,
      required this.locale,
      required this.currencyCode,
      this.salary,
      this.salaryCycle = SalaryCycle.monthly,
      this.hasThirteenthSalary = false});

  @override
  final ThemeMode themeMode;
  @override
  final Locale locale;
  @override
  final String currencyCode;
// --- NEUE FELDER FÜR GEHALT ---
  @override
  final double? salary;
  @override
  @JsonKey()
  final SalaryCycle salaryCycle;
  @override
  @JsonKey()
  final bool hasThirteenthSalary;

  @override
  String toString() {
    return 'SettingsEntity(themeMode: $themeMode, locale: $locale, currencyCode: $currencyCode, salary: $salary, salaryCycle: $salaryCycle, hasThirteenthSalary: $hasThirteenthSalary)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SettingsEntityImpl &&
            (identical(other.themeMode, themeMode) ||
                other.themeMode == themeMode) &&
            (identical(other.locale, locale) || other.locale == locale) &&
            (identical(other.currencyCode, currencyCode) ||
                other.currencyCode == currencyCode) &&
            (identical(other.salary, salary) || other.salary == salary) &&
            (identical(other.salaryCycle, salaryCycle) ||
                other.salaryCycle == salaryCycle) &&
            (identical(other.hasThirteenthSalary, hasThirteenthSalary) ||
                other.hasThirteenthSalary == hasThirteenthSalary));
  }

  @override
  int get hashCode => Object.hash(runtimeType, themeMode, locale, currencyCode,
      salary, salaryCycle, hasThirteenthSalary);

  /// Create a copy of SettingsEntity
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SettingsEntityImplCopyWith<_$SettingsEntityImpl> get copyWith =>
      __$$SettingsEntityImplCopyWithImpl<_$SettingsEntityImpl>(
          this, _$identity);
}

abstract class _SettingsEntity implements SettingsEntity {
  const factory _SettingsEntity(
      {required final ThemeMode themeMode,
      required final Locale locale,
      required final String currencyCode,
      final double? salary,
      final SalaryCycle salaryCycle,
      final bool hasThirteenthSalary}) = _$SettingsEntityImpl;

  @override
  ThemeMode get themeMode;
  @override
  Locale get locale;
  @override
  String get currencyCode; // --- NEUE FELDER FÜR GEHALT ---
  @override
  double? get salary;
  @override
  SalaryCycle get salaryCycle;
  @override
  bool get hasThirteenthSalary;

  /// Create a copy of SettingsEntity
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SettingsEntityImplCopyWith<_$SettingsEntityImpl> get copyWith =>
      throw _privateConstructorUsedError;
}


===== FILE: settings_repository.dart =====
===== PATH: lib/features/settings/domain/repositories/settings_repository.dart =====

// lib/features/settings/domain/repositories/settings_repository.dart

import 'package:aboapp/features/settings/domain/entities/settings_entity.dart';
import 'package:flutter/material.dart';

abstract class SettingsRepository {
  Future<SettingsEntity> getSettings();
  Future<void> saveThemeMode(ThemeMode themeMode);
  Future<void> saveLocale(Locale locale);
  Future<void> saveCurrencyCode(String currencyCode);
  // NEU
  Future<void> saveSalarySettings({
    required double? salary,
    required SalaryCycle salaryCycle,
    required bool hasThirteenthSalary,
  });
}


===== FILE: get_settings_usecase.dart =====
===== PATH: lib/features/settings/domain/usecases/get_settings_usecase.dart =====

import 'package:aboapp/features/settings/domain/entities/settings_entity.dart';
import 'package:aboapp/features/settings/domain/repositories/settings_repository.dart';
import 'package:injectable/injectable.dart';

@lazySingleton
class GetSettingsUseCase {
  final SettingsRepository repository;

  GetSettingsUseCase(this.repository);

  Future<SettingsEntity> call() async {
    return await repository.getSettings();
  }
}

===== FILE: save_currency_setting_usecase.dart =====
===== PATH: lib/features/settings/domain/usecases/save_currency_setting_usecase.dart =====

import 'package:aboapp/features/settings/domain/repositories/settings_repository.dart';
import 'package:injectable/injectable.dart';

@lazySingleton
class SaveCurrencySettingUseCase {
  final SettingsRepository repository;

  SaveCurrencySettingUseCase(this.repository);

  Future<void> call(String currencyCode) async {
    return await repository.saveCurrencyCode(currencyCode);
  }
}

===== FILE: save_locale_setting_usecase.dart =====
===== PATH: lib/features/settings/domain/usecases/save_locale_setting_usecase.dart =====

import 'package:aboapp/features/settings/domain/repositories/settings_repository.dart';
import 'package:flutter/material.dart'; // For Locale
import 'package:injectable/injectable.dart';

@lazySingleton
class SaveLocaleSettingUseCase {
  final SettingsRepository repository;

  SaveLocaleSettingUseCase(this.repository);

  Future<void> call(Locale locale) async {
    return await repository.saveLocale(locale);
  }
}

===== FILE: save_salary_settings_usecase.dart =====
===== PATH: lib/features/settings/domain/usecases/save_salary_settings_usecase.dart =====

// lib/features/settings/domain/usecases/save_salary_settings_usecase.dart

import 'package:aboapp/features/settings/domain/entities/settings_entity.dart';
import 'package:aboapp/features/settings/domain/repositories/settings_repository.dart';
import 'package:injectable/injectable.dart';

@lazySingleton
class SaveSalarySettingsUseCase {
  final SettingsRepository repository;

  SaveSalarySettingsUseCase(this.repository);

  Future<void> call({
    required double? salary,
    required SalaryCycle salaryCycle,
    required bool hasThirteenthSalary,
  }) async {
    return await repository.saveSalarySettings(
      salary: salary,
      salaryCycle: salaryCycle,
      hasThirteenthSalary: hasThirteenthSalary,
    );
  }
}


===== FILE: save_theme_setting_usecase.dart =====
===== PATH: lib/features/settings/domain/usecases/save_theme_setting_usecase.dart =====

import 'package:aboapp/features/settings/domain/repositories/settings_repository.dart';
import 'package:flutter/material.dart'; // For ThemeMode
import 'package:injectable/injectable.dart';

@lazySingleton
class SaveThemeSettingUseCase {
  final SettingsRepository repository;

  SaveThemeSettingUseCase(this.repository);

  Future<void> call(ThemeMode themeMode) async {
    return await repository.saveThemeMode(themeMode);
  }
}

===== FILE: settings_screen.dart =====
===== PATH: lib/features/settings/presentation/cubit/screens/settings_screen.dart =====

import 'package:aboapp/features/settings/domain/entities/settings_entity.dart';
import 'package:aboapp/features/settings/presentation/cubit/settings_cubit.dart';
import 'package:aboapp/core/utils/currency_formatter.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

class SettingsScreen extends StatefulWidget {
  const SettingsScreen({super.key});

  @override
  State<SettingsScreen> createState() => _SettingsScreenState();
}

class _SettingsScreenState extends State<SettingsScreen> {
  final _salaryController = TextEditingController();
  SalaryCycle? _salaryCycle;
  bool? _hasThirteenthSalary;

  @override
  void initState() {
    super.initState();
    final settingsState = context.read<SettingsCubit>().state;
    _updateLocalState(settingsState);
  }

  void _updateLocalState(SettingsState state) {
    if (state.salary != null) {
      _salaryController.text = state.salary.toString();
    }
    _salaryCycle = state.salaryCycle;
    _hasThirteenthSalary = state.hasThirteenthSalary;
  }

  @override
  void dispose() {
    _salaryController.dispose();
    super.dispose();
  }

  void _saveSalary() {
    final salary = double.tryParse(_salaryController.text.replaceAll(',', '.'));
    context.read<SettingsCubit>().updateSalarySettings(
          salary: salary,
          salaryCycle: _salaryCycle,
          hasThirteenthSalary: _hasThirteenthSalary,
        );
    FocusScope.of(context).unfocus(); // Close keyboard
  }

  String _getThemeModeDisplayName(BuildContext context, ThemeMode themeMode) {
    switch (themeMode) {
      case ThemeMode.system:
        return 'System Default';
      case ThemeMode.light:
        return 'Light';
      case ThemeMode.dark:
        return 'Dark';
    }
  }

  String _getLocaleDisplayName(BuildContext context, Locale locale) {
    if (locale.languageCode == 'en') return 'English';
    if (locale.languageCode == 'de') return 'Deutsch (German)';
    return locale.toLanguageTag();
  }

  static const Map<String, String> _supportedCurrencies = {
    'USD': 'USD - United States Dollar (\$)',
    'EUR': 'EUR - Euro (€)',
    'GBP': 'GBP - British Pound (£)',
    'JPY': 'JPY - Japanese Yen (¥)',
    'CHF': 'CHF - Swiss Franc (CHF)',
  };

  @override
  Widget build(BuildContext context) {
    return BlocListener<SettingsCubit, SettingsState>(
      listener: (context, state) {
        // Update local form state if cubit state changes from another source
        _updateLocalState(state);
      },
      child: Scaffold(
        appBar: AppBar(
          title: const Text('Settings'),
        ),
        body: BlocBuilder<SettingsCubit, SettingsState>(
          builder: (context, state) {
            if (state.isLoading) {
              return const Center(child: CircularProgressIndicator.adaptive());
            }
            if (state.error != null) {
              return Center(
                  child: Text('Error loading settings: ${state.error}'));
            }

            return ListView(
              padding: const EdgeInsets.all(16.0),
              children: <Widget>[
                _buildSectionHeader(context, 'Appearance'),
                _buildAppearanceSection(context, state),
                const Divider(height: 32),
                _buildSectionHeader(context, 'Regional'),
                _buildRegionalSection(context, state),
                const Divider(height: 32),
                _buildSectionHeader(context, 'Salary Insights'),
                _buildSalarySection(context, state),
                const Divider(height: 32),
                _buildSectionHeader(context, 'About'),
                _buildAboutSection(context),
              ],
            );
          },
        ),
      ),
    );
  }

  Widget _buildAppearanceSection(BuildContext context, SettingsState state) {
    return Card(
      child: ListTile(
        leading: const Icon(Icons.brightness_6_rounded),
        title: const Text('Theme'),
        subtitle: Text(_getThemeModeDisplayName(context, state.themeMode)),
        onTap: () => _showThemeModeDialog(context, state.themeMode),
      ),
    );
  }

  Widget _buildRegionalSection(BuildContext context, SettingsState state) {
    return Card(
      child: Column(
        children: [
          ListTile(
            leading: const Icon(Icons.language_rounded),
            title: const Text('Language'),
            subtitle: Text(_getLocaleDisplayName(context, state.locale)),
            onTap: () => _showLocaleDialog(context, state.locale),
          ),
          ListTile(
            leading: const Icon(Icons.attach_money_rounded),
            title: const Text('Currency'),
            subtitle: Text(
                _supportedCurrencies[state.currencyCode] ?? state.currencyCode),
            onTap: () => _showCurrencyDialog(context, state.currencyCode),
          ),
        ],
      ),
    );
  }

  Widget _buildSalarySection(BuildContext context, SettingsState state) {
    final theme = Theme.of(context);
    final currencySymbol =
        CurrencyFormatter.getCurrencySymbol(state.currencyCode);

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              "Your Salary",
              style: theme.textTheme.titleMedium,
            ),
            const SizedBox(height: 4),
            Text(
              "This is optional and helps generate personal spending statistics. The data is stored only on your device.",
              style: theme.textTheme.bodySmall
                  ?.copyWith(color: theme.colorScheme.onSurfaceVariant),
            ),
            const SizedBox(height: 16),
            TextFormField(
              controller: _salaryController,
              decoration: InputDecoration(
                labelText: "Salary Amount",
                prefixText: "$currencySymbol ",
              ),
              keyboardType:
                  const TextInputType.numberWithOptions(decimal: true),
              inputFormatters: [
                FilteringTextInputFormatter.allow(RegExp(r'[\d,.]'))
              ],
              onEditingComplete: _saveSalary,
            ),
            const SizedBox(height: 16),
            SegmentedButton<SalaryCycle>(
              segments: const [
                ButtonSegment(
                    value: SalaryCycle.monthly, label: Text("Monthly")),
                ButtonSegment(value: SalaryCycle.yearly, label: Text("Yearly")),
              ],
              selected: {_salaryCycle ?? SalaryCycle.monthly},
              onSelectionChanged: (newSelection) {
                setState(() => _salaryCycle = newSelection.first);
                _saveSalary();
              },
            ),
            if (_salaryCycle == SalaryCycle.monthly)
              SwitchListTile.adaptive(
                title: const Text("I receive a 13th salary"),
                value: _hasThirteenthSalary ?? false,
                onChanged: (value) {
                  setState(() => _hasThirteenthSalary = value);
                  _saveSalary();
                },
                contentPadding: EdgeInsets.zero,
              ),
          ],
        ),
      ),
    );
  }

  Widget _buildAboutSection(BuildContext context) {
    return Card(
      child: ListTile(
        leading: const Icon(Icons.info_outline_rounded),
        title: const Text('About AboApp'),
        subtitle: const Text('Version 3.0.0 - Refactored'),
        onTap: () {
          showDialog(
            context: context,
            builder: (ctx) => AlertDialog(
              title: const Text('About AboApp'),
              content: const Text(
                  'Subscription management made easy.\nVersion 3.0.0'),
              actions: [
                TextButton(
                  onPressed: () => Navigator.of(ctx).pop(),
                  child: const Text('Close'),
                )
              ],
            ),
          );
        },
      ),
    );
  }

  Widget _buildSectionHeader(BuildContext context, String title) {
    return Padding(
      padding:
          const EdgeInsets.only(top: 8.0, bottom: 8.0, left: 8.0, right: 8.0),
      child: Text(
        title,
        style: Theme.of(context).textTheme.titleSmall?.copyWith(
              color: Theme.of(context).colorScheme.primary,
              fontWeight: FontWeight.w600,
            ),
      ),
    );
  }

  void _showThemeModeDialog(BuildContext context, ThemeMode currentThemeMode) {
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('Select Theme'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: ThemeMode.values.map((themeMode) {
            return RadioListTile<ThemeMode>(
              title: Text(_getThemeModeDisplayName(context, themeMode)),
              value: themeMode,
              groupValue: currentThemeMode,
              onChanged: (value) {
                if (value != null) {
                  context.read<SettingsCubit>().updateThemeMode(value);
                  Navigator.of(ctx).pop();
                }
              },
            );
          }).toList(),
        ),
      ),
    );
  }

  void _showLocaleDialog(BuildContext context, Locale currentLocale) {
    const supportedLocales = [Locale('en', 'US'), Locale('de', 'DE')];
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('Select Language'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: supportedLocales.map((locale) {
            return RadioListTile<Locale>(
              title: Text(_getLocaleDisplayName(context, locale)),
              value: locale,
              groupValue: currentLocale,
              onChanged: (value) {
                if (value != null) {
                  context.read<SettingsCubit>().updateLocale(value);
                  Navigator.of(ctx).pop();
                }
              },
            );
          }).toList(),
        ),
      ),
    );
  }

  void _showCurrencyDialog(BuildContext context, String currentCurrencyCode) {
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('Select Currency'),
        content: SizedBox(
          width: double.maxFinite,
          child: ListView(
            shrinkWrap: true,
            children: _supportedCurrencies.entries.map((entry) {
              return RadioListTile<String>(
                title: Text(entry.value),
                value: entry.key,
                groupValue: currentCurrencyCode,
                onChanged: (value) {
                  if (value != null) {
                    context.read<SettingsCubit>().updateCurrencyCode(value);
                    Navigator.of(ctx).pop();
                  }
                },
              );
            }).toList(),
          ),
        ),
      ),
    );
  }
}


===== FILE: settings_cubit.dart =====
===== PATH: lib/features/settings/presentation/cubit/settings_cubit.dart =====

// lib/features/settings/presentation/cubit/settings_cubit.dart

import 'package:aboapp/features/settings/domain/entities/settings_entity.dart';
import 'package:aboapp/features/settings/domain/usecases/get_settings_usecase.dart';
import 'package:aboapp/features/settings/domain/usecases/save_currency_setting_usecase.dart';
import 'package:aboapp/features/settings/domain/usecases/save_locale_setting_usecase.dart';
import 'package:aboapp/features/settings/domain/usecases/save_salary_settings_usecase.dart';
import 'package:aboapp/features/settings/domain/usecases/save_theme_setting_usecase.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:injectable/injectable.dart';

part 'settings_state.dart';
part 'settings_cubit.freezed.dart';

@injectable
class SettingsCubit extends Cubit<SettingsState> {
  final GetSettingsUseCase _getSettings;
  final SaveThemeSettingUseCase _saveThemeSetting;
  final SaveLocaleSettingUseCase _saveLocaleSetting;
  final SaveCurrencySettingUseCase _saveCurrencySetting;
  final SaveSalarySettingsUseCase _saveSalarySettings;

  SettingsCubit(
    this._getSettings,
    this._saveThemeSetting,
    this._saveLocaleSetting,
    this._saveCurrencySetting,
    this._saveSalarySettings,
  ) : super(SettingsState.initial());

  Future<void> loadSettings() async {
    emit(state.copyWith(isLoading: true, error: null));
    try {
      final settingsEntity = await _getSettings();
      emit(state.copyWith(
        themeMode: settingsEntity.themeMode,
        locale: settingsEntity.locale,
        currencyCode: settingsEntity.currencyCode,
        salary: settingsEntity.salary,
        salaryCycle: settingsEntity.salaryCycle,
        hasThirteenthSalary: settingsEntity.hasThirteenthSalary,
        isLoading: false,
      ));
    } catch (e) {
      emit(state.copyWith(isLoading: false, error: e.toString()));
    }
  }

  Future<void> updateSalarySettings({
    double? salary,
    SalaryCycle? salaryCycle,
    bool? hasThirteenthSalary,
  }) async {
    // Wenn ein Wert null ist, den aktuellen State-Wert verwenden
    final newSalary = salary ?? state.salary;
    final newCycle = salaryCycle ?? state.salaryCycle;
    final newHasThirteenth = hasThirteenthSalary ?? state.hasThirteenthSalary;

    emit(state.copyWith(isLoading: true, error: null));
    try {
      await _saveSalarySettings(
        salary: newSalary,
        salaryCycle: newCycle,
        hasThirteenthSalary: newHasThirteenth,
      );
      emit(state.copyWith(
        salary: newSalary,
        salaryCycle: newCycle,
        hasThirteenthSalary: newHasThirteenth,
        isLoading: false,
      ));
    } catch (e) {
      emit(state.copyWith(isLoading: false, error: e.toString()));
    }
  }

  Future<void> updateThemeMode(ThemeMode newThemeMode) async {
    emit(state.copyWith(isLoading: true, error: null));
    try {
      await _saveThemeSetting(newThemeMode);
      emit(state.copyWith(themeMode: newThemeMode, isLoading: false));
    } catch (e) {
      emit(state.copyWith(isLoading: false, error: e.toString()));
    }
  }

  Future<void> updateLocale(Locale newLocale) async {
    emit(state.copyWith(isLoading: true, error: null));
    try {
      await _saveLocaleSetting(newLocale);
      emit(state.copyWith(locale: newLocale, isLoading: false));
    } catch (e) {
      emit(state.copyWith(isLoading: false, error: e.toString()));
    }
  }

  Future<void> updateCurrencyCode(String newCurrencyCode) async {
    emit(state.copyWith(isLoading: true, error: null));
    try {
      await _saveCurrencySetting(newCurrencyCode);
      emit(state.copyWith(currencyCode: newCurrencyCode, isLoading: false));
    } catch (e) {
      emit(state.copyWith(isLoading: false, error: e.toString()));
    }
  }
}


===== FILE: settings_cubit.freezed.dart =====
===== PATH: lib/features/settings/presentation/cubit/settings_cubit.freezed.dart =====

// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'settings_cubit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$SettingsState {
  ThemeMode get themeMode => throw _privateConstructorUsedError;
  Locale get locale => throw _privateConstructorUsedError;
  String get currencyCode => throw _privateConstructorUsedError;
  double? get salary => throw _privateConstructorUsedError;
  SalaryCycle get salaryCycle => throw _privateConstructorUsedError;
  bool get hasThirteenthSalary => throw _privateConstructorUsedError;
  bool get isLoading => throw _privateConstructorUsedError;
  String? get error => throw _privateConstructorUsedError;

  /// Create a copy of SettingsState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SettingsStateCopyWith<SettingsState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SettingsStateCopyWith<$Res> {
  factory $SettingsStateCopyWith(
          SettingsState value, $Res Function(SettingsState) then) =
      _$SettingsStateCopyWithImpl<$Res, SettingsState>;
  @useResult
  $Res call(
      {ThemeMode themeMode,
      Locale locale,
      String currencyCode,
      double? salary,
      SalaryCycle salaryCycle,
      bool hasThirteenthSalary,
      bool isLoading,
      String? error});
}

/// @nodoc
class _$SettingsStateCopyWithImpl<$Res, $Val extends SettingsState>
    implements $SettingsStateCopyWith<$Res> {
  _$SettingsStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SettingsState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? themeMode = null,
    Object? locale = null,
    Object? currencyCode = null,
    Object? salary = freezed,
    Object? salaryCycle = null,
    Object? hasThirteenthSalary = null,
    Object? isLoading = null,
    Object? error = freezed,
  }) {
    return _then(_value.copyWith(
      themeMode: null == themeMode
          ? _value.themeMode
          : themeMode // ignore: cast_nullable_to_non_nullable
              as ThemeMode,
      locale: null == locale
          ? _value.locale
          : locale // ignore: cast_nullable_to_non_nullable
              as Locale,
      currencyCode: null == currencyCode
          ? _value.currencyCode
          : currencyCode // ignore: cast_nullable_to_non_nullable
              as String,
      salary: freezed == salary
          ? _value.salary
          : salary // ignore: cast_nullable_to_non_nullable
              as double?,
      salaryCycle: null == salaryCycle
          ? _value.salaryCycle
          : salaryCycle // ignore: cast_nullable_to_non_nullable
              as SalaryCycle,
      hasThirteenthSalary: null == hasThirteenthSalary
          ? _value.hasThirteenthSalary
          : hasThirteenthSalary // ignore: cast_nullable_to_non_nullable
              as bool,
      isLoading: null == isLoading
          ? _value.isLoading
          : isLoading // ignore: cast_nullable_to_non_nullable
              as bool,
      error: freezed == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SettingsStateImplCopyWith<$Res>
    implements $SettingsStateCopyWith<$Res> {
  factory _$$SettingsStateImplCopyWith(
          _$SettingsStateImpl value, $Res Function(_$SettingsStateImpl) then) =
      __$$SettingsStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {ThemeMode themeMode,
      Locale locale,
      String currencyCode,
      double? salary,
      SalaryCycle salaryCycle,
      bool hasThirteenthSalary,
      bool isLoading,
      String? error});
}

/// @nodoc
class __$$SettingsStateImplCopyWithImpl<$Res>
    extends _$SettingsStateCopyWithImpl<$Res, _$SettingsStateImpl>
    implements _$$SettingsStateImplCopyWith<$Res> {
  __$$SettingsStateImplCopyWithImpl(
      _$SettingsStateImpl _value, $Res Function(_$SettingsStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of SettingsState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? themeMode = null,
    Object? locale = null,
    Object? currencyCode = null,
    Object? salary = freezed,
    Object? salaryCycle = null,
    Object? hasThirteenthSalary = null,
    Object? isLoading = null,
    Object? error = freezed,
  }) {
    return _then(_$SettingsStateImpl(
      themeMode: null == themeMode
          ? _value.themeMode
          : themeMode // ignore: cast_nullable_to_non_nullable
              as ThemeMode,
      locale: null == locale
          ? _value.locale
          : locale // ignore: cast_nullable_to_non_nullable
              as Locale,
      currencyCode: null == currencyCode
          ? _value.currencyCode
          : currencyCode // ignore: cast_nullable_to_non_nullable
              as String,
      salary: freezed == salary
          ? _value.salary
          : salary // ignore: cast_nullable_to_non_nullable
              as double?,
      salaryCycle: null == salaryCycle
          ? _value.salaryCycle
          : salaryCycle // ignore: cast_nullable_to_non_nullable
              as SalaryCycle,
      hasThirteenthSalary: null == hasThirteenthSalary
          ? _value.hasThirteenthSalary
          : hasThirteenthSalary // ignore: cast_nullable_to_non_nullable
              as bool,
      isLoading: null == isLoading
          ? _value.isLoading
          : isLoading // ignore: cast_nullable_to_non_nullable
              as bool,
      error: freezed == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$SettingsStateImpl implements _SettingsState {
  const _$SettingsStateImpl(
      {required this.themeMode,
      required this.locale,
      required this.currencyCode,
      this.salary,
      this.salaryCycle = SalaryCycle.monthly,
      this.hasThirteenthSalary = false,
      this.isLoading = false,
      this.error});

  @override
  final ThemeMode themeMode;
  @override
  final Locale locale;
  @override
  final String currencyCode;
  @override
  final double? salary;
  @override
  @JsonKey()
  final SalaryCycle salaryCycle;
  @override
  @JsonKey()
  final bool hasThirteenthSalary;
  @override
  @JsonKey()
  final bool isLoading;
  @override
  final String? error;

  @override
  String toString() {
    return 'SettingsState(themeMode: $themeMode, locale: $locale, currencyCode: $currencyCode, salary: $salary, salaryCycle: $salaryCycle, hasThirteenthSalary: $hasThirteenthSalary, isLoading: $isLoading, error: $error)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SettingsStateImpl &&
            (identical(other.themeMode, themeMode) ||
                other.themeMode == themeMode) &&
            (identical(other.locale, locale) || other.locale == locale) &&
            (identical(other.currencyCode, currencyCode) ||
                other.currencyCode == currencyCode) &&
            (identical(other.salary, salary) || other.salary == salary) &&
            (identical(other.salaryCycle, salaryCycle) ||
                other.salaryCycle == salaryCycle) &&
            (identical(other.hasThirteenthSalary, hasThirteenthSalary) ||
                other.hasThirteenthSalary == hasThirteenthSalary) &&
            (identical(other.isLoading, isLoading) ||
                other.isLoading == isLoading) &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode => Object.hash(runtimeType, themeMode, locale, currencyCode,
      salary, salaryCycle, hasThirteenthSalary, isLoading, error);

  /// Create a copy of SettingsState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SettingsStateImplCopyWith<_$SettingsStateImpl> get copyWith =>
      __$$SettingsStateImplCopyWithImpl<_$SettingsStateImpl>(this, _$identity);
}

abstract class _SettingsState implements SettingsState {
  const factory _SettingsState(
      {required final ThemeMode themeMode,
      required final Locale locale,
      required final String currencyCode,
      final double? salary,
      final SalaryCycle salaryCycle,
      final bool hasThirteenthSalary,
      final bool isLoading,
      final String? error}) = _$SettingsStateImpl;

  @override
  ThemeMode get themeMode;
  @override
  Locale get locale;
  @override
  String get currencyCode;
  @override
  double? get salary;
  @override
  SalaryCycle get salaryCycle;
  @override
  bool get hasThirteenthSalary;
  @override
  bool get isLoading;
  @override
  String? get error;

  /// Create a copy of SettingsState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SettingsStateImplCopyWith<_$SettingsStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}


===== FILE: settings_state.dart =====
===== PATH: lib/features/settings/presentation/cubit/settings_state.dart =====

// lib/features/settings/presentation/cubit/settings_state.dart
part of 'settings_cubit.dart';

@freezed
class SettingsState with _$SettingsState {
  const factory SettingsState({
    required ThemeMode themeMode,
    required Locale locale,
    required String currencyCode,
    double? salary,
    @Default(SalaryCycle.monthly) SalaryCycle salaryCycle,
    @Default(false) bool hasThirteenthSalary,
    @Default(false) bool isLoading,
    String? error,
  }) = _SettingsState;

  factory SettingsState.initial() => const SettingsState(
        themeMode: ThemeMode.system,
        locale: Locale('en', 'US'),
        currencyCode: 'USD',
        salary: null,
        salaryCycle: SalaryCycle.monthly,
        hasThirteenthSalary: false,
      );
}


===== FILE: statistics_cubit.dart =====
===== PATH: lib/features/statistics/presentation/cubit/statistics_cubit.dart =====

import 'dart:async';
import 'package:aboapp/features/settings/domain/entities/settings_entity.dart';
import 'package:aboapp/features/settings/presentation/cubit/settings_cubit.dart';
import 'package:aboapp/features/subscriptions/domain/entities/subscription_entity.dart';
import 'package:aboapp/features/subscriptions/presentation/cubit/subscription_cubit.dart';
import 'package:fl_chart/fl_chart.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:collection/collection.dart';

part 'statistics_state.dart';
part 'statistics_cubit.freezed.dart';

class StatisticsCubit extends Cubit<StatisticsState> {
  final SubscriptionCubit _subscriptionCubit;
  final SettingsCubit _settingsCubit;
  late final StreamSubscription _subscriptionSubscription;
  late final StreamSubscription _settingsSubscription;

  List<SubscriptionEntity> _latestSubscriptions = [];
  late SettingsEntity _latestSettings;

  StatisticsCubit({
    required SubscriptionCubit subscriptionCubit,
    required SettingsCubit settingsCubit,
  })  : _subscriptionCubit = subscriptionCubit,
        _settingsCubit = settingsCubit,
        super(const StatisticsState.initial()) {
    _updateLatestStates();

    _subscriptionSubscription = _subscriptionCubit.stream.listen((_) {
      _updateLatestStatesAndRecalculate();
    });
    _settingsSubscription = _settingsCubit.stream.listen((_) {
      _updateLatestStatesAndRecalculate();
    });
  }

  void _updateLatestStates() {
    _subscriptionCubit.state.whenOrNull(
      loaded: (all, _, __, ___, ____, _____) {
        _latestSubscriptions = all;
      },
    );
    final settingsState = _settingsCubit.state;
    _latestSettings = SettingsEntity(
      themeMode: settingsState.themeMode,
      locale: settingsState.locale,
      currencyCode: settingsState.currencyCode,
      salary: settingsState.salary,
      salaryCycle: settingsState.salaryCycle,
      hasThirteenthSalary: settingsState.hasThirteenthSalary,
    );
  }

  void _updateLatestStatesAndRecalculate() {
    _updateLatestStates();
    generateStatistics();
  }

  @override
  Future<void> close() {
    _subscriptionSubscription.cancel();
    _settingsSubscription.cancel();
    return super.close();
  }

  void generateStatistics({int? yearForTrend}) {
    emit(const StatisticsState.loading());

    final allSubscriptions = _latestSubscriptions;
    final settings = _latestSettings;

    final activeSubscriptions =
        allSubscriptions.where((s) => s.isActive).toList();

    if (activeSubscriptions.isEmpty) {
      emit(const StatisticsState.empty(
          message: 'No active subscriptions to generate statistics.'));
      return;
    }

    try {
      final totalMonthlyEquivalent =
          activeSubscriptions.sumByDouble((s) => s.monthlyEquivalentPrice);
      final totalYearlyEquivalent = totalMonthlyEquivalent * 12;

      final Map<SubscriptionCategory, double> categoryTotals = {};
      for (var sub in activeSubscriptions) {
        categoryTotals.update(
          sub.category,
          (value) => value + sub.monthlyEquivalentPrice,
          ifAbsent: () => sub.monthlyEquivalentPrice,
        );
      }
      final List<CategorySpending> categorySpendingData = categoryTotals.entries
          .map((entry) => CategorySpending(
                category: entry.key,
                totalAmount: entry.value,
                percentage: totalMonthlyEquivalent > 0
                    ? (entry.value / totalMonthlyEquivalent)
                    : 0.0,
              ))
          .sortedBy<num>((cs) => cs.totalAmount)
          .reversed
          .toList();

      final Map<BillingCycle, List<SubscriptionEntity>> subsByBillingCycle = {};
      for (var sub in activeSubscriptions) {
        subsByBillingCycle.putIfAbsent(sub.billingCycle, () => []).add(sub);
      }
      final List<BillingTypeSpending> billingTypeSpendingData =
          subsByBillingCycle.entries
              .map((entry) {
                final cycleTotalMonthlyEquiv =
                    entry.value.sumByDouble((s) => s.monthlyEquivalentPrice);
                return BillingTypeSpending(
                  billingCycle: entry.key,
                  totalAmount: cycleTotalMonthlyEquiv,
                  subscriptionCount: entry.value.length,
                  percentageOfTotal: totalMonthlyEquivalent > 0
                      ? (cycleTotalMonthlyEquiv / totalMonthlyEquivalent)
                      : 0.0,
                );
              })
              .sortedBy<num>((bs) => bs.totalAmount)
              .reversed
              .toList();

      final List<SubscriptionEntity> topSpendingSubscriptions =
          List.from(activeSubscriptions)
            ..sort((a, b) =>
                b.monthlyEquivalentPrice.compareTo(a.monthlyEquivalentPrice));
      final topN = topSpendingSubscriptions.take(5).toList();

      final int trendYear = yearForTrend ??
          state.maybeWhen(
              loaded: (
                _,
                __,
                ___,
                ____,
                _____,
                ______,
                _______,
                trendYear,
                ________,
                _________,
              ) =>
                  trendYear,
              orElse: () => DateTime.now().year);

      final List<FlSpot> spots = [];
      double maxSpendingInYear = 0.0;
      for (int month = 1; month <= 12; month++) {
        double monthlyTotalForTrend = 0.0;
        for (final sub in activeSubscriptions) {
          if (sub.startDate != null &&
              (sub.startDate!.year < trendYear ||
                  (sub.startDate!.year == trendYear &&
                      sub.startDate!.month <= month))) {
            monthlyTotalForTrend += sub.monthlyEquivalentPrice;
          }
        }
        spots.add(FlSpot(month.toDouble(), monthlyTotalForTrend));
        if (monthlyTotalForTrend > maxSpendingInYear) {
          maxSpendingInYear = monthlyTotalForTrend;
        }
      }
      final spendingTrendData = MonthlySpendingTrendData(
        year: trendYear,
        spots: spots,
        maxSpendingInYear: maxSpendingInYear,
      );

      double? percentageOfSalary;
      double yearlySalary = 0;
      if (settings.salary != null && settings.salary! > 0) {
        if (settings.salaryCycle == SalaryCycle.yearly) {
          yearlySalary = settings.salary!;
        } else {
          yearlySalary =
              settings.salary! * (settings.hasThirteenthSalary ? 13 : 12);
        }
      }
      if (yearlySalary > 0) {
        percentageOfSalary = (totalYearlyEquivalent / yearlySalary);
      }

      emit(StatisticsState.loaded(
        activeSubscriptions: activeSubscriptions,
        categorySpendingData: categorySpendingData,
        billingTypeSpendingData: billingTypeSpendingData,
        topSpendingSubscriptions: topN,
        spendingTrendData: spendingTrendData,
        totalMonthlyEquivalentSpending: totalMonthlyEquivalent,
        totalYearlyEquivalentSpending: totalYearlyEquivalent,
        selectedYearForTrend: trendYear,
        yearlySalary: yearlySalary > 0 ? yearlySalary : null,
        percentageOfSalary: percentageOfSalary,
      ));
    } catch (e) {
      emit(StatisticsState.error(
          message: "Failed to generate statistics: ${e.toString()}"));
    }
  }

  void changeTrendYear(int newYear) {
    generateStatistics(yearForTrend: newYear);
  }
}

extension SumByDouble<T> on Iterable<T> {
  double sumByDouble(double Function(T element) f) {
    double sum = 0;
    for (var element in this) {
      sum += f(element);
    }
    return sum;
  }
}


===== FILE: statistics_cubit.freezed.dart =====
===== PATH: lib/features/statistics/presentation/cubit/statistics_cubit.freezed.dart =====

// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'statistics_cubit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$StatisticsState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            List<SubscriptionEntity> activeSubscriptions,
            List<CategorySpending> categorySpendingData,
            List<BillingTypeSpending> billingTypeSpendingData,
            List<SubscriptionEntity> topSpendingSubscriptions,
            MonthlySpendingTrendData spendingTrendData,
            double totalMonthlyEquivalentSpending,
            double totalYearlyEquivalentSpending,
            int selectedYearForTrend,
            double? yearlySalary,
            double? percentageOfSalary)
        loaded,
    required TResult Function(String message) error,
    required TResult Function(String message) empty,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(
            List<SubscriptionEntity> activeSubscriptions,
            List<CategorySpending> categorySpendingData,
            List<BillingTypeSpending> billingTypeSpendingData,
            List<SubscriptionEntity> topSpendingSubscriptions,
            MonthlySpendingTrendData spendingTrendData,
            double totalMonthlyEquivalentSpending,
            double totalYearlyEquivalentSpending,
            int selectedYearForTrend,
            double? yearlySalary,
            double? percentageOfSalary)?
        loaded,
    TResult? Function(String message)? error,
    TResult? Function(String message)? empty,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            List<SubscriptionEntity> activeSubscriptions,
            List<CategorySpending> categorySpendingData,
            List<BillingTypeSpending> billingTypeSpendingData,
            List<SubscriptionEntity> topSpendingSubscriptions,
            MonthlySpendingTrendData spendingTrendData,
            double totalMonthlyEquivalentSpending,
            double totalYearlyEquivalentSpending,
            int selectedYearForTrend,
            double? yearlySalary,
            double? percentageOfSalary)?
        loaded,
    TResult Function(String message)? error,
    TResult Function(String message)? empty,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
    required TResult Function(_Empty value) empty,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
    TResult? Function(_Empty value)? empty,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    TResult Function(_Empty value)? empty,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StatisticsStateCopyWith<$Res> {
  factory $StatisticsStateCopyWith(
          StatisticsState value, $Res Function(StatisticsState) then) =
      _$StatisticsStateCopyWithImpl<$Res, StatisticsState>;
}

/// @nodoc
class _$StatisticsStateCopyWithImpl<$Res, $Val extends StatisticsState>
    implements $StatisticsStateCopyWith<$Res> {
  _$StatisticsStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of StatisticsState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$InitialImplCopyWith<$Res> {
  factory _$$InitialImplCopyWith(
          _$InitialImpl value, $Res Function(_$InitialImpl) then) =
      __$$InitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitialImplCopyWithImpl<$Res>
    extends _$StatisticsStateCopyWithImpl<$Res, _$InitialImpl>
    implements _$$InitialImplCopyWith<$Res> {
  __$$InitialImplCopyWithImpl(
      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)
      : super(_value, _then);

  /// Create a copy of StatisticsState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$InitialImpl implements _Initial {
  const _$InitialImpl();

  @override
  String toString() {
    return 'StatisticsState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            List<SubscriptionEntity> activeSubscriptions,
            List<CategorySpending> categorySpendingData,
            List<BillingTypeSpending> billingTypeSpendingData,
            List<SubscriptionEntity> topSpendingSubscriptions,
            MonthlySpendingTrendData spendingTrendData,
            double totalMonthlyEquivalentSpending,
            double totalYearlyEquivalentSpending,
            int selectedYearForTrend,
            double? yearlySalary,
            double? percentageOfSalary)
        loaded,
    required TResult Function(String message) error,
    required TResult Function(String message) empty,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(
            List<SubscriptionEntity> activeSubscriptions,
            List<CategorySpending> categorySpendingData,
            List<BillingTypeSpending> billingTypeSpendingData,
            List<SubscriptionEntity> topSpendingSubscriptions,
            MonthlySpendingTrendData spendingTrendData,
            double totalMonthlyEquivalentSpending,
            double totalYearlyEquivalentSpending,
            int selectedYearForTrend,
            double? yearlySalary,
            double? percentageOfSalary)?
        loaded,
    TResult? Function(String message)? error,
    TResult? Function(String message)? empty,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            List<SubscriptionEntity> activeSubscriptions,
            List<CategorySpending> categorySpendingData,
            List<BillingTypeSpending> billingTypeSpendingData,
            List<SubscriptionEntity> topSpendingSubscriptions,
            MonthlySpendingTrendData spendingTrendData,
            double totalMonthlyEquivalentSpending,
            double totalYearlyEquivalentSpending,
            int selectedYearForTrend,
            double? yearlySalary,
            double? percentageOfSalary)?
        loaded,
    TResult Function(String message)? error,
    TResult Function(String message)? empty,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
    required TResult Function(_Empty value) empty,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
    TResult? Function(_Empty value)? empty,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    TResult Function(_Empty value)? empty,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements StatisticsState {
  const factory _Initial() = _$InitialImpl;
}

/// @nodoc
abstract class _$$LoadingImplCopyWith<$Res> {
  factory _$$LoadingImplCopyWith(
          _$LoadingImpl value, $Res Function(_$LoadingImpl) then) =
      __$$LoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadingImplCopyWithImpl<$Res>
    extends _$StatisticsStateCopyWithImpl<$Res, _$LoadingImpl>
    implements _$$LoadingImplCopyWith<$Res> {
  __$$LoadingImplCopyWithImpl(
      _$LoadingImpl _value, $Res Function(_$LoadingImpl) _then)
      : super(_value, _then);

  /// Create a copy of StatisticsState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$LoadingImpl implements _Loading {
  const _$LoadingImpl();

  @override
  String toString() {
    return 'StatisticsState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            List<SubscriptionEntity> activeSubscriptions,
            List<CategorySpending> categorySpendingData,
            List<BillingTypeSpending> billingTypeSpendingData,
            List<SubscriptionEntity> topSpendingSubscriptions,
            MonthlySpendingTrendData spendingTrendData,
            double totalMonthlyEquivalentSpending,
            double totalYearlyEquivalentSpending,
            int selectedYearForTrend,
            double? yearlySalary,
            double? percentageOfSalary)
        loaded,
    required TResult Function(String message) error,
    required TResult Function(String message) empty,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(
            List<SubscriptionEntity> activeSubscriptions,
            List<CategorySpending> categorySpendingData,
            List<BillingTypeSpending> billingTypeSpendingData,
            List<SubscriptionEntity> topSpendingSubscriptions,
            MonthlySpendingTrendData spendingTrendData,
            double totalMonthlyEquivalentSpending,
            double totalYearlyEquivalentSpending,
            int selectedYearForTrend,
            double? yearlySalary,
            double? percentageOfSalary)?
        loaded,
    TResult? Function(String message)? error,
    TResult? Function(String message)? empty,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            List<SubscriptionEntity> activeSubscriptions,
            List<CategorySpending> categorySpendingData,
            List<BillingTypeSpending> billingTypeSpendingData,
            List<SubscriptionEntity> topSpendingSubscriptions,
            MonthlySpendingTrendData spendingTrendData,
            double totalMonthlyEquivalentSpending,
            double totalYearlyEquivalentSpending,
            int selectedYearForTrend,
            double? yearlySalary,
            double? percentageOfSalary)?
        loaded,
    TResult Function(String message)? error,
    TResult Function(String message)? empty,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
    required TResult Function(_Empty value) empty,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
    TResult? Function(_Empty value)? empty,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    TResult Function(_Empty value)? empty,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _Loading implements StatisticsState {
  const factory _Loading() = _$LoadingImpl;
}

/// @nodoc
abstract class _$$LoadedImplCopyWith<$Res> {
  factory _$$LoadedImplCopyWith(
          _$LoadedImpl value, $Res Function(_$LoadedImpl) then) =
      __$$LoadedImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {List<SubscriptionEntity> activeSubscriptions,
      List<CategorySpending> categorySpendingData,
      List<BillingTypeSpending> billingTypeSpendingData,
      List<SubscriptionEntity> topSpendingSubscriptions,
      MonthlySpendingTrendData spendingTrendData,
      double totalMonthlyEquivalentSpending,
      double totalYearlyEquivalentSpending,
      int selectedYearForTrend,
      double? yearlySalary,
      double? percentageOfSalary});
}

/// @nodoc
class __$$LoadedImplCopyWithImpl<$Res>
    extends _$StatisticsStateCopyWithImpl<$Res, _$LoadedImpl>
    implements _$$LoadedImplCopyWith<$Res> {
  __$$LoadedImplCopyWithImpl(
      _$LoadedImpl _value, $Res Function(_$LoadedImpl) _then)
      : super(_value, _then);

  /// Create a copy of StatisticsState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? activeSubscriptions = null,
    Object? categorySpendingData = null,
    Object? billingTypeSpendingData = null,
    Object? topSpendingSubscriptions = null,
    Object? spendingTrendData = null,
    Object? totalMonthlyEquivalentSpending = null,
    Object? totalYearlyEquivalentSpending = null,
    Object? selectedYearForTrend = null,
    Object? yearlySalary = freezed,
    Object? percentageOfSalary = freezed,
  }) {
    return _then(_$LoadedImpl(
      activeSubscriptions: null == activeSubscriptions
          ? _value._activeSubscriptions
          : activeSubscriptions // ignore: cast_nullable_to_non_nullable
              as List<SubscriptionEntity>,
      categorySpendingData: null == categorySpendingData
          ? _value._categorySpendingData
          : categorySpendingData // ignore: cast_nullable_to_non_nullable
              as List<CategorySpending>,
      billingTypeSpendingData: null == billingTypeSpendingData
          ? _value._billingTypeSpendingData
          : billingTypeSpendingData // ignore: cast_nullable_to_non_nullable
              as List<BillingTypeSpending>,
      topSpendingSubscriptions: null == topSpendingSubscriptions
          ? _value._topSpendingSubscriptions
          : topSpendingSubscriptions // ignore: cast_nullable_to_non_nullable
              as List<SubscriptionEntity>,
      spendingTrendData: null == spendingTrendData
          ? _value.spendingTrendData
          : spendingTrendData // ignore: cast_nullable_to_non_nullable
              as MonthlySpendingTrendData,
      totalMonthlyEquivalentSpending: null == totalMonthlyEquivalentSpending
          ? _value.totalMonthlyEquivalentSpending
          : totalMonthlyEquivalentSpending // ignore: cast_nullable_to_non_nullable
              as double,
      totalYearlyEquivalentSpending: null == totalYearlyEquivalentSpending
          ? _value.totalYearlyEquivalentSpending
          : totalYearlyEquivalentSpending // ignore: cast_nullable_to_non_nullable
              as double,
      selectedYearForTrend: null == selectedYearForTrend
          ? _value.selectedYearForTrend
          : selectedYearForTrend // ignore: cast_nullable_to_non_nullable
              as int,
      yearlySalary: freezed == yearlySalary
          ? _value.yearlySalary
          : yearlySalary // ignore: cast_nullable_to_non_nullable
              as double?,
      percentageOfSalary: freezed == percentageOfSalary
          ? _value.percentageOfSalary
          : percentageOfSalary // ignore: cast_nullable_to_non_nullable
              as double?,
    ));
  }
}

/// @nodoc

class _$LoadedImpl implements _Loaded {
  const _$LoadedImpl(
      {required final List<SubscriptionEntity> activeSubscriptions,
      required final List<CategorySpending> categorySpendingData,
      required final List<BillingTypeSpending> billingTypeSpendingData,
      required final List<SubscriptionEntity> topSpendingSubscriptions,
      required this.spendingTrendData,
      required this.totalMonthlyEquivalentSpending,
      required this.totalYearlyEquivalentSpending,
      required this.selectedYearForTrend,
      this.yearlySalary,
      this.percentageOfSalary})
      : _activeSubscriptions = activeSubscriptions,
        _categorySpendingData = categorySpendingData,
        _billingTypeSpendingData = billingTypeSpendingData,
        _topSpendingSubscriptions = topSpendingSubscriptions;

  final List<SubscriptionEntity> _activeSubscriptions;
  @override
  List<SubscriptionEntity> get activeSubscriptions {
    if (_activeSubscriptions is EqualUnmodifiableListView)
      return _activeSubscriptions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_activeSubscriptions);
  }

  final List<CategorySpending> _categorySpendingData;
  @override
  List<CategorySpending> get categorySpendingData {
    if (_categorySpendingData is EqualUnmodifiableListView)
      return _categorySpendingData;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_categorySpendingData);
  }

  final List<BillingTypeSpending> _billingTypeSpendingData;
  @override
  List<BillingTypeSpending> get billingTypeSpendingData {
    if (_billingTypeSpendingData is EqualUnmodifiableListView)
      return _billingTypeSpendingData;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_billingTypeSpendingData);
  }

  final List<SubscriptionEntity> _topSpendingSubscriptions;
  @override
  List<SubscriptionEntity> get topSpendingSubscriptions {
    if (_topSpendingSubscriptions is EqualUnmodifiableListView)
      return _topSpendingSubscriptions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_topSpendingSubscriptions);
  }

  @override
  final MonthlySpendingTrendData spendingTrendData;
  @override
  final double totalMonthlyEquivalentSpending;
  @override
  final double totalYearlyEquivalentSpending;
  @override
  final int selectedYearForTrend;
// --- NEUE PARAMETER ---
  @override
  final double? yearlySalary;
  @override
  final double? percentageOfSalary;

  @override
  String toString() {
    return 'StatisticsState.loaded(activeSubscriptions: $activeSubscriptions, categorySpendingData: $categorySpendingData, billingTypeSpendingData: $billingTypeSpendingData, topSpendingSubscriptions: $topSpendingSubscriptions, spendingTrendData: $spendingTrendData, totalMonthlyEquivalentSpending: $totalMonthlyEquivalentSpending, totalYearlyEquivalentSpending: $totalYearlyEquivalentSpending, selectedYearForTrend: $selectedYearForTrend, yearlySalary: $yearlySalary, percentageOfSalary: $percentageOfSalary)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoadedImpl &&
            const DeepCollectionEquality()
                .equals(other._activeSubscriptions, _activeSubscriptions) &&
            const DeepCollectionEquality()
                .equals(other._categorySpendingData, _categorySpendingData) &&
            const DeepCollectionEquality().equals(
                other._billingTypeSpendingData, _billingTypeSpendingData) &&
            const DeepCollectionEquality().equals(
                other._topSpendingSubscriptions, _topSpendingSubscriptions) &&
            (identical(other.spendingTrendData, spendingTrendData) ||
                other.spendingTrendData == spendingTrendData) &&
            (identical(other.totalMonthlyEquivalentSpending,
                    totalMonthlyEquivalentSpending) ||
                other.totalMonthlyEquivalentSpending ==
                    totalMonthlyEquivalentSpending) &&
            (identical(other.totalYearlyEquivalentSpending,
                    totalYearlyEquivalentSpending) ||
                other.totalYearlyEquivalentSpending ==
                    totalYearlyEquivalentSpending) &&
            (identical(other.selectedYearForTrend, selectedYearForTrend) ||
                other.selectedYearForTrend == selectedYearForTrend) &&
            (identical(other.yearlySalary, yearlySalary) ||
                other.yearlySalary == yearlySalary) &&
            (identical(other.percentageOfSalary, percentageOfSalary) ||
                other.percentageOfSalary == percentageOfSalary));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_activeSubscriptions),
      const DeepCollectionEquality().hash(_categorySpendingData),
      const DeepCollectionEquality().hash(_billingTypeSpendingData),
      const DeepCollectionEquality().hash(_topSpendingSubscriptions),
      spendingTrendData,
      totalMonthlyEquivalentSpending,
      totalYearlyEquivalentSpending,
      selectedYearForTrend,
      yearlySalary,
      percentageOfSalary);

  /// Create a copy of StatisticsState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$LoadedImplCopyWith<_$LoadedImpl> get copyWith =>
      __$$LoadedImplCopyWithImpl<_$LoadedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            List<SubscriptionEntity> activeSubscriptions,
            List<CategorySpending> categorySpendingData,
            List<BillingTypeSpending> billingTypeSpendingData,
            List<SubscriptionEntity> topSpendingSubscriptions,
            MonthlySpendingTrendData spendingTrendData,
            double totalMonthlyEquivalentSpending,
            double totalYearlyEquivalentSpending,
            int selectedYearForTrend,
            double? yearlySalary,
            double? percentageOfSalary)
        loaded,
    required TResult Function(String message) error,
    required TResult Function(String message) empty,
  }) {
    return loaded(
        activeSubscriptions,
        categorySpendingData,
        billingTypeSpendingData,
        topSpendingSubscriptions,
        spendingTrendData,
        totalMonthlyEquivalentSpending,
        totalYearlyEquivalentSpending,
        selectedYearForTrend,
        yearlySalary,
        percentageOfSalary);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(
            List<SubscriptionEntity> activeSubscriptions,
            List<CategorySpending> categorySpendingData,
            List<BillingTypeSpending> billingTypeSpendingData,
            List<SubscriptionEntity> topSpendingSubscriptions,
            MonthlySpendingTrendData spendingTrendData,
            double totalMonthlyEquivalentSpending,
            double totalYearlyEquivalentSpending,
            int selectedYearForTrend,
            double? yearlySalary,
            double? percentageOfSalary)?
        loaded,
    TResult? Function(String message)? error,
    TResult? Function(String message)? empty,
  }) {
    return loaded?.call(
        activeSubscriptions,
        categorySpendingData,
        billingTypeSpendingData,
        topSpendingSubscriptions,
        spendingTrendData,
        totalMonthlyEquivalentSpending,
        totalYearlyEquivalentSpending,
        selectedYearForTrend,
        yearlySalary,
        percentageOfSalary);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            List<SubscriptionEntity> activeSubscriptions,
            List<CategorySpending> categorySpendingData,
            List<BillingTypeSpending> billingTypeSpendingData,
            List<SubscriptionEntity> topSpendingSubscriptions,
            MonthlySpendingTrendData spendingTrendData,
            double totalMonthlyEquivalentSpending,
            double totalYearlyEquivalentSpending,
            int selectedYearForTrend,
            double? yearlySalary,
            double? percentageOfSalary)?
        loaded,
    TResult Function(String message)? error,
    TResult Function(String message)? empty,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(
          activeSubscriptions,
          categorySpendingData,
          billingTypeSpendingData,
          topSpendingSubscriptions,
          spendingTrendData,
          totalMonthlyEquivalentSpending,
          totalYearlyEquivalentSpending,
          selectedYearForTrend,
          yearlySalary,
          percentageOfSalary);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
    required TResult Function(_Empty value) empty,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
    TResult? Function(_Empty value)? empty,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    TResult Function(_Empty value)? empty,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class _Loaded implements StatisticsState {
  const factory _Loaded(
      {required final List<SubscriptionEntity> activeSubscriptions,
      required final List<CategorySpending> categorySpendingData,
      required final List<BillingTypeSpending> billingTypeSpendingData,
      required final List<SubscriptionEntity> topSpendingSubscriptions,
      required final MonthlySpendingTrendData spendingTrendData,
      required final double totalMonthlyEquivalentSpending,
      required final double totalYearlyEquivalentSpending,
      required final int selectedYearForTrend,
      final double? yearlySalary,
      final double? percentageOfSalary}) = _$LoadedImpl;

  List<SubscriptionEntity> get activeSubscriptions;
  List<CategorySpending> get categorySpendingData;
  List<BillingTypeSpending> get billingTypeSpendingData;
  List<SubscriptionEntity> get topSpendingSubscriptions;
  MonthlySpendingTrendData get spendingTrendData;
  double get totalMonthlyEquivalentSpending;
  double get totalYearlyEquivalentSpending;
  int get selectedYearForTrend; // --- NEUE PARAMETER ---
  double? get yearlySalary;
  double? get percentageOfSalary;

  /// Create a copy of StatisticsState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$LoadedImplCopyWith<_$LoadedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ErrorImplCopyWith<$Res> {
  factory _$$ErrorImplCopyWith(
          _$ErrorImpl value, $Res Function(_$ErrorImpl) then) =
      __$$ErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$ErrorImplCopyWithImpl<$Res>
    extends _$StatisticsStateCopyWithImpl<$Res, _$ErrorImpl>
    implements _$$ErrorImplCopyWith<$Res> {
  __$$ErrorImplCopyWithImpl(
      _$ErrorImpl _value, $Res Function(_$ErrorImpl) _then)
      : super(_value, _then);

  /// Create a copy of StatisticsState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$ErrorImpl(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ErrorImpl implements _Error {
  const _$ErrorImpl({required this.message});

  @override
  final String message;

  @override
  String toString() {
    return 'StatisticsState.error(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ErrorImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  /// Create a copy of StatisticsState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>
      __$$ErrorImplCopyWithImpl<_$ErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            List<SubscriptionEntity> activeSubscriptions,
            List<CategorySpending> categorySpendingData,
            List<BillingTypeSpending> billingTypeSpendingData,
            List<SubscriptionEntity> topSpendingSubscriptions,
            MonthlySpendingTrendData spendingTrendData,
            double totalMonthlyEquivalentSpending,
            double totalYearlyEquivalentSpending,
            int selectedYearForTrend,
            double? yearlySalary,
            double? percentageOfSalary)
        loaded,
    required TResult Function(String message) error,
    required TResult Function(String message) empty,
  }) {
    return error(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(
            List<SubscriptionEntity> activeSubscriptions,
            List<CategorySpending> categorySpendingData,
            List<BillingTypeSpending> billingTypeSpendingData,
            List<SubscriptionEntity> topSpendingSubscriptions,
            MonthlySpendingTrendData spendingTrendData,
            double totalMonthlyEquivalentSpending,
            double totalYearlyEquivalentSpending,
            int selectedYearForTrend,
            double? yearlySalary,
            double? percentageOfSalary)?
        loaded,
    TResult? Function(String message)? error,
    TResult? Function(String message)? empty,
  }) {
    return error?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            List<SubscriptionEntity> activeSubscriptions,
            List<CategorySpending> categorySpendingData,
            List<BillingTypeSpending> billingTypeSpendingData,
            List<SubscriptionEntity> topSpendingSubscriptions,
            MonthlySpendingTrendData spendingTrendData,
            double totalMonthlyEquivalentSpending,
            double totalYearlyEquivalentSpending,
            int selectedYearForTrend,
            double? yearlySalary,
            double? percentageOfSalary)?
        loaded,
    TResult Function(String message)? error,
    TResult Function(String message)? empty,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
    required TResult Function(_Empty value) empty,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
    TResult? Function(_Empty value)? empty,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    TResult Function(_Empty value)? empty,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _Error implements StatisticsState {
  const factory _Error({required final String message}) = _$ErrorImpl;

  String get message;

  /// Create a copy of StatisticsState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EmptyImplCopyWith<$Res> {
  factory _$$EmptyImplCopyWith(
          _$EmptyImpl value, $Res Function(_$EmptyImpl) then) =
      __$$EmptyImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$EmptyImplCopyWithImpl<$Res>
    extends _$StatisticsStateCopyWithImpl<$Res, _$EmptyImpl>
    implements _$$EmptyImplCopyWith<$Res> {
  __$$EmptyImplCopyWithImpl(
      _$EmptyImpl _value, $Res Function(_$EmptyImpl) _then)
      : super(_value, _then);

  /// Create a copy of StatisticsState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$EmptyImpl(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$EmptyImpl implements _Empty {
  const _$EmptyImpl({required this.message});

  @override
  final String message;

  @override
  String toString() {
    return 'StatisticsState.empty(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EmptyImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  /// Create a copy of StatisticsState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$EmptyImplCopyWith<_$EmptyImpl> get copyWith =>
      __$$EmptyImplCopyWithImpl<_$EmptyImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            List<SubscriptionEntity> activeSubscriptions,
            List<CategorySpending> categorySpendingData,
            List<BillingTypeSpending> billingTypeSpendingData,
            List<SubscriptionEntity> topSpendingSubscriptions,
            MonthlySpendingTrendData spendingTrendData,
            double totalMonthlyEquivalentSpending,
            double totalYearlyEquivalentSpending,
            int selectedYearForTrend,
            double? yearlySalary,
            double? percentageOfSalary)
        loaded,
    required TResult Function(String message) error,
    required TResult Function(String message) empty,
  }) {
    return empty(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(
            List<SubscriptionEntity> activeSubscriptions,
            List<CategorySpending> categorySpendingData,
            List<BillingTypeSpending> billingTypeSpendingData,
            List<SubscriptionEntity> topSpendingSubscriptions,
            MonthlySpendingTrendData spendingTrendData,
            double totalMonthlyEquivalentSpending,
            double totalYearlyEquivalentSpending,
            int selectedYearForTrend,
            double? yearlySalary,
            double? percentageOfSalary)?
        loaded,
    TResult? Function(String message)? error,
    TResult? Function(String message)? empty,
  }) {
    return empty?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            List<SubscriptionEntity> activeSubscriptions,
            List<CategorySpending> categorySpendingData,
            List<BillingTypeSpending> billingTypeSpendingData,
            List<SubscriptionEntity> topSpendingSubscriptions,
            MonthlySpendingTrendData spendingTrendData,
            double totalMonthlyEquivalentSpending,
            double totalYearlyEquivalentSpending,
            int selectedYearForTrend,
            double? yearlySalary,
            double? percentageOfSalary)?
        loaded,
    TResult Function(String message)? error,
    TResult Function(String message)? empty,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
    required TResult Function(_Empty value) empty,
  }) {
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
    TResult? Function(_Empty value)? empty,
  }) {
    return empty?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    TResult Function(_Empty value)? empty,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class _Empty implements StatisticsState {
  const factory _Empty({required final String message}) = _$EmptyImpl;

  String get message;

  /// Create a copy of StatisticsState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$EmptyImplCopyWith<_$EmptyImpl> get copyWith =>
      throw _privateConstructorUsedError;
}


===== FILE: statistics_state.dart =====
===== PATH: lib/features/statistics/presentation/cubit/statistics_state.dart =====

// lib/features/statistics/presentation/cubit/statistics_state.dart
part of 'statistics_cubit.dart';

// ... (Data structures for charts remain the same)
class CategorySpending {
  final SubscriptionCategory category;
  final double totalAmount;
  final double percentage;
  CategorySpending(
      {required this.category,
      required this.totalAmount,
      required this.percentage});
}

class BillingTypeSpending {
  final BillingCycle billingCycle;
  final double totalAmount;
  final int subscriptionCount;
  final double percentageOfTotal;
  BillingTypeSpending(
      {required this.billingCycle,
      required this.totalAmount,
      required this.subscriptionCount,
      required this.percentageOfTotal});
}

class MonthlySpendingTrendData {
  final int year;
  final List<FlSpot> spots;
  final double maxSpendingInYear;
  MonthlySpendingTrendData(
      {required this.year,
      required this.spots,
      required this.maxSpendingInYear});
}

@freezed
class StatisticsState with _$StatisticsState {
  const factory StatisticsState.initial() = _Initial;
  const factory StatisticsState.loading() = _Loading;
  const factory StatisticsState.loaded({
    required List<SubscriptionEntity> activeSubscriptions,
    required List<CategorySpending> categorySpendingData,
    required List<BillingTypeSpending> billingTypeSpendingData,
    required List<SubscriptionEntity> topSpendingSubscriptions,
    required MonthlySpendingTrendData spendingTrendData,
    required double totalMonthlyEquivalentSpending,
    required double totalYearlyEquivalentSpending,
    required int selectedYearForTrend,
    // --- NEUE PARAMETER ---
    double? yearlySalary,
    double? percentageOfSalary,
  }) = _Loaded;
  const factory StatisticsState.error({required String message}) = _Error;
  const factory StatisticsState.empty({required String message}) = _Empty;
}


===== FILE: statistics_screen.dart =====
===== PATH: lib/features/statistics/presentation/screens/statistics_screen.dart =====

import 'package:aboapp/features/statistics/presentation/cubit/statistics_cubit.dart';
import 'package:aboapp/features/statistics/presentation/widgets/billing_type_breakdown_card.dart';
import 'package:aboapp/features/statistics/presentation/widgets/category_spending_pie_chart_card.dart';
import 'package:aboapp/features/statistics/presentation/widgets/overall_spending_summary_card.dart';
import 'package:aboapp/features/statistics/presentation/widgets/salary_insight_card.dart';
import 'package:aboapp/features/statistics/presentation/widgets/spending_trend_line_chart_card.dart';
import 'package:aboapp/features/statistics/presentation/widgets/top_subscriptions_list_card.dart';
import 'package:aboapp/widgets/empty_state_widget.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

class StatisticsScreen extends StatefulWidget {
  const StatisticsScreen({super.key});

  @override
  State<StatisticsScreen> createState() => _StatisticsScreenState();
}

class _StatisticsScreenState extends State<StatisticsScreen> {
  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      context.read<StatisticsCubit>().generateStatistics();
    });
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Scaffold(
      body: BlocBuilder<StatisticsCubit, StatisticsState>(
        builder: (context, statsState) {
          return statsState.when(
            initial: () =>
                const Center(child: CircularProgressIndicator.adaptive()),
            loading: () =>
                const Center(child: CircularProgressIndicator.adaptive()),
            empty: (message) => EmptyStateWidget(
              icon: Icons.insights_rounded,
              title: 'No Statistics Yet',
              message: message,
            ),
            error: (message) => EmptyStateWidget(
              icon: Icons.error_outline_rounded,
              title: 'Error Loading Statistics',
              message: message,
              onRetry: () =>
                  context.read<StatisticsCubit>().generateStatistics(),
              retryText: 'Retry',
            ),
            loaded: (
              activeSubscriptions,
              categorySpendingData,
              billingTypeSpendingData,
              topSpendingSubscriptions,
              spendingTrendData,
              totalMonthlyEquivalentSpending,
              totalYearlyEquivalentSpending,
              selectedYearForTrend,
              yearlySalary,
              percentageOfSalary,
            ) {
              return RefreshIndicator(
                onRefresh: () async =>
                    context.read<StatisticsCubit>().generateStatistics(),
                child: CustomScrollView(
                  slivers: <Widget>[
                    SliverAppBar(
                      title: const Text('Statistics'),
                      floating: true,
                      snap: true,
                      actions: [
                        _buildYearSelector(
                            context, theme, selectedYearForTrend),
                      ],
                    ),
                    SliverPadding(
                      padding: const EdgeInsets.fromLTRB(16, 8, 16, 80),
                      sliver: SliverList(
                        delegate: SliverChildListDelegate.fixed([
                          if (yearlySalary != null &&
                              percentageOfSalary != null) ...[
                            SalaryInsightCard(
                              percentageOfSalary: percentageOfSalary,
                              yearlySalary: yearlySalary,
                            ),
                            const SizedBox(height: 16),
                          ],
                          OverallSpendingSummaryCard(
                            totalMonthlySpending:
                                totalMonthlyEquivalentSpending,
                            totalYearlySpending: totalYearlyEquivalentSpending,
                          ),
                          const SizedBox(height: 16),
                          CategorySpendingPieChartCard(
                            categorySpendingData: categorySpendingData,
                          ),
                          const SizedBox(height: 16),
                          SpendingTrendLineChartCard(
                            spendingTrendData: spendingTrendData,
                          ),
                          const SizedBox(height: 16),
                          BillingTypeBreakdownCard(
                            billingTypeSpendingData: billingTypeSpendingData,
                          ),
                          const SizedBox(height: 16),
                          TopSubscriptionsListCard(
                            topSubscriptions: topSpendingSubscriptions,
                          ),
                        ]),
                      ),
                    ),
                  ],
                ),
              );
            },
          );
        },
      ),
    );
  }

  Widget _buildYearSelector(
      BuildContext context, ThemeData theme, int currentYear) {
    return PopupMenuButton<int>(
      onSelected: (newYear) {
        if (newYear != currentYear) {
          context.read<StatisticsCubit>().changeTrendYear(newYear);
        }
      },
      itemBuilder: (context) {
        return List.generate(5, (index) => DateTime.now().year - index)
            .map((year) => PopupMenuItem<int>(
                  value: year,
                  child: Text(year.toString()),
                ))
            .toList();
      },
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(
              currentYear.toString(),
              style: theme.textTheme.titleMedium
                  ?.copyWith(color: theme.colorScheme.primary),
            ),
            const SizedBox(width: 4),
            Icon(
              Icons.keyboard_arrow_down_rounded,
              color: theme.colorScheme.primary,
            ),
          ],
        ),
      ),
    );
  }
}


===== FILE: billing_type_breakdown_card.dart =====
===== PATH: lib/features/statistics/presentation/widgets/billing_type_breakdown_card.dart =====

// lib/features/statistics/presentation/widgets/billing_type_breakdown_card.dart

import 'package:aboapp/core/utils/currency_formatter.dart';
import 'package:aboapp/features/settings/presentation/cubit/settings_cubit.dart';
import 'package:aboapp/features/statistics/presentation/cubit/statistics_cubit.dart'; // For BillingTypeSpending
import 'package:aboapp/features/subscriptions/domain/entities/subscription_entity.dart'; // For BillingCycle
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

class BillingTypeBreakdownCard extends StatelessWidget {
  final List<BillingTypeSpending> billingTypeSpendingData;

  const BillingTypeBreakdownCard({
    super.key,
    required this.billingTypeSpendingData,
  });

  String _getBillingCycleLabel(BuildContext context, BillingCycle cycle) {
    // TODO: Localize
    switch (cycle) {
      case BillingCycle.weekly:
        return 'Weekly';
      case BillingCycle.monthly:
        return 'Monthly';
      case BillingCycle.quarterly:
        return 'Quarterly';
      case BillingCycle.biAnnual:
        return 'Bi-Annual';
      case BillingCycle.yearly:
        return 'Yearly';
      case BillingCycle.custom:
        return 'Custom';
    }
  }

  Color _getBillingCycleColor(BuildContext context, BillingCycle cycle) {
    // Use a consistent color mapping, possibly from AppColors or theme extensions
    final colors = [
      Colors.blue.shade300,
      Colors.purple.shade300,
      Colors.teal.shade300,
      Colors.orange.shade300,
      Colors.red.shade300,
      Colors.grey.shade400
    ];
    return colors[cycle.index % colors.length];
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final settingsState = context.watch<SettingsCubit>().state;

    if (billingTypeSpendingData.isEmpty) {
      return Card(
        elevation: 1.0,
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Center(
            child: Text(
              'No billing type data available.', // TODO: Localize
              style: theme.textTheme.bodyMedium,
            ),
          ),
        ),
      );
    }

    final totalMonthlyEquivalentSpending = billingTypeSpendingData.fold<double>(
        0, (sum, item) => sum + item.totalAmount);

    return Card(
      elevation: 1.0,
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Breakdown by Billing Cycle', // TODO: Localize
              style: theme.textTheme.titleMedium
                  ?.copyWith(fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 8),
            Text(
              '(Based on Monthly Equivalent Cost)', // TODO: Localize
              style: theme.textTheme.bodySmall
                  ?.copyWith(color: theme.colorScheme.onSurfaceVariant),
            ),
            const SizedBox(height: 16),
            if (totalMonthlyEquivalentSpending > 0)
              LayoutBuilder(builder: (context, constraints) {
                return ClipRRect(
                  borderRadius: BorderRadius.circular(8),
                  child: Row(
                    children: billingTypeSpendingData.map((item) {
                      final percentage = item.percentageOfTotal;
                      return Expanded(
                        flex: (percentage * 100).toInt().clamp(1, 100),
                        child: Container(
                          height: 24,
                          color:
                              _getBillingCycleColor(context, item.billingCycle),
                        ),
                      );
                    }).toList(),
                  ),
                );
              }),
            const SizedBox(height: 16),
            ...billingTypeSpendingData.map((item) {
              return Padding(
                padding: const EdgeInsets.only(bottom: 8.0),
                child: Row(
                  children: [
                    Container(
                      width: 12,
                      height: 12,
                      decoration: BoxDecoration(
                        color:
                            _getBillingCycleColor(context, item.billingCycle),
                        borderRadius: BorderRadius.circular(3.0),
                      ),
                    ),
                    const SizedBox(width: 8.0),
                    Expanded(
                      flex: 3,
                      child: Text(
                        _getBillingCycleLabel(context, item.billingCycle),
                        style: theme.textTheme.bodyMedium,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                    Expanded(
                      flex: 2,
                      child: Text(
                        '${item.subscriptionCount} sub${item.subscriptionCount == 1 ? "" : "s"}', // TODO: Localize
                        style: theme.textTheme.bodySmall?.copyWith(
                            color: theme.colorScheme.onSurfaceVariant),
                        textAlign: TextAlign.end,
                      ),
                    ),
                    const SizedBox(width: 12.0),
                    Expanded(
                      flex: 3,
                      child: Text(
                        CurrencyFormatter.format(
                          item.totalAmount,
                          currencyCode: settingsState.currencyCode,
                          locale: settingsState.locale,
                          decimalDigits: 0,
                        ),
                        style: theme.textTheme.bodyMedium
                            ?.copyWith(fontWeight: FontWeight.w600),
                        textAlign: TextAlign.end,
                      ),
                    ),
                    const SizedBox(width: 8.0),
                    Expanded(
                      flex: 2,
                      child: Text(
                        '(${(item.percentageOfTotal * 100).toStringAsFixed(0)}%)',
                        style: theme.textTheme.bodySmall?.copyWith(
                            color: theme.colorScheme.onSurfaceVariant),
                        textAlign: TextAlign.end,
                      ),
                    ),
                  ],
                ),
              );
            }),
          ],
        ),
      ),
    );
  }
}


===== FILE: category_spending_pie_chart_card.dart =====
===== PATH: lib/features/statistics/presentation/widgets/category_spending_pie_chart_card.dart =====

import 'package:aboapp/core/utils/currency_formatter.dart';
import 'package:aboapp/features/settings/presentation/cubit/settings_cubit.dart';
import 'package:aboapp/features/statistics/presentation/cubit/statistics_cubit.dart';
import 'package:aboapp/features/subscriptions/presentation/widgets/subscription_card_widget.dart';
import 'package:fl_chart/fl_chart.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

class CategorySpendingPieChartCard extends StatefulWidget {
  final List<CategorySpending> categorySpendingData;

  const CategorySpendingPieChartCard({
    super.key,
    required this.categorySpendingData,
  });

  @override
  State<CategorySpendingPieChartCard> createState() =>
      _CategorySpendingPieChartCardState();
}

class _CategorySpendingPieChartCardState
    extends State<CategorySpendingPieChartCard> {
  int? _touchedIndex;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final settingsState = context.watch<SettingsCubit>().state;

    if (widget.categorySpendingData.isEmpty) {
      return Card(
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Center(
            child: Text(
              'No category spending data available.',
              style: theme.textTheme.bodyMedium,
            ),
          ),
        ),
      );
    }

    final relevantData =
        widget.categorySpendingData.where((d) => d.totalAmount > 0.01).toList();
    if (relevantData.isEmpty) {
      return Card(
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Center(
            child: Text(
              'No significant category spending.',
              style: theme.textTheme.bodyMedium,
            ),
          ),
        ),
      );
    }

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Spending by Category',
              style: theme.textTheme.titleMedium
                  ?.copyWith(fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 24),
            SizedBox(
              height: 180,
              child: PieChart(
                PieChartData(
                  pieTouchData: PieTouchData(
                    touchCallback: (FlTouchEvent event, pieTouchResponse) {
                      setState(() {
                        if (!event.isInterestedForInteractions ||
                            pieTouchResponse == null ||
                            pieTouchResponse.touchedSection == null) {
                          _touchedIndex = -1;
                          return;
                        }
                        _touchedIndex = pieTouchResponse
                            .touchedSection!.touchedSectionIndex;
                      });
                    },
                  ),
                  borderData: FlBorderData(show: false),
                  sectionsSpace: 2,
                  centerSpaceRadius: 45,
                  sections: _generatePieChartSections(theme, relevantData),
                ),
              ),
            ),
            const SizedBox(height: 24),
            _buildLegend(theme, settingsState, relevantData),
          ],
        ),
      ),
    );
  }

  List<PieChartSectionData> _generatePieChartSections(
      ThemeData theme, List<CategorySpending> data) {
    return List.generate(data.length, (i) {
      final isTouched = i == _touchedIndex;
      final fontSize = isTouched ? 14.0 : 10.0;
      final radius = isTouched ? 70.0 : 60.0;
      final categoryData = data[i];

      return PieChartSectionData(
        color: categoryData.category.categoryDisplayIconColor(theme),
        value: categoryData.totalAmount,
        title: '${(categoryData.percentage * 100).toStringAsFixed(0)}%',
        radius: radius,
        titleStyle: TextStyle(
          fontSize: fontSize,
          fontWeight: FontWeight.bold,
          color: ThemeData.estimateBrightnessForColor(
                      categoryData.category.categoryDisplayIconColor(theme)) ==
                  Brightness.dark
              ? Colors.white
              : Colors.black,
          shadows: const [Shadow(color: Colors.black26, blurRadius: 1)],
        ),
      );
    });
  }

  Widget _buildLegend(ThemeData theme, SettingsState settingsState,
      List<CategorySpending> data) {
    return Wrap(
      spacing: 16.0,
      runSpacing: 8.0,
      alignment: WrapAlignment.center,
      children: data.map((categoryData) {
        final isTouched = data.indexOf(categoryData) == _touchedIndex;
        return AnimatedContainer(
          duration: const Duration(milliseconds: 150),
          padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
          decoration: BoxDecoration(
            color: isTouched
                ? categoryData.category
                    .categoryDisplayIconColor(theme)
                    .withOpacity(0.2)
                : Colors.transparent,
            borderRadius: BorderRadius.circular(6),
          ),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              Container(
                width: 12,
                height: 12,
                decoration: BoxDecoration(
                  color: categoryData.category.categoryDisplayIconColor(theme),
                  shape: BoxShape.circle,
                ),
              ),
              const SizedBox(width: 6),
              Text(
                categoryData.category.displayName,
                style: theme.textTheme.bodySmall?.copyWith(
                  fontWeight: isTouched ? FontWeight.bold : FontWeight.normal,
                ),
              ),
              const SizedBox(width: 4),
              Text(
                '(${CurrencyFormatter.format(categoryData.totalAmount, currencyCode: settingsState.currencyCode, locale: settingsState.locale, decimalDigits: 0)})',
                style: theme.textTheme.labelSmall?.copyWith(
                  color: theme.colorScheme.onSurfaceVariant,
                  fontWeight: isTouched ? FontWeight.bold : FontWeight.normal,
                ),
              )
            ],
          ),
        );
      }).toList(),
    );
  }
}


===== FILE: overall_spending_summary_card.dart =====
===== PATH: lib/features/statistics/presentation/widgets/overall_spending_summary_card.dart =====

import 'package:aboapp/features/settings/presentation/cubit/settings_cubit.dart';
import 'package:aboapp/widgets/animated_counter_widget.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:intl/intl.dart';

class OverallSpendingSummaryCard extends StatelessWidget {
  final double totalMonthlySpending;
  final double totalYearlySpending;

  const OverallSpendingSummaryCard({
    super.key,
    required this.totalMonthlySpending,
    required this.totalYearlySpending,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final settingsState = context.watch<SettingsCubit>().state;
    final currencyFormat = NumberFormat.currency(
      locale: settingsState.locale.toLanguageTag(),
      symbol: NumberFormat.simpleCurrency(
              locale: settingsState.locale.toLanguageTag())
          .currencySymbol,
    );

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(20.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Text(
              'Spending Overview',
              style: theme.textTheme.titleMedium
                  ?.copyWith(fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 16),
            Row(
              children: [
                _buildMetric(
                  context: context,
                  currencyFormat: currencyFormat,
                  label: 'Monthly',
                  value: totalMonthlySpending,
                  style: theme.textTheme.headlineMedium!.copyWith(
                    color: theme.colorScheme.primary,
                    fontWeight: FontWeight.bold,
                  ),
                  labelStyle: theme.textTheme.bodySmall!,
                ),
                const SizedBox(width: 24),
                _buildMetric(
                  context: context,
                  currencyFormat: currencyFormat,
                  label: 'Yearly',
                  value: totalYearlySpending,
                  style: theme.textTheme.headlineMedium!.copyWith(
                    color: theme.colorScheme.onSurfaceVariant,
                    fontWeight: FontWeight.w600,
                  ),
                  labelStyle: theme.textTheme.bodySmall!,
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildMetric({
    required BuildContext context,
    required NumberFormat currencyFormat,
    required String label,
    required double value,
    required TextStyle style,
    required TextStyle labelStyle,
  }) {
    return Expanded(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          FittedBox(
            fit: BoxFit.scaleDown,
            child: AnimatedCounterWidget(
              value: value,
              formatter: (val) => currencyFormat.format(val),
              style: style,
            ),
          ),
          const SizedBox(height: 2),
          Text(
            label,
            style: labelStyle.copyWith(
                color: Theme.of(context).colorScheme.onSurfaceVariant),
          ),
        ],
      ),
    );
  }
}


===== FILE: salary_insight_card.dart =====
===== PATH: lib/features/statistics/presentation/widgets/salary_insight_card.dart =====

// lib/features/statistics/presentation/widgets/salary_insight_card.dart
import 'package:aboapp/core/utils/currency_formatter.dart';
import 'package:aboapp/features/settings/presentation/cubit/settings_cubit.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:percent_indicator/percent_indicator.dart';

class SalaryInsightCard extends StatelessWidget {
  final double percentageOfSalary;
  final double yearlySalary;

  const SalaryInsightCard({
    super.key,
    required this.percentageOfSalary,
    required this.yearlySalary,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final settingsState = context.watch<SettingsCubit>().state;
    final formattedPercentage = (percentageOfSalary * 100).toStringAsFixed(2);
    final formattedSalary = CurrencyFormatter.format(
      yearlySalary,
      currencyCode: settingsState.currencyCode,
      locale: settingsState.locale,
      decimalDigits: 0,
    );

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Row(
          children: [
            CircularPercentIndicator(
              radius: 40.0,
              lineWidth: 9.0,
              percent: percentageOfSalary.clamp(0.0, 1.0),
              center: Text(
                "$formattedPercentage%",
                style: theme.textTheme.titleMedium
                    ?.copyWith(fontWeight: FontWeight.bold),
              ),
              progressColor: theme.colorScheme.primary,
              backgroundColor: theme.dividerColor.withAlpha(128),
              circularStrokeCap: CircularStrokeCap.round,
              animation: true,
              animationDuration: 800,
            ),
            const SizedBox(width: 20),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    "Salary Contribution",
                    style: theme.textTheme.titleMedium
                        ?.copyWith(fontWeight: FontWeight.bold),
                  ),
                  const SizedBox(height: 4),
                  Text(
                    "You're spending $formattedPercentage% of your yearly salary ($formattedSalary) on subscriptions.",
                    style: theme.textTheme.bodyMedium
                        ?.copyWith(color: theme.colorScheme.onSurfaceVariant),
                  ),
                ],
              ),
            )
          ],
        ),
      ),
    );
  }
}


===== FILE: spending_trend_line_chart_card.dart =====
===== PATH: lib/features/statistics/presentation/widgets/spending_trend_line_chart_card.dart =====

import 'package:aboapp/core/utils/currency_formatter.dart';
import 'package:aboapp/features/settings/presentation/cubit/settings_cubit.dart';
import 'package:aboapp/features/statistics/presentation/cubit/statistics_cubit.dart';
import 'package:fl_chart/fl_chart.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:intl/intl.dart';

class SpendingTrendLineChartCard extends StatelessWidget {
  final MonthlySpendingTrendData spendingTrendData;

  const SpendingTrendLineChartCard({
    super.key,
    required this.spendingTrendData,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final settingsState = context.watch<SettingsCubit>().state;

    if (spendingTrendData.spots.isEmpty) {
      return Card(
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Center(
            child: Text(
              'No spending trend data available for ${spendingTrendData.year}.',
              style: theme.textTheme.bodyMedium,
            ),
          ),
        ),
      );
    }

    return Card(
      child: Padding(
        padding: const EdgeInsets.fromLTRB(16, 16, 20, 20),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Spending Trend - ${spendingTrendData.year}',
              style: theme.textTheme.titleMedium
                  ?.copyWith(fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 24),
            SizedBox(
              height: 200,
              child: LineChart(
                LineChartData(
                  gridData: FlGridData(
                    show: true,
                    drawVerticalLine: false,
                    horizontalInterval: (spendingTrendData.maxSpendingInYear > 0
                            ? spendingTrendData.maxSpendingInYear / 4
                            : 50.0)
                        .clamp(10.0, double.infinity),
                    getDrawingHorizontalLine: (value) {
                      return FlLine(
                        color: theme.dividerColor.withOpacity(0.5),
                        strokeWidth: 0.5,
                      );
                    },
                  ),
                  titlesData: FlTitlesData(
                    show: true,
                    rightTitles: const AxisTitles(
                        sideTitles: SideTitles(showTitles: false)),
                    topTitles: const AxisTitles(
                        sideTitles: SideTitles(showTitles: false)),
                    bottomTitles: AxisTitles(
                      sideTitles: SideTitles(
                        showTitles: true,
                        reservedSize: 30,
                        interval: 2,
                        getTitlesWidget: (value, meta) {
                          const months = [
                            'Jan',
                            'Feb',
                            'Mar',
                            'Apr',
                            'May',
                            'Jun',
                            'Jul',
                            'Aug',
                            'Sep',
                            'Oct',
                            'Nov',
                            'Dec'
                          ];
                          final int monthIndex = value.toInt() - 1;
                          if (monthIndex >= 0 && monthIndex < months.length) {
                            return SideTitleWidget(
                              axisSide: meta.axisSide,
                              space: 8.0,
                              child: Text(months[monthIndex],
                                  style: theme.textTheme.bodySmall),
                            );
                          }
                          return const Text('');
                        },
                      ),
                    ),
                    leftTitles: AxisTitles(
                      sideTitles: SideTitles(
                        showTitles: true,
                        reservedSize: 48,
                        getTitlesWidget: (value, meta) {
                          if (value == meta.max || value == meta.min) {
                            return const Text('');
                          }
                          return SideTitleWidget(
                            axisSide: meta.axisSide,
                            space: 4.0,
                            child: Text(
                                CurrencyFormatter.format(
                                  value,
                                  currencyCode: settingsState.currencyCode,
                                  locale: settingsState.locale,
                                  decimalDigits: 0,
                                ),
                                style: theme.textTheme.bodySmall),
                          );
                        },
                      ),
                    ),
                  ),
                  borderData: FlBorderData(show: false),
                  minX: 1,
                  maxX: 12,
                  minY: 0,
                  maxY: spendingTrendData.maxSpendingInYear > 0
                      ? spendingTrendData.maxSpendingInYear * 1.1
                      : 100,
                  lineBarsData: [
                    LineChartBarData(
                      spots: spendingTrendData.spots,
                      isCurved: true,
                      gradient: LinearGradient(
                        colors: [
                          theme.colorScheme.primary,
                          theme.colorScheme.secondary
                        ],
                      ),
                      barWidth: 3.5,
                      isStrokeCapRound: true,
                      dotData: FlDotData(
                        show: true,
                        getDotPainter: (spot, percent, barData, index) =>
                            FlDotCirclePainter(
                          radius: 4,
                          color: Color.lerp(theme.colorScheme.primary,
                                  theme.colorScheme.secondary, percent / 100) ??
                              theme.colorScheme.primary,
                          strokeWidth: 1.5,
                          strokeColor: theme.cardColor,
                        ),
                      ),
                      belowBarData: BarAreaData(
                        show: true,
                        gradient: LinearGradient(
                          colors: [
                            theme.colorScheme.primary.withOpacity(0.2),
                            theme.colorScheme.secondary.withOpacity(0.05),
                          ],
                          begin: Alignment.topCenter,
                          end: Alignment.bottomCenter,
                        ),
                      ),
                    ),
                  ],
                  lineTouchData: LineTouchData(
                    handleBuiltInTouches: true,
                    touchTooltipData: LineTouchTooltipData(
                      getTooltipColor: (spot) =>
                          theme.colorScheme.surfaceContainerHighest,
                      getTooltipItems: (List<LineBarSpot> touchedBarSpots) {
                        return touchedBarSpots.map((barSpot) {
                          final flSpot = barSpot;
                          final monthName = DateFormat.MMMM(
                                  settingsState.locale.toLanguageTag())
                              .format(DateTime(
                                  spendingTrendData.year, flSpot.x.toInt()));
                          return LineTooltipItem(
                            '$monthName: ${CurrencyFormatter.format(flSpot.y, currencyCode: settingsState.currencyCode, locale: settingsState.locale, decimalDigits: 0)}\n',
                            TextStyle(
                              color: theme.colorScheme.onSurfaceVariant,
                              fontWeight: FontWeight.bold,
                            ),
                          );
                        }).toList();
                      },
                    ),
                  ),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}


===== FILE: top_subscriptions_list_card.dart =====
===== PATH: lib/features/statistics/presentation/widgets/top_subscriptions_list_card.dart =====

// lib/features/statistics/presentation/widgets/top_subscriptions_list_card.dart

import 'package:aboapp/core/utils/currency_formatter.dart';
import 'package:aboapp/features/settings/presentation/cubit/settings_cubit.dart';
import 'package:aboapp/features/subscriptions/domain/entities/subscription_entity.dart';
import 'package:aboapp/features/subscriptions/presentation/widgets/subscription_card_widget.dart'; // For CategoryDisplayHelpers
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

class TopSubscriptionsListCard extends StatelessWidget {
  final List<SubscriptionEntity> topSubscriptions;

  const TopSubscriptionsListCard({
    super.key,
    required this.topSubscriptions,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final settingsState = context.watch<SettingsCubit>().state;

    if (topSubscriptions.isEmpty) {
      return Card(
        elevation: 1.0,
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Center(
            child: Text(
              'No subscriptions to display in top list.', // TODO: Localize
              style: theme.textTheme.bodyMedium,
            ),
          ),
        ),
      );
    }

    return Card(
      elevation: 1.0,
      child: Padding(
        padding: const EdgeInsets.symmetric(vertical: 8.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Padding(
              padding: const EdgeInsets.only(
                  left: 16.0, top: 8.0, right: 16.0, bottom: 4.0),
              child: Text(
                'Top Spending Subscriptions', // TODO: Localize
                style: theme.textTheme.titleMedium
                    ?.copyWith(fontWeight: FontWeight.bold),
              ),
            ),
            Padding(
              padding:
                  const EdgeInsets.only(left: 16.0, right: 16.0, bottom: 8.0),
              child: Text(
                '(Based on Monthly Equivalent Cost)', // TODO: Localize
                style: theme.textTheme.bodySmall
                    ?.copyWith(color: theme.colorScheme.onSurfaceVariant),
              ),
            ),
            ListView.separated(
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
              itemCount: topSubscriptions.length,
              itemBuilder: (context, index) {
                final sub = topSubscriptions[index];
                final rank = index + 1;
                return ListTile(
                  contentPadding: const EdgeInsets.symmetric(
                      horizontal: 16.0, vertical: 4.0),
                  leading: CircleAvatar(
                    radius: 16,
                    backgroundColor: theme.colorScheme.primaryContainer,
                    child: Text(
                      '$rank',
                      style: theme.textTheme.labelSmall?.copyWith(
                          color: theme.colorScheme.onPrimaryContainer,
                          fontWeight: FontWeight.bold),
                    ),
                  ),
                  title: Text(
                    sub.name,
                    style: theme.textTheme.titleSmall
                        ?.copyWith(fontWeight: FontWeight.w500),
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
                  subtitle: Text(
                    sub.category
                        .displayName, // Use extension from subscription_card_widget
                    style: theme.textTheme.bodySmall
                        ?.copyWith(color: theme.colorScheme.onSurfaceVariant),
                  ),
                  trailing: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    crossAxisAlignment: CrossAxisAlignment.end,
                    children: [
                      Text(
                        CurrencyFormatter.format(sub.monthlyEquivalentPrice,
                            currencyCode: settingsState.currencyCode,
                            locale: settingsState.locale),
                        style: theme.textTheme.bodyMedium
                            ?.copyWith(fontWeight: FontWeight.bold),
                      ),
                      Text(
                        'per month', // TODO: Localize (as it's monthly equivalent)
                        style: theme.textTheme.labelSmall?.copyWith(
                            color: theme.colorScheme.onSurfaceVariant),
                      )
                    ],
                  ),
                );
              },
              separatorBuilder: (context, index) =>
                  const Divider(height: 1, indent: 16, endIndent: 16),
            ),
          ],
        ),
      ),
    );
  }
}


===== FILE: subscription_local_datasource.dart =====
===== PATH: lib/features/subscriptions/data/datasources/subscription_local_datasource.dart =====

import 'dart:convert';
import 'package:aboapp/features/subscriptions/data/models/subscription_model.dart';
import 'package:injectable/injectable.dart';
import 'package:shared_preferences/shared_preferences.dart';

abstract class SubscriptionLocalDataSource {
  Future<List<SubscriptionModel>> getAllSubscriptions();
  Future<void> saveSubscription(SubscriptionModel subscription);
  Future<void> deleteSubscription(String id);
  Future<void> updateSubscription(SubscriptionModel subscription);
  Future<void> cacheSubscriptions(List<SubscriptionModel> subscriptions);
}

const String cachedSubscriptionsKey = 'CACHED_SUBSCRIPTIONS';

@LazySingleton(as: SubscriptionLocalDataSource)
class SubscriptionLocalDataSourceImpl implements SubscriptionLocalDataSource {
  final SharedPreferences sharedPreferences;

  SubscriptionLocalDataSourceImpl(this.sharedPreferences);

  @override
  Future<List<SubscriptionModel>> getAllSubscriptions() async {
    final jsonStringList = sharedPreferences.getStringList(cachedSubscriptionsKey);
    if (jsonStringList != null) {
      try {
        return jsonStringList
            .map((jsonString) =>
                SubscriptionModel.fromJson(jsonDecode(jsonString) as Map<String, dynamic>))
            .toList();
      } catch (e) {
        // Handle corrupted data, e.g., by clearing it or logging
        await sharedPreferences.remove(cachedSubscriptionsKey);
        throw Exception('Failed to parse subscriptions from local storage: $e');
      }
    } else {
      return [];
    }
  }

  @override
  Future<void> cacheSubscriptions(List<SubscriptionModel> subscriptions) async {
    final List<String> jsonStringList =
        subscriptions.map((sub) => jsonEncode(sub.toJson())).toList();
    await sharedPreferences.setStringList(cachedSubscriptionsKey, jsonStringList);
  }

  @override
  Future<void> saveSubscription(SubscriptionModel subscription) async {
    final subscriptions = await getAllSubscriptions();
    subscriptions.add(subscription);
    await cacheSubscriptions(subscriptions);
  }

  @override
  Future<void> updateSubscription(SubscriptionModel subscription) async {
    final subscriptions = await getAllSubscriptions();
    final index = subscriptions.indexWhere((sub) => sub.id == subscription.id);
    if (index != -1) {
      subscriptions[index] = subscription;
      await cacheSubscriptions(subscriptions);
    } else {
      // Optionally handle case where subscription to update is not found
      // For now, it just won't do anything if not found.
      // Or, throw an exception:
      // throw Exception('Subscription with id ${subscription.id} not found for update.');
    }
  }

  @override
  Future<void> deleteSubscription(String id) async {
    final subscriptions = await getAllSubscriptions();
    subscriptions.removeWhere((sub) => sub.id == id);
    await cacheSubscriptions(subscriptions);
  }
}

===== FILE: subscription_model.dart =====
===== PATH: lib/features/subscriptions/data/models/subscription_model.dart =====

// lib/features/subscriptions/data/models/subscription_model.dart

import 'package:aboapp/core/utils/color_serializer.dart';
import 'package:aboapp/features/subscriptions/domain/entities/subscription_entity.dart';
import 'package:flutter/material.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

part 'subscription_model.freezed.dart';
part 'subscription_model.g.dart';

@freezed
class SubscriptionModel with _$SubscriptionModel {
  const SubscriptionModel._();

  // FIX: Die @JsonKey-Annotationen sind jetzt korrekt an den Parametern platziert.
  const factory SubscriptionModel({
    required String id,
    required String name,
    required double price,
    @JsonKey(unknownEnumValue: BillingCycle.custom)
    required BillingCycle billingCycle,
    required DateTime nextBillingDate,
    @JsonKey(unknownEnumValue: SubscriptionCategory.other)
    required SubscriptionCategory category,
    DateTime? startDate,
    String? description,
    String? logoUrl,
    @ColorSerializer() Color? color,
    @Default(true) bool isActive,
    @Default(true) bool notificationsEnabled,
    @Default(7) int notificationDaysBefore,
    DateTime? trialEndDate,
    Map<String, dynamic>? customCycleDetails,
    String? notes,
  }) = _SubscriptionModel;

  factory SubscriptionModel.fromJson(Map<String, dynamic> json) =>
      _$SubscriptionModelFromJson(json);

  factory SubscriptionModel.fromEntity(SubscriptionEntity entity) {
    return SubscriptionModel(
      id: entity.id,
      name: entity.name,
      price: entity.price,
      billingCycle: entity.billingCycle,
      nextBillingDate: entity.nextBillingDate,
      category: entity.category,
      startDate: entity.startDate,
      description: entity.description,
      logoUrl: entity.logoUrl,
      color: entity.color,
      isActive: entity.isActive,
      notificationsEnabled: entity.notificationsEnabled,
      notificationDaysBefore: entity.notificationDaysBefore,
      trialEndDate: entity.trialEndDate,
      customCycleDetails: entity.customCycleDetails,
      notes: entity.notes,
    );
  }

  SubscriptionEntity toEntity() {
    return SubscriptionEntity(
      id: id,
      name: name,
      price: price,
      billingCycle: billingCycle,
      nextBillingDate: nextBillingDate,
      category: category,
      startDate: startDate,
      description: description,
      logoUrl: logoUrl,
      color: color,
      isActive: isActive,
      notificationsEnabled: notificationsEnabled,
      notificationDaysBefore: notificationDaysBefore,
      trialEndDate: trialEndDate,
      customCycleDetails: customCycleDetails,
      notes: notes,
    );
  }
}


===== FILE: subscription_model.freezed.dart =====
===== PATH: lib/features/subscriptions/data/models/subscription_model.freezed.dart =====

// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'subscription_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

SubscriptionModel _$SubscriptionModelFromJson(Map<String, dynamic> json) {
  return _SubscriptionModel.fromJson(json);
}

/// @nodoc
mixin _$SubscriptionModel {
  String get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  double get price => throw _privateConstructorUsedError;
  @JsonKey(unknownEnumValue: BillingCycle.custom)
  BillingCycle get billingCycle => throw _privateConstructorUsedError;
  DateTime get nextBillingDate => throw _privateConstructorUsedError;
  @JsonKey(unknownEnumValue: SubscriptionCategory.other)
  SubscriptionCategory get category => throw _privateConstructorUsedError;
  DateTime? get startDate => throw _privateConstructorUsedError;
  String? get description => throw _privateConstructorUsedError;
  String? get logoUrl => throw _privateConstructorUsedError;
  @ColorSerializer()
  Color? get color => throw _privateConstructorUsedError;
  bool get isActive => throw _privateConstructorUsedError;
  bool get notificationsEnabled => throw _privateConstructorUsedError;
  int get notificationDaysBefore => throw _privateConstructorUsedError;
  DateTime? get trialEndDate => throw _privateConstructorUsedError;
  Map<String, dynamic>? get customCycleDetails =>
      throw _privateConstructorUsedError;
  String? get notes => throw _privateConstructorUsedError;

  /// Serializes this SubscriptionModel to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of SubscriptionModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SubscriptionModelCopyWith<SubscriptionModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubscriptionModelCopyWith<$Res> {
  factory $SubscriptionModelCopyWith(
          SubscriptionModel value, $Res Function(SubscriptionModel) then) =
      _$SubscriptionModelCopyWithImpl<$Res, SubscriptionModel>;
  @useResult
  $Res call(
      {String id,
      String name,
      double price,
      @JsonKey(unknownEnumValue: BillingCycle.custom) BillingCycle billingCycle,
      DateTime nextBillingDate,
      @JsonKey(unknownEnumValue: SubscriptionCategory.other)
      SubscriptionCategory category,
      DateTime? startDate,
      String? description,
      String? logoUrl,
      @ColorSerializer() Color? color,
      bool isActive,
      bool notificationsEnabled,
      int notificationDaysBefore,
      DateTime? trialEndDate,
      Map<String, dynamic>? customCycleDetails,
      String? notes});
}

/// @nodoc
class _$SubscriptionModelCopyWithImpl<$Res, $Val extends SubscriptionModel>
    implements $SubscriptionModelCopyWith<$Res> {
  _$SubscriptionModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SubscriptionModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? price = null,
    Object? billingCycle = null,
    Object? nextBillingDate = null,
    Object? category = null,
    Object? startDate = freezed,
    Object? description = freezed,
    Object? logoUrl = freezed,
    Object? color = freezed,
    Object? isActive = null,
    Object? notificationsEnabled = null,
    Object? notificationDaysBefore = null,
    Object? trialEndDate = freezed,
    Object? customCycleDetails = freezed,
    Object? notes = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      price: null == price
          ? _value.price
          : price // ignore: cast_nullable_to_non_nullable
              as double,
      billingCycle: null == billingCycle
          ? _value.billingCycle
          : billingCycle // ignore: cast_nullable_to_non_nullable
              as BillingCycle,
      nextBillingDate: null == nextBillingDate
          ? _value.nextBillingDate
          : nextBillingDate // ignore: cast_nullable_to_non_nullable
              as DateTime,
      category: null == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as SubscriptionCategory,
      startDate: freezed == startDate
          ? _value.startDate
          : startDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      logoUrl: freezed == logoUrl
          ? _value.logoUrl
          : logoUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      color: freezed == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color?,
      isActive: null == isActive
          ? _value.isActive
          : isActive // ignore: cast_nullable_to_non_nullable
              as bool,
      notificationsEnabled: null == notificationsEnabled
          ? _value.notificationsEnabled
          : notificationsEnabled // ignore: cast_nullable_to_non_nullable
              as bool,
      notificationDaysBefore: null == notificationDaysBefore
          ? _value.notificationDaysBefore
          : notificationDaysBefore // ignore: cast_nullable_to_non_nullable
              as int,
      trialEndDate: freezed == trialEndDate
          ? _value.trialEndDate
          : trialEndDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      customCycleDetails: freezed == customCycleDetails
          ? _value.customCycleDetails
          : customCycleDetails // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      notes: freezed == notes
          ? _value.notes
          : notes // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SubscriptionModelImplCopyWith<$Res>
    implements $SubscriptionModelCopyWith<$Res> {
  factory _$$SubscriptionModelImplCopyWith(_$SubscriptionModelImpl value,
          $Res Function(_$SubscriptionModelImpl) then) =
      __$$SubscriptionModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      double price,
      @JsonKey(unknownEnumValue: BillingCycle.custom) BillingCycle billingCycle,
      DateTime nextBillingDate,
      @JsonKey(unknownEnumValue: SubscriptionCategory.other)
      SubscriptionCategory category,
      DateTime? startDate,
      String? description,
      String? logoUrl,
      @ColorSerializer() Color? color,
      bool isActive,
      bool notificationsEnabled,
      int notificationDaysBefore,
      DateTime? trialEndDate,
      Map<String, dynamic>? customCycleDetails,
      String? notes});
}

/// @nodoc
class __$$SubscriptionModelImplCopyWithImpl<$Res>
    extends _$SubscriptionModelCopyWithImpl<$Res, _$SubscriptionModelImpl>
    implements _$$SubscriptionModelImplCopyWith<$Res> {
  __$$SubscriptionModelImplCopyWithImpl(_$SubscriptionModelImpl _value,
      $Res Function(_$SubscriptionModelImpl) _then)
      : super(_value, _then);

  /// Create a copy of SubscriptionModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? price = null,
    Object? billingCycle = null,
    Object? nextBillingDate = null,
    Object? category = null,
    Object? startDate = freezed,
    Object? description = freezed,
    Object? logoUrl = freezed,
    Object? color = freezed,
    Object? isActive = null,
    Object? notificationsEnabled = null,
    Object? notificationDaysBefore = null,
    Object? trialEndDate = freezed,
    Object? customCycleDetails = freezed,
    Object? notes = freezed,
  }) {
    return _then(_$SubscriptionModelImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      price: null == price
          ? _value.price
          : price // ignore: cast_nullable_to_non_nullable
              as double,
      billingCycle: null == billingCycle
          ? _value.billingCycle
          : billingCycle // ignore: cast_nullable_to_non_nullable
              as BillingCycle,
      nextBillingDate: null == nextBillingDate
          ? _value.nextBillingDate
          : nextBillingDate // ignore: cast_nullable_to_non_nullable
              as DateTime,
      category: null == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as SubscriptionCategory,
      startDate: freezed == startDate
          ? _value.startDate
          : startDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      logoUrl: freezed == logoUrl
          ? _value.logoUrl
          : logoUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      color: freezed == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color?,
      isActive: null == isActive
          ? _value.isActive
          : isActive // ignore: cast_nullable_to_non_nullable
              as bool,
      notificationsEnabled: null == notificationsEnabled
          ? _value.notificationsEnabled
          : notificationsEnabled // ignore: cast_nullable_to_non_nullable
              as bool,
      notificationDaysBefore: null == notificationDaysBefore
          ? _value.notificationDaysBefore
          : notificationDaysBefore // ignore: cast_nullable_to_non_nullable
              as int,
      trialEndDate: freezed == trialEndDate
          ? _value.trialEndDate
          : trialEndDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      customCycleDetails: freezed == customCycleDetails
          ? _value._customCycleDetails
          : customCycleDetails // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      notes: freezed == notes
          ? _value.notes
          : notes // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$SubscriptionModelImpl extends _SubscriptionModel {
  const _$SubscriptionModelImpl(
      {required this.id,
      required this.name,
      required this.price,
      @JsonKey(unknownEnumValue: BillingCycle.custom)
      required this.billingCycle,
      required this.nextBillingDate,
      @JsonKey(unknownEnumValue: SubscriptionCategory.other)
      required this.category,
      this.startDate,
      this.description,
      this.logoUrl,
      @ColorSerializer() this.color,
      this.isActive = true,
      this.notificationsEnabled = true,
      this.notificationDaysBefore = 7,
      this.trialEndDate,
      final Map<String, dynamic>? customCycleDetails,
      this.notes})
      : _customCycleDetails = customCycleDetails,
        super._();

  factory _$SubscriptionModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$SubscriptionModelImplFromJson(json);

  @override
  final String id;
  @override
  final String name;
  @override
  final double price;
  @override
  @JsonKey(unknownEnumValue: BillingCycle.custom)
  final BillingCycle billingCycle;
  @override
  final DateTime nextBillingDate;
  @override
  @JsonKey(unknownEnumValue: SubscriptionCategory.other)
  final SubscriptionCategory category;
  @override
  final DateTime? startDate;
  @override
  final String? description;
  @override
  final String? logoUrl;
  @override
  @ColorSerializer()
  final Color? color;
  @override
  @JsonKey()
  final bool isActive;
  @override
  @JsonKey()
  final bool notificationsEnabled;
  @override
  @JsonKey()
  final int notificationDaysBefore;
  @override
  final DateTime? trialEndDate;
  final Map<String, dynamic>? _customCycleDetails;
  @override
  Map<String, dynamic>? get customCycleDetails {
    final value = _customCycleDetails;
    if (value == null) return null;
    if (_customCycleDetails is EqualUnmodifiableMapView)
      return _customCycleDetails;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  final String? notes;

  @override
  String toString() {
    return 'SubscriptionModel(id: $id, name: $name, price: $price, billingCycle: $billingCycle, nextBillingDate: $nextBillingDate, category: $category, startDate: $startDate, description: $description, logoUrl: $logoUrl, color: $color, isActive: $isActive, notificationsEnabled: $notificationsEnabled, notificationDaysBefore: $notificationDaysBefore, trialEndDate: $trialEndDate, customCycleDetails: $customCycleDetails, notes: $notes)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SubscriptionModelImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.price, price) || other.price == price) &&
            (identical(other.billingCycle, billingCycle) ||
                other.billingCycle == billingCycle) &&
            (identical(other.nextBillingDate, nextBillingDate) ||
                other.nextBillingDate == nextBillingDate) &&
            (identical(other.category, category) ||
                other.category == category) &&
            (identical(other.startDate, startDate) ||
                other.startDate == startDate) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.logoUrl, logoUrl) || other.logoUrl == logoUrl) &&
            (identical(other.color, color) || other.color == color) &&
            (identical(other.isActive, isActive) ||
                other.isActive == isActive) &&
            (identical(other.notificationsEnabled, notificationsEnabled) ||
                other.notificationsEnabled == notificationsEnabled) &&
            (identical(other.notificationDaysBefore, notificationDaysBefore) ||
                other.notificationDaysBefore == notificationDaysBefore) &&
            (identical(other.trialEndDate, trialEndDate) ||
                other.trialEndDate == trialEndDate) &&
            const DeepCollectionEquality()
                .equals(other._customCycleDetails, _customCycleDetails) &&
            (identical(other.notes, notes) || other.notes == notes));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      name,
      price,
      billingCycle,
      nextBillingDate,
      category,
      startDate,
      description,
      logoUrl,
      color,
      isActive,
      notificationsEnabled,
      notificationDaysBefore,
      trialEndDate,
      const DeepCollectionEquality().hash(_customCycleDetails),
      notes);

  /// Create a copy of SubscriptionModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SubscriptionModelImplCopyWith<_$SubscriptionModelImpl> get copyWith =>
      __$$SubscriptionModelImplCopyWithImpl<_$SubscriptionModelImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$SubscriptionModelImplToJson(
      this,
    );
  }
}

abstract class _SubscriptionModel extends SubscriptionModel {
  const factory _SubscriptionModel(
      {required final String id,
      required final String name,
      required final double price,
      @JsonKey(unknownEnumValue: BillingCycle.custom)
      required final BillingCycle billingCycle,
      required final DateTime nextBillingDate,
      @JsonKey(unknownEnumValue: SubscriptionCategory.other)
      required final SubscriptionCategory category,
      final DateTime? startDate,
      final String? description,
      final String? logoUrl,
      @ColorSerializer() final Color? color,
      final bool isActive,
      final bool notificationsEnabled,
      final int notificationDaysBefore,
      final DateTime? trialEndDate,
      final Map<String, dynamic>? customCycleDetails,
      final String? notes}) = _$SubscriptionModelImpl;
  const _SubscriptionModel._() : super._();

  factory _SubscriptionModel.fromJson(Map<String, dynamic> json) =
      _$SubscriptionModelImpl.fromJson;

  @override
  String get id;
  @override
  String get name;
  @override
  double get price;
  @override
  @JsonKey(unknownEnumValue: BillingCycle.custom)
  BillingCycle get billingCycle;
  @override
  DateTime get nextBillingDate;
  @override
  @JsonKey(unknownEnumValue: SubscriptionCategory.other)
  SubscriptionCategory get category;
  @override
  DateTime? get startDate;
  @override
  String? get description;
  @override
  String? get logoUrl;
  @override
  @ColorSerializer()
  Color? get color;
  @override
  bool get isActive;
  @override
  bool get notificationsEnabled;
  @override
  int get notificationDaysBefore;
  @override
  DateTime? get trialEndDate;
  @override
  Map<String, dynamic>? get customCycleDetails;
  @override
  String? get notes;

  /// Create a copy of SubscriptionModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SubscriptionModelImplCopyWith<_$SubscriptionModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}


===== FILE: subscription_model.g.dart =====
===== PATH: lib/features/subscriptions/data/models/subscription_model.g.dart =====

// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'subscription_model.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$SubscriptionModelImpl _$$SubscriptionModelImplFromJson(
        Map<String, dynamic> json) =>
    _$SubscriptionModelImpl(
      id: json['id'] as String,
      name: json['name'] as String,
      price: (json['price'] as num).toDouble(),
      billingCycle: $enumDecode(_$BillingCycleEnumMap, json['billingCycle'],
          unknownValue: BillingCycle.custom),
      nextBillingDate: DateTime.parse(json['nextBillingDate'] as String),
      category: $enumDecode(_$SubscriptionCategoryEnumMap, json['category'],
          unknownValue: SubscriptionCategory.other),
      startDate: json['startDate'] == null
          ? null
          : DateTime.parse(json['startDate'] as String),
      description: json['description'] as String?,
      logoUrl: json['logoUrl'] as String?,
      color: const ColorSerializer().fromJson((json['color'] as num?)?.toInt()),
      isActive: json['isActive'] as bool? ?? true,
      notificationsEnabled: json['notificationsEnabled'] as bool? ?? true,
      notificationDaysBefore:
          (json['notificationDaysBefore'] as num?)?.toInt() ?? 7,
      trialEndDate: json['trialEndDate'] == null
          ? null
          : DateTime.parse(json['trialEndDate'] as String),
      customCycleDetails: json['customCycleDetails'] as Map<String, dynamic>?,
      notes: json['notes'] as String?,
    );

Map<String, dynamic> _$$SubscriptionModelImplToJson(
        _$SubscriptionModelImpl instance) =>
    <String, dynamic>{
      'id': instance.id,
      'name': instance.name,
      'price': instance.price,
      'billingCycle': _$BillingCycleEnumMap[instance.billingCycle]!,
      'nextBillingDate': instance.nextBillingDate.toIso8601String(),
      'category': _$SubscriptionCategoryEnumMap[instance.category]!,
      'startDate': instance.startDate?.toIso8601String(),
      'description': instance.description,
      'logoUrl': instance.logoUrl,
      'color': const ColorSerializer().toJson(instance.color),
      'isActive': instance.isActive,
      'notificationsEnabled': instance.notificationsEnabled,
      'notificationDaysBefore': instance.notificationDaysBefore,
      'trialEndDate': instance.trialEndDate?.toIso8601String(),
      'customCycleDetails': instance.customCycleDetails,
      'notes': instance.notes,
    };

const _$BillingCycleEnumMap = {
  BillingCycle.weekly: 'weekly',
  BillingCycle.monthly: 'monthly',
  BillingCycle.quarterly: 'quarterly',
  BillingCycle.biAnnual: 'biAnnual',
  BillingCycle.yearly: 'yearly',
  BillingCycle.custom: 'custom',
};

const _$SubscriptionCategoryEnumMap = {
  SubscriptionCategory.streaming: 'streaming',
  SubscriptionCategory.software: 'software',
  SubscriptionCategory.gaming: 'gaming',
  SubscriptionCategory.fitness: 'fitness',
  SubscriptionCategory.music: 'music',
  SubscriptionCategory.news: 'news',
  SubscriptionCategory.cloud: 'cloud',
  SubscriptionCategory.utilities: 'utilities',
  SubscriptionCategory.education: 'education',
  SubscriptionCategory.other: 'other',
};


===== FILE: subscription_repository_impl.dart =====
===== PATH: lib/features/subscriptions/data/repositories/subscription_repository_impl.dart =====

import 'package:aboapp/features/subscriptions/data/datasources/subscription_local_datasource.dart';
import 'package:aboapp/features/subscriptions/data/models/subscription_model.dart';
import 'package:aboapp/features/subscriptions/domain/entities/subscription_entity.dart';
import 'package:aboapp/features/subscriptions/domain/repositories/subscription_repository.dart';
import 'package:injectable/injectable.dart';

@LazySingleton(as: SubscriptionRepository)
class SubscriptionRepositoryImpl implements SubscriptionRepository {
  final SubscriptionLocalDataSource localDataSource;

  SubscriptionRepositoryImpl({
    required this.localDataSource,
  });

  @override
  Future<List<SubscriptionEntity>> getAllSubscriptions() async {
    try {
      final localSubscriptions = await localDataSource.getAllSubscriptions();
      return localSubscriptions.map((model) => model.toEntity()).toList();
    } catch (e) {
      // print('Error fetching subscriptions: $e'); // Avoid print
      throw Exception('Could not load subscriptions.'); 
    }
  }

  @override
  Future<SubscriptionEntity?> getSubscriptionById(String id) async {
    final allSubscriptions = await getAllSubscriptions();
    try {
      return allSubscriptions.firstWhere((sub) => sub.id == id);
    } catch (e) {
      return null; 
    }
  }

  @override
  Future<void> addSubscription(SubscriptionEntity subscription) async {
    final model = SubscriptionModel.fromEntity(subscription);
    await localDataSource.saveSubscription(model);
  }

  @override
  Future<void> updateSubscription(SubscriptionEntity subscription) async {
    final model = SubscriptionModel.fromEntity(subscription);
    await localDataSource.updateSubscription(model);
  }

  @override
  Future<void> deleteSubscription(String id) async {
    await localDataSource.deleteSubscription(id);
  }

  @override
  Future<void> saveAllSubscriptions(List<SubscriptionEntity> subscriptions) async {
    final models = subscriptions.map((e) => SubscriptionModel.fromEntity(e)).toList();
    await localDataSource.cacheSubscriptions(models);
  }
}

===== FILE: subscription_entity.dart =====
===== PATH: lib/features/subscriptions/domain/entities/subscription_entity.dart =====

import 'package:flutter/material.dart'; 
import 'package:freezed_annotation/freezed_annotation.dart';

part 'subscription_entity.freezed.dart'; 

enum BillingCycle {
  weekly,
  monthly,
  quarterly,
  biAnnual, 
  yearly,
  custom, 
}

enum SubscriptionCategory {
  streaming,
  software,
  gaming,
  fitness,
  music,
  news,
  cloud,
  utilities, 
  education, 
  other,
}

@freezed
class SubscriptionEntity with _$SubscriptionEntity {
  const SubscriptionEntity._(); 

  const factory SubscriptionEntity({
    required String id,
    required String name,
    required double price, 
    required BillingCycle billingCycle,
    required DateTime nextBillingDate,
    required SubscriptionCategory category,
    DateTime? startDate,
    String? description,
    String? logoUrl, 
    Color? color,     
    @Default(true) bool isActive,
    @Default(true) bool notificationsEnabled,
    @Default(7) int notificationDaysBefore,
    DateTime? trialEndDate,
    Map<String, dynamic>? customCycleDetails, 
    String? notes, 
  }) = _SubscriptionEntity;

  bool get isInTrial {
    if (trialEndDate == null) return false;
    return DateTime.now().isBefore(trialEndDate!);
  }

  int get daysUntilBilling {
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    final nextBillingDay = DateTime(nextBillingDate.year, nextBillingDate.month, nextBillingDate.day);
    return nextBillingDay.difference(today).inDays;
  }

  double get monthlyEquivalentPrice {
    switch (billingCycle) {
      case BillingCycle.weekly:
        return price * (365.25 / 12 / 7); 
      case BillingCycle.monthly:
        return price;
      case BillingCycle.quarterly:
        return price / 3.0;
      case BillingCycle.biAnnual:
        return price / 6.0;
      case BillingCycle.yearly:
        return price / 12.0;
      case BillingCycle.custom:
        final days = customCycleDetails?['value'] as int?;
        if (days != null && days > 0) {
          return price * (30.4375 / days); 
        }
        return price; 
      // No default needed if all cases are covered, but good for safety if enum changes.
      // However, the linter for unreachable_switch_default will trigger if all are covered.
      // Removing default as the error was for it being unreachable.
    }
  }
}

// Moved extensions for SubscriptionCategory to subscription_card_widget.dart
// to keep entity cleaner and consolidate UI helpers.

===== FILE: subscription_entity.freezed.dart =====
===== PATH: lib/features/subscriptions/domain/entities/subscription_entity.freezed.dart =====

// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'subscription_entity.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$SubscriptionEntity {
  String get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  double get price => throw _privateConstructorUsedError;
  BillingCycle get billingCycle => throw _privateConstructorUsedError;
  DateTime get nextBillingDate => throw _privateConstructorUsedError;
  SubscriptionCategory get category => throw _privateConstructorUsedError;
  DateTime? get startDate => throw _privateConstructorUsedError;
  String? get description => throw _privateConstructorUsedError;
  String? get logoUrl => throw _privateConstructorUsedError;
  Color? get color => throw _privateConstructorUsedError;
  bool get isActive => throw _privateConstructorUsedError;
  bool get notificationsEnabled => throw _privateConstructorUsedError;
  int get notificationDaysBefore => throw _privateConstructorUsedError;
  DateTime? get trialEndDate => throw _privateConstructorUsedError;
  Map<String, dynamic>? get customCycleDetails =>
      throw _privateConstructorUsedError;
  String? get notes => throw _privateConstructorUsedError;

  /// Create a copy of SubscriptionEntity
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SubscriptionEntityCopyWith<SubscriptionEntity> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubscriptionEntityCopyWith<$Res> {
  factory $SubscriptionEntityCopyWith(
          SubscriptionEntity value, $Res Function(SubscriptionEntity) then) =
      _$SubscriptionEntityCopyWithImpl<$Res, SubscriptionEntity>;
  @useResult
  $Res call(
      {String id,
      String name,
      double price,
      BillingCycle billingCycle,
      DateTime nextBillingDate,
      SubscriptionCategory category,
      DateTime? startDate,
      String? description,
      String? logoUrl,
      Color? color,
      bool isActive,
      bool notificationsEnabled,
      int notificationDaysBefore,
      DateTime? trialEndDate,
      Map<String, dynamic>? customCycleDetails,
      String? notes});
}

/// @nodoc
class _$SubscriptionEntityCopyWithImpl<$Res, $Val extends SubscriptionEntity>
    implements $SubscriptionEntityCopyWith<$Res> {
  _$SubscriptionEntityCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SubscriptionEntity
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? price = null,
    Object? billingCycle = null,
    Object? nextBillingDate = null,
    Object? category = null,
    Object? startDate = freezed,
    Object? description = freezed,
    Object? logoUrl = freezed,
    Object? color = freezed,
    Object? isActive = null,
    Object? notificationsEnabled = null,
    Object? notificationDaysBefore = null,
    Object? trialEndDate = freezed,
    Object? customCycleDetails = freezed,
    Object? notes = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      price: null == price
          ? _value.price
          : price // ignore: cast_nullable_to_non_nullable
              as double,
      billingCycle: null == billingCycle
          ? _value.billingCycle
          : billingCycle // ignore: cast_nullable_to_non_nullable
              as BillingCycle,
      nextBillingDate: null == nextBillingDate
          ? _value.nextBillingDate
          : nextBillingDate // ignore: cast_nullable_to_non_nullable
              as DateTime,
      category: null == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as SubscriptionCategory,
      startDate: freezed == startDate
          ? _value.startDate
          : startDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      logoUrl: freezed == logoUrl
          ? _value.logoUrl
          : logoUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      color: freezed == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color?,
      isActive: null == isActive
          ? _value.isActive
          : isActive // ignore: cast_nullable_to_non_nullable
              as bool,
      notificationsEnabled: null == notificationsEnabled
          ? _value.notificationsEnabled
          : notificationsEnabled // ignore: cast_nullable_to_non_nullable
              as bool,
      notificationDaysBefore: null == notificationDaysBefore
          ? _value.notificationDaysBefore
          : notificationDaysBefore // ignore: cast_nullable_to_non_nullable
              as int,
      trialEndDate: freezed == trialEndDate
          ? _value.trialEndDate
          : trialEndDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      customCycleDetails: freezed == customCycleDetails
          ? _value.customCycleDetails
          : customCycleDetails // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      notes: freezed == notes
          ? _value.notes
          : notes // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SubscriptionEntityImplCopyWith<$Res>
    implements $SubscriptionEntityCopyWith<$Res> {
  factory _$$SubscriptionEntityImplCopyWith(_$SubscriptionEntityImpl value,
          $Res Function(_$SubscriptionEntityImpl) then) =
      __$$SubscriptionEntityImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      double price,
      BillingCycle billingCycle,
      DateTime nextBillingDate,
      SubscriptionCategory category,
      DateTime? startDate,
      String? description,
      String? logoUrl,
      Color? color,
      bool isActive,
      bool notificationsEnabled,
      int notificationDaysBefore,
      DateTime? trialEndDate,
      Map<String, dynamic>? customCycleDetails,
      String? notes});
}

/// @nodoc
class __$$SubscriptionEntityImplCopyWithImpl<$Res>
    extends _$SubscriptionEntityCopyWithImpl<$Res, _$SubscriptionEntityImpl>
    implements _$$SubscriptionEntityImplCopyWith<$Res> {
  __$$SubscriptionEntityImplCopyWithImpl(_$SubscriptionEntityImpl _value,
      $Res Function(_$SubscriptionEntityImpl) _then)
      : super(_value, _then);

  /// Create a copy of SubscriptionEntity
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? price = null,
    Object? billingCycle = null,
    Object? nextBillingDate = null,
    Object? category = null,
    Object? startDate = freezed,
    Object? description = freezed,
    Object? logoUrl = freezed,
    Object? color = freezed,
    Object? isActive = null,
    Object? notificationsEnabled = null,
    Object? notificationDaysBefore = null,
    Object? trialEndDate = freezed,
    Object? customCycleDetails = freezed,
    Object? notes = freezed,
  }) {
    return _then(_$SubscriptionEntityImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      price: null == price
          ? _value.price
          : price // ignore: cast_nullable_to_non_nullable
              as double,
      billingCycle: null == billingCycle
          ? _value.billingCycle
          : billingCycle // ignore: cast_nullable_to_non_nullable
              as BillingCycle,
      nextBillingDate: null == nextBillingDate
          ? _value.nextBillingDate
          : nextBillingDate // ignore: cast_nullable_to_non_nullable
              as DateTime,
      category: null == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as SubscriptionCategory,
      startDate: freezed == startDate
          ? _value.startDate
          : startDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      logoUrl: freezed == logoUrl
          ? _value.logoUrl
          : logoUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      color: freezed == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color?,
      isActive: null == isActive
          ? _value.isActive
          : isActive // ignore: cast_nullable_to_non_nullable
              as bool,
      notificationsEnabled: null == notificationsEnabled
          ? _value.notificationsEnabled
          : notificationsEnabled // ignore: cast_nullable_to_non_nullable
              as bool,
      notificationDaysBefore: null == notificationDaysBefore
          ? _value.notificationDaysBefore
          : notificationDaysBefore // ignore: cast_nullable_to_non_nullable
              as int,
      trialEndDate: freezed == trialEndDate
          ? _value.trialEndDate
          : trialEndDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      customCycleDetails: freezed == customCycleDetails
          ? _value._customCycleDetails
          : customCycleDetails // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      notes: freezed == notes
          ? _value.notes
          : notes // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$SubscriptionEntityImpl extends _SubscriptionEntity {
  const _$SubscriptionEntityImpl(
      {required this.id,
      required this.name,
      required this.price,
      required this.billingCycle,
      required this.nextBillingDate,
      required this.category,
      this.startDate,
      this.description,
      this.logoUrl,
      this.color,
      this.isActive = true,
      this.notificationsEnabled = true,
      this.notificationDaysBefore = 7,
      this.trialEndDate,
      final Map<String, dynamic>? customCycleDetails,
      this.notes})
      : _customCycleDetails = customCycleDetails,
        super._();

  @override
  final String id;
  @override
  final String name;
  @override
  final double price;
  @override
  final BillingCycle billingCycle;
  @override
  final DateTime nextBillingDate;
  @override
  final SubscriptionCategory category;
  @override
  final DateTime? startDate;
  @override
  final String? description;
  @override
  final String? logoUrl;
  @override
  final Color? color;
  @override
  @JsonKey()
  final bool isActive;
  @override
  @JsonKey()
  final bool notificationsEnabled;
  @override
  @JsonKey()
  final int notificationDaysBefore;
  @override
  final DateTime? trialEndDate;
  final Map<String, dynamic>? _customCycleDetails;
  @override
  Map<String, dynamic>? get customCycleDetails {
    final value = _customCycleDetails;
    if (value == null) return null;
    if (_customCycleDetails is EqualUnmodifiableMapView)
      return _customCycleDetails;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  final String? notes;

  @override
  String toString() {
    return 'SubscriptionEntity(id: $id, name: $name, price: $price, billingCycle: $billingCycle, nextBillingDate: $nextBillingDate, category: $category, startDate: $startDate, description: $description, logoUrl: $logoUrl, color: $color, isActive: $isActive, notificationsEnabled: $notificationsEnabled, notificationDaysBefore: $notificationDaysBefore, trialEndDate: $trialEndDate, customCycleDetails: $customCycleDetails, notes: $notes)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SubscriptionEntityImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.price, price) || other.price == price) &&
            (identical(other.billingCycle, billingCycle) ||
                other.billingCycle == billingCycle) &&
            (identical(other.nextBillingDate, nextBillingDate) ||
                other.nextBillingDate == nextBillingDate) &&
            (identical(other.category, category) ||
                other.category == category) &&
            (identical(other.startDate, startDate) ||
                other.startDate == startDate) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.logoUrl, logoUrl) || other.logoUrl == logoUrl) &&
            (identical(other.color, color) || other.color == color) &&
            (identical(other.isActive, isActive) ||
                other.isActive == isActive) &&
            (identical(other.notificationsEnabled, notificationsEnabled) ||
                other.notificationsEnabled == notificationsEnabled) &&
            (identical(other.notificationDaysBefore, notificationDaysBefore) ||
                other.notificationDaysBefore == notificationDaysBefore) &&
            (identical(other.trialEndDate, trialEndDate) ||
                other.trialEndDate == trialEndDate) &&
            const DeepCollectionEquality()
                .equals(other._customCycleDetails, _customCycleDetails) &&
            (identical(other.notes, notes) || other.notes == notes));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      name,
      price,
      billingCycle,
      nextBillingDate,
      category,
      startDate,
      description,
      logoUrl,
      color,
      isActive,
      notificationsEnabled,
      notificationDaysBefore,
      trialEndDate,
      const DeepCollectionEquality().hash(_customCycleDetails),
      notes);

  /// Create a copy of SubscriptionEntity
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SubscriptionEntityImplCopyWith<_$SubscriptionEntityImpl> get copyWith =>
      __$$SubscriptionEntityImplCopyWithImpl<_$SubscriptionEntityImpl>(
          this, _$identity);
}

abstract class _SubscriptionEntity extends SubscriptionEntity {
  const factory _SubscriptionEntity(
      {required final String id,
      required final String name,
      required final double price,
      required final BillingCycle billingCycle,
      required final DateTime nextBillingDate,
      required final SubscriptionCategory category,
      final DateTime? startDate,
      final String? description,
      final String? logoUrl,
      final Color? color,
      final bool isActive,
      final bool notificationsEnabled,
      final int notificationDaysBefore,
      final DateTime? trialEndDate,
      final Map<String, dynamic>? customCycleDetails,
      final String? notes}) = _$SubscriptionEntityImpl;
  const _SubscriptionEntity._() : super._();

  @override
  String get id;
  @override
  String get name;
  @override
  double get price;
  @override
  BillingCycle get billingCycle;
  @override
  DateTime get nextBillingDate;
  @override
  SubscriptionCategory get category;
  @override
  DateTime? get startDate;
  @override
  String? get description;
  @override
  String? get logoUrl;
  @override
  Color? get color;
  @override
  bool get isActive;
  @override
  bool get notificationsEnabled;
  @override
  int get notificationDaysBefore;
  @override
  DateTime? get trialEndDate;
  @override
  Map<String, dynamic>? get customCycleDetails;
  @override
  String? get notes;

  /// Create a copy of SubscriptionEntity
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SubscriptionEntityImplCopyWith<_$SubscriptionEntityImpl> get copyWith =>
      throw _privateConstructorUsedError;
}


===== FILE: subscription_repository.dart =====
===== PATH: lib/features/subscriptions/domain/repositories/subscription_repository.dart =====

import 'package:aboapp/features/subscriptions/domain/entities/subscription_entity.dart';
// Using a Either for functional error handling is a good practice, but for simplicity,
// we can use Futures that might throw exceptions, to be handled by the BLoC/Cubit.
// import 'package:dartz/dartz.dart'; // For Either
// import 'package:aboapp/core/error/failures.dart'; // Custom failure types

abstract class SubscriptionRepository {
  Future<List<SubscriptionEntity>> getAllSubscriptions();
  Future<SubscriptionEntity?> getSubscriptionById(String id);
  Future<void> addSubscription(SubscriptionEntity subscription);
  Future<void> updateSubscription(SubscriptionEntity subscription);
  Future<void> deleteSubscription(String id);
  Future<void> saveAllSubscriptions(List<SubscriptionEntity> subscriptions); // For bulk operations if needed
}

===== FILE: add_subscription_usecase.dart =====
===== PATH: lib/features/subscriptions/domain/usecases/add_subscription_usecase.dart =====

import 'package:aboapp/features/subscriptions/domain/entities/subscription_entity.dart';
import 'package:aboapp/features/subscriptions/domain/repositories/subscription_repository.dart';
import 'package:injectable/injectable.dart';

@lazySingleton
class AddSubscriptionUseCase {
  final SubscriptionRepository repository;

  AddSubscriptionUseCase(this.repository);

  Future<void> call(SubscriptionEntity subscription) async {
    // Business logic before adding, e.g., validation, could go here.
    // However, complex validation is often better handled in the entity or BLoC/Cubit.
    return await repository.addSubscription(subscription);
  }
}

===== FILE: delete_subscription_usecase.dart =====
===== PATH: lib/features/subscriptions/domain/usecases/delete_subscription_usecase.dart =====

import 'package:aboapp/features/subscriptions/domain/repositories/subscription_repository.dart';
import 'package:injectable/injectable.dart';

@lazySingleton
class DeleteSubscriptionUseCase {
  final SubscriptionRepository repository;

  DeleteSubscriptionUseCase(this.repository);

  Future<void> call(String id) async {
    return await repository.deleteSubscription(id);
  }
}

===== FILE: get_all_subscriptions_usecase.dart =====
===== PATH: lib/features/subscriptions/domain/usecases/get_all_subscriptions_usecase.dart =====

import 'package:aboapp/features/subscriptions/domain/entities/subscription_entity.dart';
import 'package:aboapp/features/subscriptions/domain/repositories/subscription_repository.dart';
import 'package:injectable/injectable.dart';

// Basic use case structure. Can be expanded with parameters if needed (e.g., for filtering).
// For more complex scenarios, consider a generic UseCase class.

@lazySingleton
class GetAllSubscriptionsUseCase {
  final SubscriptionRepository repository;

  GetAllSubscriptionsUseCase(this.repository);

  Future<List<SubscriptionEntity>> call() async {
    // You can add pre-processing or post-processing logic here if necessary.
    return await repository.getAllSubscriptions();
  }
}

===== FILE: update_subscription_usecase.dart =====
===== PATH: lib/features/subscriptions/domain/usecases/update_subscription_usecase.dart =====

import 'package:aboapp/features/subscriptions/domain/entities/subscription_entity.dart';
import 'package:aboapp/features/subscriptions/domain/repositories/subscription_repository.dart';
import 'package:injectable/injectable.dart';

@lazySingleton
class UpdateSubscriptionUseCase {
  final SubscriptionRepository repository;

  UpdateSubscriptionUseCase(this.repository);

  Future<void> call(SubscriptionEntity subscription) async {
    return await repository.updateSubscription(subscription);
  }
}

===== FILE: subscription_cubit.dart =====
===== PATH: lib/features/subscriptions/presentation/cubit/subscription_cubit.dart =====

// lib/features/subscriptions/presentation/cubit/subscription_cubit.dart
import 'package:aboapp/features/subscriptions/domain/entities/subscription_entity.dart';
import 'package:aboapp/features/subscriptions/domain/usecases/add_subscription_usecase.dart';
import 'package:aboapp/features/subscriptions/domain/usecases/delete_subscription_usecase.dart';
import 'package:aboapp/features/subscriptions/domain/usecases/get_all_subscriptions_usecase.dart';
import 'package:aboapp/features/subscriptions/domain/usecases/update_subscription_usecase.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:injectable/injectable.dart';
import 'package:uuid/uuid.dart';

part 'subscription_state.dart';
part 'subscription_cubit.freezed.dart';

@injectable
class SubscriptionCubit extends Cubit<SubscriptionState> {
  final GetAllSubscriptionsUseCase _getAllSubscriptions;
  final AddSubscriptionUseCase _addSubscription;
  final UpdateSubscriptionUseCase _updateSubscription;
  final DeleteSubscriptionUseCase _deleteSubscription;
  final Uuid _uuid;

  List<SubscriptionEntity> _masterSubscriptionList = [];

  SubscriptionCubit(
    this._getAllSubscriptions,
    this._addSubscription,
    this._updateSubscription,
    this._deleteSubscription,
    this._uuid,
  ) : super(const SubscriptionState.initial());

  Future<void> loadSubscriptions() async {
    emit(const SubscriptionState.loading());
    try {
      _masterSubscriptionList = await _getAllSubscriptions();
      _applyFiltersAndSort();
    } catch (e) {
      emit(SubscriptionState.error(message: e.toString()));
    }
  }

  Future<void> addSubscription(SubscriptionEntity subscription) async {
    final subToAdd = subscription.id.isEmpty
        ? subscription.copyWith(id: _uuid.v4())
        : subscription;
    emit(const SubscriptionState.loading());
    try {
      await _addSubscription(subToAdd);
      _masterSubscriptionList.add(subToAdd);
      _applyFiltersAndSort();
    } catch (e) {
      emit(SubscriptionState.error(
          message: "Failed to add subscription: ${e.toString()}"));
      _applyFiltersAndSort();
    }
  }

  Future<void> updateSubscription(SubscriptionEntity subscription) async {
    emit(const SubscriptionState.loading());
    try {
      await _updateSubscription(subscription);
      final index =
          _masterSubscriptionList.indexWhere((s) => s.id == subscription.id);
      if (index != -1) {
        _masterSubscriptionList[index] = subscription;
      } else {
        _masterSubscriptionList.add(subscription);
      }
      _applyFiltersAndSort();
    } catch (e) {
      emit(SubscriptionState.error(
          message: "Failed to update subscription: ${e.toString()}"));
      _applyFiltersAndSort();
    }
  }

  Future<void> deleteSubscription(String id) async {
    emit(const SubscriptionState.loading());
    try {
      await _deleteSubscription(id);
      _masterSubscriptionList.removeWhere((s) => s.id == id);
      _applyFiltersAndSort();
    } catch (e) {
      emit(SubscriptionState.error(
          message: "Failed to delete subscription: ${e.toString()}"));
      _applyFiltersAndSort();
    }
  }

  Future<void> toggleSubscriptionActiveStatus(String id) async {
    final index = _masterSubscriptionList.indexWhere((s) => s.id == id);
    if (index != -1) {
      final sub = _masterSubscriptionList[index];
      final updatedSub = sub.copyWith(isActive: !sub.isActive);
      await updateSubscription(updatedSub);
    }
  }

  Future<void> toggleSubscriptionNotification(String id) async {
    final index = _masterSubscriptionList.indexWhere((s) => s.id == id);
    if (index != -1) {
      final sub = _masterSubscriptionList[index];
      final updatedSub =
          sub.copyWith(notificationsEnabled: !sub.notificationsEnabled);
      await updateSubscription(updatedSub);
    }
  }

  void _applyFiltersAndSort({
    SortOption? newSortOption,
    List<SubscriptionCategory>? newFilterCategories,
    List<BillingCycle>? newFilterBillingCycles,
    String? newSearchTerm,
    bool clearSearch = false,
    bool clearCategories = false,
    bool clearBillingCycles = false,
  }) {
    final currentState = state.maybeWhen(
      loaded: (alls, filters, sort, cats, bills, search) => state as _Loaded,
      orElse: () => null,
    );

    SortOption currentSortOption = newSortOption ??
        currentState?.currentSortOption ??
        SortOption.nextBillingDateAsc;
    List<SubscriptionCategory> currentFilterCategories =
        newFilterCategories ?? currentState?.filterCategories ?? [];
    List<BillingCycle> currentFilterBillingCycles =
        newFilterBillingCycles ?? currentState?.filterBillingCycles ?? [];
    String? currentSearchTerm = newSearchTerm ?? currentState?.searchTerm;

    if (clearSearch) currentSearchTerm = null;
    if (clearCategories) currentFilterCategories = [];
    if (clearBillingCycles) currentFilterBillingCycles = [];

    List<SubscriptionEntity> filtered = List.from(_masterSubscriptionList);

    if (currentSearchTerm != null && currentSearchTerm.isNotEmpty) {
      final query = currentSearchTerm.toLowerCase();
      filtered = filtered
          .where((sub) =>
              sub.name.toLowerCase().contains(query) ||
              (sub.description?.toLowerCase().contains(query) ?? false))
          .toList();
    }

    if (currentFilterCategories.isNotEmpty) {
      filtered = filtered
          .where((sub) => currentFilterCategories.contains(sub.category))
          .toList();
    }

    if (currentFilterBillingCycles.isNotEmpty) {
      filtered = filtered
          .where((sub) => currentFilterBillingCycles.contains(sub.billingCycle))
          .toList();
    }

    switch (currentSortOption) {
      case SortOption.nameAsc:
        filtered.sort(
            (a, b) => a.name.toLowerCase().compareTo(b.name.toLowerCase()));
        break;
      case SortOption.nameDesc:
        filtered.sort(
            (a, b) => b.name.toLowerCase().compareTo(a.name.toLowerCase()));
        break;
      case SortOption.priceAsc:
        filtered.sort((a, b) =>
            a.monthlyEquivalentPrice.compareTo(b.monthlyEquivalentPrice));
        break;
      case SortOption.priceDesc:
        filtered.sort((a, b) =>
            b.monthlyEquivalentPrice.compareTo(a.monthlyEquivalentPrice));
        break;
      case SortOption.nextBillingDateAsc:
        filtered.sort((a, b) => a.nextBillingDate.compareTo(b.nextBillingDate));
        break;
      case SortOption.nextBillingDateDesc:
        filtered.sort((a, b) => b.nextBillingDate.compareTo(a.nextBillingDate));
        break;
      case SortOption.category:
        filtered.sort((a, b) => a.category.index.compareTo(b.category.index));
        break;
    }

    emit(SubscriptionState.loaded(
      allSubscriptions: _masterSubscriptionList,
      filteredSubscriptions: filtered,
      currentSortOption: currentSortOption,
      filterCategories: currentFilterCategories,
      filterBillingCycles: currentFilterBillingCycles,
      searchTerm: currentSearchTerm,
    ));
  }

  void changeSortOption(SortOption option) {
    _applyFiltersAndSort(newSortOption: option);
  }

  void toggleCategoryFilter(SubscriptionCategory category) {
    final currentState = state.maybeWhen(
      loaded: (alls, filters, sort, cats, bills, search) => state as _Loaded,
      orElse: () => null,
    );
    if (currentState == null) return;

    List<SubscriptionCategory> currentCats =
        List.from(currentState.filterCategories ?? []);

    if (currentCats.contains(category)) {
      currentCats.remove(category);
    } else {
      currentCats.add(category);
    }
    _applyFiltersAndSort(newFilterCategories: currentCats);
  }

  void toggleBillingCycleFilter(BillingCycle cycle) {
    final currentState = state.maybeWhen(
      loaded: (alls, filters, sort, cats, bills, search) => state as _Loaded,
      orElse: () => null,
    );
    if (currentState == null) return;

    List<BillingCycle> currentCycles =
        List.from(currentState.filterBillingCycles ?? []);

    if (currentCycles.contains(cycle)) {
      currentCycles.remove(cycle);
    } else {
      currentCycles.add(cycle);
    }
    _applyFiltersAndSort(newFilterBillingCycles: currentCycles);
  }

  void searchSubscriptions(String searchTerm) {
    _applyFiltersAndSort(newSearchTerm: searchTerm);
  }

  void clearSearch() {
    _applyFiltersAndSort(clearSearch: true, newSearchTerm: '');
  }

  void clearCategoryFilters() {
    _applyFiltersAndSort(clearCategories: true);
  }

  void clearBillingCycleFilters() {
    _applyFiltersAndSort(clearBillingCycles: true);
  }

  void clearAllFilters() {
    _applyFiltersAndSort(
      clearCategories: true,
      clearBillingCycles: true,
      newSearchTerm: '',
      clearSearch: true,
    );
  }

  void setCategoryFilters(List<SubscriptionCategory> categories) {
    _applyFiltersAndSort(newFilterCategories: categories);
  }

  void setBillingCycleFilters(List<BillingCycle> cycles) {
    _applyFiltersAndSort(newFilterBillingCycles: cycles);
  }
}


===== FILE: subscription_cubit.freezed.dart =====
===== PATH: lib/features/subscriptions/presentation/cubit/subscription_cubit.freezed.dart =====

// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'subscription_cubit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$SubscriptionState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            List<SubscriptionEntity> allSubscriptions,
            List<SubscriptionEntity> filteredSubscriptions,
            SortOption? currentSortOption,
            List<SubscriptionCategory>? filterCategories,
            List<BillingCycle>? filterBillingCycles,
            String? searchTerm)
        loaded,
    required TResult Function(String message) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(
            List<SubscriptionEntity> allSubscriptions,
            List<SubscriptionEntity> filteredSubscriptions,
            SortOption? currentSortOption,
            List<SubscriptionCategory>? filterCategories,
            List<BillingCycle>? filterBillingCycles,
            String? searchTerm)?
        loaded,
    TResult? Function(String message)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            List<SubscriptionEntity> allSubscriptions,
            List<SubscriptionEntity> filteredSubscriptions,
            SortOption? currentSortOption,
            List<SubscriptionCategory>? filterCategories,
            List<BillingCycle>? filterBillingCycles,
            String? searchTerm)?
        loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubscriptionStateCopyWith<$Res> {
  factory $SubscriptionStateCopyWith(
          SubscriptionState value, $Res Function(SubscriptionState) then) =
      _$SubscriptionStateCopyWithImpl<$Res, SubscriptionState>;
}

/// @nodoc
class _$SubscriptionStateCopyWithImpl<$Res, $Val extends SubscriptionState>
    implements $SubscriptionStateCopyWith<$Res> {
  _$SubscriptionStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SubscriptionState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$InitialImplCopyWith<$Res> {
  factory _$$InitialImplCopyWith(
          _$InitialImpl value, $Res Function(_$InitialImpl) then) =
      __$$InitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitialImplCopyWithImpl<$Res>
    extends _$SubscriptionStateCopyWithImpl<$Res, _$InitialImpl>
    implements _$$InitialImplCopyWith<$Res> {
  __$$InitialImplCopyWithImpl(
      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)
      : super(_value, _then);

  /// Create a copy of SubscriptionState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$InitialImpl implements _Initial {
  const _$InitialImpl();

  @override
  String toString() {
    return 'SubscriptionState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            List<SubscriptionEntity> allSubscriptions,
            List<SubscriptionEntity> filteredSubscriptions,
            SortOption? currentSortOption,
            List<SubscriptionCategory>? filterCategories,
            List<BillingCycle>? filterBillingCycles,
            String? searchTerm)
        loaded,
    required TResult Function(String message) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(
            List<SubscriptionEntity> allSubscriptions,
            List<SubscriptionEntity> filteredSubscriptions,
            SortOption? currentSortOption,
            List<SubscriptionCategory>? filterCategories,
            List<BillingCycle>? filterBillingCycles,
            String? searchTerm)?
        loaded,
    TResult? Function(String message)? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            List<SubscriptionEntity> allSubscriptions,
            List<SubscriptionEntity> filteredSubscriptions,
            SortOption? currentSortOption,
            List<SubscriptionCategory>? filterCategories,
            List<BillingCycle>? filterBillingCycles,
            String? searchTerm)?
        loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements SubscriptionState {
  const factory _Initial() = _$InitialImpl;
}

/// @nodoc
abstract class _$$LoadingImplCopyWith<$Res> {
  factory _$$LoadingImplCopyWith(
          _$LoadingImpl value, $Res Function(_$LoadingImpl) then) =
      __$$LoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadingImplCopyWithImpl<$Res>
    extends _$SubscriptionStateCopyWithImpl<$Res, _$LoadingImpl>
    implements _$$LoadingImplCopyWith<$Res> {
  __$$LoadingImplCopyWithImpl(
      _$LoadingImpl _value, $Res Function(_$LoadingImpl) _then)
      : super(_value, _then);

  /// Create a copy of SubscriptionState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$LoadingImpl implements _Loading {
  const _$LoadingImpl();

  @override
  String toString() {
    return 'SubscriptionState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            List<SubscriptionEntity> allSubscriptions,
            List<SubscriptionEntity> filteredSubscriptions,
            SortOption? currentSortOption,
            List<SubscriptionCategory>? filterCategories,
            List<BillingCycle>? filterBillingCycles,
            String? searchTerm)
        loaded,
    required TResult Function(String message) error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(
            List<SubscriptionEntity> allSubscriptions,
            List<SubscriptionEntity> filteredSubscriptions,
            SortOption? currentSortOption,
            List<SubscriptionCategory>? filterCategories,
            List<BillingCycle>? filterBillingCycles,
            String? searchTerm)?
        loaded,
    TResult? Function(String message)? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            List<SubscriptionEntity> allSubscriptions,
            List<SubscriptionEntity> filteredSubscriptions,
            SortOption? currentSortOption,
            List<SubscriptionCategory>? filterCategories,
            List<BillingCycle>? filterBillingCycles,
            String? searchTerm)?
        loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _Loading implements SubscriptionState {
  const factory _Loading() = _$LoadingImpl;
}

/// @nodoc
abstract class _$$LoadedImplCopyWith<$Res> {
  factory _$$LoadedImplCopyWith(
          _$LoadedImpl value, $Res Function(_$LoadedImpl) then) =
      __$$LoadedImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {List<SubscriptionEntity> allSubscriptions,
      List<SubscriptionEntity> filteredSubscriptions,
      SortOption? currentSortOption,
      List<SubscriptionCategory>? filterCategories,
      List<BillingCycle>? filterBillingCycles,
      String? searchTerm});
}

/// @nodoc
class __$$LoadedImplCopyWithImpl<$Res>
    extends _$SubscriptionStateCopyWithImpl<$Res, _$LoadedImpl>
    implements _$$LoadedImplCopyWith<$Res> {
  __$$LoadedImplCopyWithImpl(
      _$LoadedImpl _value, $Res Function(_$LoadedImpl) _then)
      : super(_value, _then);

  /// Create a copy of SubscriptionState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? allSubscriptions = null,
    Object? filteredSubscriptions = null,
    Object? currentSortOption = freezed,
    Object? filterCategories = freezed,
    Object? filterBillingCycles = freezed,
    Object? searchTerm = freezed,
  }) {
    return _then(_$LoadedImpl(
      allSubscriptions: null == allSubscriptions
          ? _value._allSubscriptions
          : allSubscriptions // ignore: cast_nullable_to_non_nullable
              as List<SubscriptionEntity>,
      filteredSubscriptions: null == filteredSubscriptions
          ? _value._filteredSubscriptions
          : filteredSubscriptions // ignore: cast_nullable_to_non_nullable
              as List<SubscriptionEntity>,
      currentSortOption: freezed == currentSortOption
          ? _value.currentSortOption
          : currentSortOption // ignore: cast_nullable_to_non_nullable
              as SortOption?,
      filterCategories: freezed == filterCategories
          ? _value._filterCategories
          : filterCategories // ignore: cast_nullable_to_non_nullable
              as List<SubscriptionCategory>?,
      filterBillingCycles: freezed == filterBillingCycles
          ? _value._filterBillingCycles
          : filterBillingCycles // ignore: cast_nullable_to_non_nullable
              as List<BillingCycle>?,
      searchTerm: freezed == searchTerm
          ? _value.searchTerm
          : searchTerm // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$LoadedImpl implements _Loaded {
  const _$LoadedImpl(
      {required final List<SubscriptionEntity> allSubscriptions,
      required final List<SubscriptionEntity> filteredSubscriptions,
      this.currentSortOption,
      final List<SubscriptionCategory>? filterCategories,
      final List<BillingCycle>? filterBillingCycles,
      this.searchTerm})
      : _allSubscriptions = allSubscriptions,
        _filteredSubscriptions = filteredSubscriptions,
        _filterCategories = filterCategories,
        _filterBillingCycles = filterBillingCycles;

  final List<SubscriptionEntity> _allSubscriptions;
  @override
  List<SubscriptionEntity> get allSubscriptions {
    if (_allSubscriptions is EqualUnmodifiableListView)
      return _allSubscriptions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_allSubscriptions);
  }

  final List<SubscriptionEntity> _filteredSubscriptions;
  @override
  List<SubscriptionEntity> get filteredSubscriptions {
    if (_filteredSubscriptions is EqualUnmodifiableListView)
      return _filteredSubscriptions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_filteredSubscriptions);
  }

  @override
  final SortOption? currentSortOption;
  final List<SubscriptionCategory>? _filterCategories;
  @override
  List<SubscriptionCategory>? get filterCategories {
    final value = _filterCategories;
    if (value == null) return null;
    if (_filterCategories is EqualUnmodifiableListView)
      return _filterCategories;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<BillingCycle>? _filterBillingCycles;
  @override
  List<BillingCycle>? get filterBillingCycles {
    final value = _filterBillingCycles;
    if (value == null) return null;
    if (_filterBillingCycles is EqualUnmodifiableListView)
      return _filterBillingCycles;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

// NEU: Liste für Zyklen
  @override
  final String? searchTerm;

  @override
  String toString() {
    return 'SubscriptionState.loaded(allSubscriptions: $allSubscriptions, filteredSubscriptions: $filteredSubscriptions, currentSortOption: $currentSortOption, filterCategories: $filterCategories, filterBillingCycles: $filterBillingCycles, searchTerm: $searchTerm)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoadedImpl &&
            const DeepCollectionEquality()
                .equals(other._allSubscriptions, _allSubscriptions) &&
            const DeepCollectionEquality()
                .equals(other._filteredSubscriptions, _filteredSubscriptions) &&
            (identical(other.currentSortOption, currentSortOption) ||
                other.currentSortOption == currentSortOption) &&
            const DeepCollectionEquality()
                .equals(other._filterCategories, _filterCategories) &&
            const DeepCollectionEquality()
                .equals(other._filterBillingCycles, _filterBillingCycles) &&
            (identical(other.searchTerm, searchTerm) ||
                other.searchTerm == searchTerm));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_allSubscriptions),
      const DeepCollectionEquality().hash(_filteredSubscriptions),
      currentSortOption,
      const DeepCollectionEquality().hash(_filterCategories),
      const DeepCollectionEquality().hash(_filterBillingCycles),
      searchTerm);

  /// Create a copy of SubscriptionState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$LoadedImplCopyWith<_$LoadedImpl> get copyWith =>
      __$$LoadedImplCopyWithImpl<_$LoadedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            List<SubscriptionEntity> allSubscriptions,
            List<SubscriptionEntity> filteredSubscriptions,
            SortOption? currentSortOption,
            List<SubscriptionCategory>? filterCategories,
            List<BillingCycle>? filterBillingCycles,
            String? searchTerm)
        loaded,
    required TResult Function(String message) error,
  }) {
    return loaded(allSubscriptions, filteredSubscriptions, currentSortOption,
        filterCategories, filterBillingCycles, searchTerm);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(
            List<SubscriptionEntity> allSubscriptions,
            List<SubscriptionEntity> filteredSubscriptions,
            SortOption? currentSortOption,
            List<SubscriptionCategory>? filterCategories,
            List<BillingCycle>? filterBillingCycles,
            String? searchTerm)?
        loaded,
    TResult? Function(String message)? error,
  }) {
    return loaded?.call(allSubscriptions, filteredSubscriptions,
        currentSortOption, filterCategories, filterBillingCycles, searchTerm);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            List<SubscriptionEntity> allSubscriptions,
            List<SubscriptionEntity> filteredSubscriptions,
            SortOption? currentSortOption,
            List<SubscriptionCategory>? filterCategories,
            List<BillingCycle>? filterBillingCycles,
            String? searchTerm)?
        loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(allSubscriptions, filteredSubscriptions, currentSortOption,
          filterCategories, filterBillingCycles, searchTerm);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class _Loaded implements SubscriptionState {
  const factory _Loaded(
      {required final List<SubscriptionEntity> allSubscriptions,
      required final List<SubscriptionEntity> filteredSubscriptions,
      final SortOption? currentSortOption,
      final List<SubscriptionCategory>? filterCategories,
      final List<BillingCycle>? filterBillingCycles,
      final String? searchTerm}) = _$LoadedImpl;

  List<SubscriptionEntity> get allSubscriptions;
  List<SubscriptionEntity> get filteredSubscriptions;
  SortOption? get currentSortOption;
  List<SubscriptionCategory>? get filterCategories;
  List<BillingCycle>? get filterBillingCycles; // NEU: Liste für Zyklen
  String? get searchTerm;

  /// Create a copy of SubscriptionState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$LoadedImplCopyWith<_$LoadedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ErrorImplCopyWith<$Res> {
  factory _$$ErrorImplCopyWith(
          _$ErrorImpl value, $Res Function(_$ErrorImpl) then) =
      __$$ErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$ErrorImplCopyWithImpl<$Res>
    extends _$SubscriptionStateCopyWithImpl<$Res, _$ErrorImpl>
    implements _$$ErrorImplCopyWith<$Res> {
  __$$ErrorImplCopyWithImpl(
      _$ErrorImpl _value, $Res Function(_$ErrorImpl) _then)
      : super(_value, _then);

  /// Create a copy of SubscriptionState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$ErrorImpl(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ErrorImpl implements _Error {
  const _$ErrorImpl({required this.message});

  @override
  final String message;

  @override
  String toString() {
    return 'SubscriptionState.error(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ErrorImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  /// Create a copy of SubscriptionState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>
      __$$ErrorImplCopyWithImpl<_$ErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            List<SubscriptionEntity> allSubscriptions,
            List<SubscriptionEntity> filteredSubscriptions,
            SortOption? currentSortOption,
            List<SubscriptionCategory>? filterCategories,
            List<BillingCycle>? filterBillingCycles,
            String? searchTerm)
        loaded,
    required TResult Function(String message) error,
  }) {
    return error(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(
            List<SubscriptionEntity> allSubscriptions,
            List<SubscriptionEntity> filteredSubscriptions,
            SortOption? currentSortOption,
            List<SubscriptionCategory>? filterCategories,
            List<BillingCycle>? filterBillingCycles,
            String? searchTerm)?
        loaded,
    TResult? Function(String message)? error,
  }) {
    return error?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            List<SubscriptionEntity> allSubscriptions,
            List<SubscriptionEntity> filteredSubscriptions,
            SortOption? currentSortOption,
            List<SubscriptionCategory>? filterCategories,
            List<BillingCycle>? filterBillingCycles,
            String? searchTerm)?
        loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _Error implements SubscriptionState {
  const factory _Error({required final String message}) = _$ErrorImpl;

  String get message;

  /// Create a copy of SubscriptionState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}


===== FILE: subscription_state.dart =====
===== PATH: lib/features/subscriptions/presentation/cubit/subscription_state.dart =====

// lib/features/subscriptions/presentation/cubit/subscription_state.dart
part of 'subscription_cubit.dart';

@freezed
class SubscriptionState with _$SubscriptionState {
  const factory SubscriptionState.initial() = _Initial;
  const factory SubscriptionState.loading() = _Loading;
  const factory SubscriptionState.loaded({
    required List<SubscriptionEntity> allSubscriptions,
    required List<SubscriptionEntity> filteredSubscriptions,
    SortOption? currentSortOption,
    List<SubscriptionCategory>? filterCategories,
    List<BillingCycle>? filterBillingCycles, // NEU: Liste für Zyklen
    String? searchTerm,
  }) = _Loaded;
  const factory SubscriptionState.error({required String message}) = _Error;
}

enum SortOption {
  nameAsc,
  nameDesc,
  priceAsc,
  priceDesc,
  nextBillingDateAsc,
  nextBillingDateDesc,
  category
}

extension SortOptionDisplay on SortOption {
  String get displayName {
    switch (this) {
      case SortOption.nameAsc:
        return 'Name (A-Z)';
      case SortOption.nameDesc:
        return 'Name (Z-A)';
      case SortOption.priceAsc:
        return 'Price (Low-High)';
      case SortOption.priceDesc:
        return 'Price (High-Low)';
      case SortOption.nextBillingDateAsc:
        return 'Next Billing Date';
      case SortOption.nextBillingDateDesc:
        return 'Next Billing Date (Desc)';
      case SortOption.category:
        return 'Category';
    }
  }
}


===== FILE: add_edit_subscription_screen.dart =====
===== PATH: lib/features/subscriptions/presentation/screens/add_edit_subscription_screen.dart =====

import 'package:aboapp/core/utils/currency_formatter.dart';
import 'package:aboapp/features/settings/presentation/cubit/settings_cubit.dart';
import 'package:aboapp/features/subscriptions/presentation/widgets/subscription_card_widget.dart';
import 'package:aboapp/widgets/animated_gradient_chip.dart';
import 'package:aboapp/widgets/animated_gradient_input_border.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:intl/intl.dart';
import 'package:aboapp/features/subscriptions/domain/entities/subscription_entity.dart';
import 'package:aboapp/features/subscriptions/presentation/cubit/subscription_cubit.dart';

class AddEditSubscriptionScreen extends StatefulWidget {
  final SubscriptionEntity? initialSubscription;
  const AddEditSubscriptionScreen({super.key, this.initialSubscription});

  @override
  State<AddEditSubscriptionScreen> createState() =>
      _AddEditSubscriptionScreenState();
}

class _AddEditSubscriptionScreenState extends State<AddEditSubscriptionScreen>
    with SingleTickerProviderStateMixin {
  final _nameController = TextEditingController();
  final _priceController = TextEditingController();
  final _notesController = TextEditingController();
  late final AnimationController _animationController;
  late SubscriptionCategory _selectedCategory;
  late BillingCycle _selectedCycle;
  late DateTime _nextBillingDate;
  bool get _isEditing => widget.initialSubscription != null;

  @override
  void initState() {
    super.initState();
    _animationController = AnimationController(
      vsync: this,
      duration: const Duration(seconds: 4),
    )..repeat();

    if (_isEditing) {
      final s = widget.initialSubscription!;
      _nameController.text = s.name;
      _priceController.text = s.price.toString().replaceAll('.', ',');
      _notesController.text = s.notes ?? '';
      _selectedCategory = s.category;
      _selectedCycle = s.billingCycle;
      _nextBillingDate = s.nextBillingDate;
    } else {
      _selectedCategory = SubscriptionCategory.other;
      _selectedCycle = BillingCycle.monthly;
      _nextBillingDate = DateTime.now().add(const Duration(days: 30));
    }
  }

  @override
  void dispose() {
    _nameController.dispose();
    _priceController.dispose();
    _notesController.dispose();
    _animationController.dispose();
    super.dispose();
  }

  Future<void> _pickNextBillingDate(Locale locale) async {
    final picked = await showDatePicker(
      context: context,
      locale: locale,
      initialDate: _nextBillingDate,
      firstDate: DateTime.now().subtract(const Duration(days: 365 * 5)),
      lastDate: DateTime.now().add(const Duration(days: 365 * 10)),
    );
    if (picked != null) setState(() => _nextBillingDate = picked);
  }

  void _save() {
    if (!_formKey.currentState!.validate()) {
      return;
    }
    final price =
        double.parse(_priceController.text.trim().replaceAll(',', '.'));
    final sub = SubscriptionEntity(
      id: widget.initialSubscription?.id ?? '',
      name: _nameController.text.trim(),
      price: price,
      category: _selectedCategory,
      billingCycle: _selectedCycle,
      nextBillingDate: _nextBillingDate,
      notes: _notesController.text.trim().isEmpty
          ? null
          : _notesController.text.trim(),
    );
    final cubit = context.read<SubscriptionCubit>();
    _isEditing ? cubit.updateSubscription(sub) : cubit.addSubscription(sub);
    Navigator.of(context).pop();
  }

  final _formKey = GlobalKey<FormState>();

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final settingsState = context.watch<SettingsCubit>().state;
    final currencySymbol =
        CurrencyFormatter.getCurrencySymbol(settingsState.currencyCode);

    final defaultBorder = OutlineInputBorder(
      borderRadius: BorderRadius.circular(12.0),
      borderSide: BorderSide.none,
    );

    // KORREKTUR: Farbverlauf für weichere Übergänge angepasst
    final focusedBorder = AnimatedGradientInputBorder(
      animation: _animationController,
      gradientColors: [
        Colors.pink.shade200,
        Colors.purple.shade200,
        Colors.blue.shade200,
        Colors.purple.shade200,
        Colors.pink.shade200,
      ],
    );
    final errorBorder = AnimatedGradientInputBorder(
      animation: _animationController,
      gradientColors: [
        theme.colorScheme.error.withAlpha(180),
        Colors.orange.shade400.withAlpha(180),
      ],
    );

    return Scaffold(
      appBar: AppBar(
        title: Text(_isEditing ? 'Abo bearbeiten' : 'Abo hinzufügen'),
      ),
      body: Padding(
        padding: const EdgeInsets.all(16),
        child: Form(
          key: _formKey,
          child: ListView(
            children: [
              _buildSectionTitle(theme, 'Kategorie'),
              _buildCategorySelector(theme),
              const SizedBox(height: 24),
              _buildSectionTitle(theme, 'Abo-Name'),
              AnimatedBuilder(
                animation: _animationController,
                builder: (context, child) => TextFormField(
                  controller: _nameController,
                  decoration: _inputDecoration(
                    theme: theme,
                    icon: Icons.subscriptions_outlined,
                    hintText: 'z.B. Netflix, Spotify...',
                    defaultBorder: defaultBorder,
                    focusedBorder: focusedBorder,
                    errorBorder: errorBorder,
                  ),
                  validator: (v) =>
                      v == null || v.trim().isEmpty ? 'Pflichtfeld' : null,
                ),
              ),
              const SizedBox(height: 16),
              _buildSectionTitle(theme, 'Preis ($currencySymbol)'),
              AnimatedBuilder(
                animation: _animationController,
                builder: (context, child) => TextFormField(
                  controller: _priceController,
                  decoration: _inputDecoration(
                    theme: theme,
                    icon: Icons.price_change_outlined,
                    hintText: '0,00',
                    defaultBorder: defaultBorder,
                    focusedBorder: focusedBorder,
                    errorBorder: errorBorder,
                  ),
                  keyboardType:
                      const TextInputType.numberWithOptions(decimal: true),
                  inputFormatters: [
                    FilteringTextInputFormatter.allow(RegExp(r'[\d,.]'))
                  ],
                  validator: (v) {
                    if (v == null || v.trim().isEmpty) return 'Pflichtfeld';
                    if (double.tryParse(v.trim().replaceAll(',', '.')) == null)
                      return 'Ungültiger Betrag';
                    return null;
                  },
                ),
              ),
              const SizedBox(height: 16),
              Row(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        _buildSectionTitle(theme, 'Intervall'),
                        AnimatedBuilder(
                          animation: _animationController,
                          builder: (context, child) =>
                              DropdownButtonFormField<BillingCycle>(
                            value: _selectedCycle,
                            decoration: _inputDecoration(
                              theme: theme,
                              icon: Icons.calendar_view_month,
                              defaultBorder: defaultBorder,
                              focusedBorder: focusedBorder,
                            ),
                            items: BillingCycle.values
                                .where((c) => c != BillingCycle.custom)
                                .map((c) => DropdownMenuItem(
                                    value: c, child: Text(c.displayName)))
                                .toList(),
                            onChanged: (v) => setState(
                                () => _selectedCycle = v ?? _selectedCycle),
                          ),
                        ),
                      ],
                    ),
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        _buildSectionTitle(theme, 'Nächste Zahlung'),
                        InkWell(
                          onTap: () =>
                              _pickNextBillingDate(settingsState.locale),
                          child: InputDecorator(
                            decoration: _inputDecoration(
                              theme: theme,
                              icon: Icons.event,
                              defaultBorder: defaultBorder,
                            ),
                            child: Padding(
                              padding: const EdgeInsets.only(
                                  top:
                                      1.0), // Kleine Anpassung für vertikale Zentrierung
                              child: Text(
                                DateFormat.yMd(
                                        settingsState.locale.toLanguageTag())
                                    .format(_nextBillingDate),
                                style: theme.textTheme.bodyLarge,
                              ),
                            ),
                          ),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 16),
              _buildSectionTitle(theme, 'Notizen (optional)'),
              AnimatedBuilder(
                animation: _animationController,
                builder: (context, child) => TextFormField(
                  controller: _notesController,
                  decoration: _inputDecoration(
                    theme: theme,
                    icon: Icons.note_alt_outlined,
                    hintText: 'Zusätzliche Infos...',
                    defaultBorder: defaultBorder,
                    focusedBorder: focusedBorder,
                  ),
                  maxLines: 3,
                ),
              ),
              const SizedBox(height: 24),
              SizedBox(
                width: double.infinity,
                child: ElevatedButton.icon(
                  icon: const Icon(Icons.save),
                  label: Text(_isEditing ? 'Aktualisieren' : 'Speichern'),
                  style: ElevatedButton.styleFrom(
                    padding: const EdgeInsets.symmetric(vertical: 18),
                    shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(12)),
                  ),
                  onPressed: _save,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  // KORREKTUR: Hilfsmethode für das getrennte Label
  Widget _buildSectionTitle(ThemeData theme, String title) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8.0, left: 4.0),
      child: Text(
        title,
        style:
            theme.textTheme.titleSmall?.copyWith(fontWeight: FontWeight.bold),
      ),
    );
  }

  // KORREKTUR: InputDecoration verwendet jetzt 'hintText' statt 'labelText'
  InputDecoration _inputDecoration({
    required ThemeData theme,
    required IconData icon,
    String? hintText,
    required InputBorder defaultBorder,
    InputBorder? focusedBorder,
    InputBorder? errorBorder,
  }) {
    return InputDecoration(
      hintText: hintText,
      prefixIcon: Icon(icon, color: theme.colorScheme.onSurfaceVariant),
      filled: true,
      fillColor: theme.colorScheme.surface,
      border: defaultBorder,
      enabledBorder: defaultBorder,
      focusedBorder: focusedBorder,
      errorBorder: errorBorder,
      focusedErrorBorder: errorBorder,
      contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 16),
    );
  }

  Widget _buildCategorySelector(ThemeData theme) {
    return Wrap(
      spacing: 10.0,
      runSpacing: 10.0,
      children: SubscriptionCategory.values.map((cat) {
        return AnimatedGradientChip(
          label: cat.displayName,
          icon: cat.displayIcon,
          isSelected: _selectedCategory == cat,
          selectedColor: cat.categoryDisplayIconColor(theme),
          onSelected: (_) => setState(() => _selectedCategory = cat),
        );
      }).toList(),
    );
  }
}

extension on BillingCycle {
  String get displayName {
    switch (this) {
      case BillingCycle.weekly:
        return 'Wöchentlich';
      case BillingCycle.monthly:
        return 'Monatlich';
      case BillingCycle.quarterly:
        return 'Quartalsweise';
      case BillingCycle.biAnnual:
        return 'Halbjährlich';
      case BillingCycle.yearly:
        return 'Jährlich';
      case BillingCycle.custom:
        return 'Benutzerdef.';
    }
  }
}


===== FILE: home_screen.dart =====
===== PATH: lib/features/subscriptions/presentation/screens/home_screen.dart =====

// lib/features/subscriptions/presentation/screens/home_screen.dart

import 'package:aboapp/core/routing/app_router.dart';
import 'package:aboapp/features/subscriptions/domain/entities/subscription_entity.dart';
import 'package:aboapp/features/subscriptions/presentation/cubit/subscription_cubit.dart';
import 'package:aboapp/features/subscriptions/presentation/widgets/filter_bottom_sheet.dart';
import 'package:aboapp/features/subscriptions/presentation/widgets/monthly_spending_summary_card.dart';
import 'package:aboapp/features/subscriptions/presentation/widgets/subscription_card_widget.dart';
import 'package:aboapp/widgets/empty_state_widget.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:go_router/go_router.dart';
import 'package:shimmer/shimmer.dart';
import 'package:aboapp/core/utils/haptic_feedback.dart' as app_haptics;

class HomeScreen extends StatefulWidget {
  const HomeScreen({super.key});

  @override
  State<HomeScreen> createState() => _HomeScreenState();
}

// ZURÜCKGESETZT: AnimationController und TickerProvider entfernt
class _HomeScreenState extends State<HomeScreen> {
  final _searchController = TextEditingController();
  final _searchFocusNode = FocusNode();
  bool _isSearching = false;

  @override
  void dispose() {
    _searchController.dispose();
    _searchFocusNode.dispose();
    super.dispose();
  }

  void _toggleSearch(BuildContext context) {
    setState(() {
      _isSearching = !_isSearching;
      if (!_isSearching) {
        _searchController.clear();
        _searchFocusNode.unfocus();
        context.read<SubscriptionCubit>().clearSearch();
      } else {
        _searchFocusNode.requestFocus();
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Scaffold(
      body: BlocBuilder<SubscriptionCubit, SubscriptionState>(
        builder: (context, state) {
          return state.when(
            initial: () =>
                const Center(child: CircularProgressIndicator.adaptive()),
            loading: () => _buildLoadingShimmer(theme),
            loaded: (allSubs, filteredSubs, sortOption, filterCats, filterBills,
                searchTerm) {
              final activeSubscriptions =
                  allSubs.where((s) => s.isActive).toList();
              final bool filtersAreActive = (filterCats?.isNotEmpty ?? false) ||
                  (filterBills?.isNotEmpty ?? false);

              return RefreshIndicator(
                onRefresh: () async {
                  app_haptics.HapticFeedback.mediumImpact();
                  await context.read<SubscriptionCubit>().loadSubscriptions();
                },
                child: CustomScrollView(
                  physics: const BouncingScrollPhysics(
                      parent: AlwaysScrollableScrollPhysics()),
                  slivers: [
                    SliverAppBar(
                      title: AnimatedSwitcher(
                        duration: const Duration(milliseconds: 200),
                        child: _isSearching
                            ? TextField(
                                controller: _searchController,
                                focusNode: _searchFocusNode,
                                autofocus: true,
                                decoration: InputDecoration(
                                    hintText: 'Search subscriptions...',
                                    border: InputBorder.none,
                                    isDense: true,
                                    hintStyle: theme.appBarTheme.titleTextStyle
                                        ?.copyWith(
                                            fontWeight: FontWeight.normal,
                                            color: theme.colorScheme.onSurface
                                                .withAlpha(150))),
                                style: theme.appBarTheme.titleTextStyle,
                                onChanged: (query) => context
                                    .read<SubscriptionCubit>()
                                    .searchSubscriptions(query),
                              )
                            : const Text('My Subscriptions'),
                      ),
                      actions: [
                        if (!_isSearching)
                          IconButton(
                            icon: const Icon(Icons.filter_list_rounded),
                            onPressed: () {
                              showModalBottomSheet(
                                context: context,
                                isScrollControlled: true,
                                backgroundColor: Colors.transparent,
                                builder: (_) {
                                  return BlocProvider.value(
                                    value: BlocProvider.of<SubscriptionCubit>(
                                        context),
                                    child: FilterBottomSheet(
                                      currentSortOption: sortOption ??
                                          SortOption.nextBillingDateAsc,
                                      currentCategories: filterCats ?? [],
                                      currentBillingCycles: filterBills ?? [],
                                    ),
                                  );
                                },
                              );
                            },
                            tooltip: 'Filter & Sort',
                          ),
                        IconButton(
                          icon: Icon(_isSearching
                              ? Icons.close_rounded
                              : Icons.search_rounded),
                          onPressed: () => _toggleSearch(context),
                          tooltip: _isSearching ? 'Close Search' : 'Search',
                        ),
                      ],
                      floating: true,
                      snap: true,
                      backgroundColor: theme.scaffoldBackgroundColor,
                      elevation: 0,
                    ),
                    // ZURÜCKGESETZT: CustomPaint und Padding entfernt
                    if (!_isSearching)
                      SliverToBoxAdapter(
                        child: MonthlySpendingSummaryCard(
                          activeSubscriptions: activeSubscriptions,
                        ),
                      ),
                    if (filtersAreActive)
                      SliverToBoxAdapter(
                        child: _buildActiveFiltersBar(context, theme,
                            filterCats ?? [], filterBills ?? []),
                      ),
                    if (filteredSubs.isEmpty)
                      SliverFillRemaining(
                        hasScrollBody: false,
                        child: Center(
                          child: EmptyStateWidget(
                            icon: Icons.search_off_rounded,
                            title: 'No Subscriptions Found',
                            message: 'Try adjusting your search or filters.',
                            onRetry: () => context
                                .read<SubscriptionCubit>()
                                .clearAllFilters(),
                            retryText: 'Clear Filters',
                          ),
                        ),
                      )
                    else
                      SliverPadding(
                        padding: const EdgeInsets.only(bottom: 80.0),
                        sliver: SliverList(
                          delegate: SliverChildBuilderDelegate(
                            (context, index) {
                              final subscription = filteredSubs[index];
                              return SubscriptionCardWidget(
                                subscription: subscription,
                                onTap: () => context.pushNamed(
                                    AppRoutes.editSubscription,
                                    pathParameters: {'id': subscription.id},
                                    extra: subscription),
                                onLongPress: () => _showSubscriptionActions(
                                    context, theme, subscription),
                              );
                            },
                            childCount: filteredSubs.length,
                          ),
                        ),
                      ),
                  ],
                ),
              );
            },
            error: (message) => Center(
              child: EmptyStateWidget(
                icon: Icons.error_outline_rounded,
                title: 'Error',
                message: message,
                onRetry: () =>
                    context.read<SubscriptionCubit>().loadSubscriptions(),
                retryText: 'Retry',
              ),
            ),
          );
        },
      ),
    );
  }

  Widget _buildActiveFiltersBar(BuildContext context, ThemeData theme,
      List<SubscriptionCategory> cats, List<BillingCycle> bills) {
    List<Widget> chips = [];

    for (var cat in cats) {
      chips.add(Chip(
        label: Text(cat.displayName),
        onDeleted: () {
          context.read<SubscriptionCubit>().toggleCategoryFilter(cat);
        },
        deleteIconColor: theme.colorScheme.onSecondaryContainer,
        backgroundColor: theme.colorScheme.secondaryContainer,
        labelStyle: TextStyle(color: theme.colorScheme.onSecondaryContainer),
      ));
    }

    for (var bill in bills) {
      chips.add(Chip(
        label: Text(bill.name[0].toUpperCase() + bill.name.substring(1)),
        onDeleted: () {
          context.read<SubscriptionCubit>().toggleBillingCycleFilter(bill);
        },
        deleteIconColor: theme.colorScheme.onSecondaryContainer,
        backgroundColor: theme.colorScheme.secondaryContainer,
        labelStyle: TextStyle(color: theme.colorScheme.onSecondaryContainer),
      ));
    }

    return Padding(
      padding: const EdgeInsets.fromLTRB(16.0, 8.0, 16.0, 0),
      child: Wrap(
        spacing: 8.0,
        runSpacing: 8.0,
        children: chips,
      ),
    );
  }

  Widget _buildLoadingShimmer(ThemeData theme) {
    return Shimmer.fromColors(
      baseColor: theme.colorScheme.surfaceContainerHighest.withAlpha(100),
      highlightColor: theme.colorScheme.surfaceContainerHighest.withAlpha(50),
      child: ListView(
        padding: const EdgeInsets.all(16.0),
        children: [
          Container(
            height: 150.0,
            decoration: BoxDecoration(
              color: theme.cardColor,
              borderRadius: BorderRadius.circular(20.0),
            ),
            margin: const EdgeInsets.only(bottom: 16),
          ),
          Container(
              height: 40,
              color: theme.cardColor,
              margin: const EdgeInsets.only(bottom: 16)),
          ...List.generate(
              5,
              (index) => Container(
                    height: 90.0,
                    decoration: BoxDecoration(
                      color: theme.cardColor,
                      borderRadius: BorderRadius.circular(12.0),
                    ),
                    margin: const EdgeInsets.only(bottom: 10.0),
                  )),
        ],
      ),
    );
  }

  void _showSubscriptionActions(
      BuildContext context, ThemeData theme, SubscriptionEntity subscription) {
    app_haptics.HapticFeedback.mediumImpact();
    showModalBottomSheet(
      context: context,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(16.0)),
      ),
      builder: (builderContext) {
        return Wrap(
          children: <Widget>[
            ListTile(
              leading: const Icon(Icons.edit_rounded),
              title: const Text('Edit Subscription'),
              onTap: () {
                Navigator.pop(builderContext);
                context.pushNamed(
                  AppRoutes.editSubscription,
                  pathParameters: {'id': subscription.id},
                  extra: subscription,
                );
              },
            ),
            ListTile(
              leading: Icon(subscription.isActive
                  ? Icons.pause_circle_outline_rounded
                  : Icons.play_circle_outline_rounded),
              title: Text(subscription.isActive
                  ? 'Pause Subscription'
                  : 'Resume Subscription'),
              onTap: () {
                Navigator.pop(builderContext);
                context
                    .read<SubscriptionCubit>()
                    .toggleSubscriptionActiveStatus(subscription.id);
              },
            ),
            ListTile(
              leading: Icon(subscription.notificationsEnabled
                  ? Icons.notifications_off_rounded
                  : Icons.notifications_active_rounded),
              title: Text(subscription.notificationsEnabled
                  ? 'Disable Notifications'
                  : 'Enable Notifications'),
              onTap: () {
                Navigator.pop(builderContext);
                context
                    .read<SubscriptionCubit>()
                    .toggleSubscriptionNotification(subscription.id);
              },
            ),
            ListTile(
              leading: Icon(Icons.delete_forever_rounded,
                  color: theme.colorScheme.error),
              title: Text('Delete Subscription',
                  style: TextStyle(color: theme.colorScheme.error)),
              onTap: () async {
                Navigator.pop(builderContext);
                final confirmDelete = await showDialog<bool>(
                  context: context,
                  builder: (dialogContext) => AlertDialog(
                    title: const Text('Confirm Delete'),
                    content: Text(
                        'Are you sure you want to delete "${subscription.name}"? This cannot be undone.'),
                    actions: <Widget>[
                      TextButton(
                        child: const Text('Cancel'),
                        onPressed: () => Navigator.of(dialogContext).pop(false),
                      ),
                      TextButton(
                        child: Text('Delete',
                            style: TextStyle(color: theme.colorScheme.error)),
                        onPressed: () => Navigator.of(dialogContext).pop(true),
                      ),
                    ],
                  ),
                );
                if (confirmDelete == true && mounted) {
                  context
                      .read<SubscriptionCubit>()
                      .deleteSubscription(subscription.id);
                }
              },
            ),
          ],
        );
      },
    );
  }
}


===== FILE: filter_bottom_sheet.dart =====
===== PATH: lib/features/subscriptions/presentation/widgets/filter_bottom_sheet.dart =====

// lib/features/subscriptions/presentation/widgets/filter_bottom_sheet.dart
import 'package:aboapp/core/utils/haptic_feedback.dart' as app_haptics;
import 'package:aboapp/features/subscriptions/domain/entities/subscription_entity.dart';
import 'package:aboapp/features/subscriptions/presentation/cubit/subscription_cubit.dart';
// Import für die .displayName Erweiterung auf SubscriptionCategory
import 'package:aboapp/features/subscriptions/presentation/widgets/subscription_card_widget.dart';
// Import für den GradientOutlinePainter
import 'package:aboapp/widgets/animated_gradient_chip.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

class FilterBottomSheet extends StatefulWidget {
  final SortOption currentSortOption;
  final List<SubscriptionCategory> currentCategories;
  final List<BillingCycle> currentBillingCycles;

  const FilterBottomSheet({
    super.key,
    required this.currentSortOption,
    required this.currentCategories,
    required this.currentBillingCycles,
  });

  @override
  State<FilterBottomSheet> createState() => _FilterBottomSheetState();
}

class _FilterBottomSheetState extends State<FilterBottomSheet>
    with SingleTickerProviderStateMixin {
  late SortOption _selectedSortOption;
  late List<SubscriptionCategory> _selectedCategories;
  late List<BillingCycle> _selectedBillingCycles;
  late final AnimationController _animationController;

  @override
  void initState() {
    super.initState();
    _selectedSortOption = widget.currentSortOption;
    _selectedCategories = List.from(widget.currentCategories);
    _selectedBillingCycles = List.from(widget.currentBillingCycles);

    _animationController = AnimationController(
      vsync: this,
      duration: const Duration(seconds: 4),
    )..repeat();
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }

  void _applyFiltersAndClose() {
    final cubit = context.read<SubscriptionCubit>();
    cubit.changeSortOption(_selectedSortOption);
    cubit.setCategoryFilters(_selectedCategories);
    cubit.setBillingCycleFilters(_selectedBillingCycles);
    Navigator.pop(context);
  }

  void _resetFilters() {
    app_haptics.HapticFeedback.lightImpact();
    setState(() {
      _selectedSortOption = SortOption.nextBillingDateAsc;
      _selectedCategories.clear();
      _selectedBillingCycles.clear();
    });
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Container(
      padding: const EdgeInsets.all(24.0),
      decoration: BoxDecoration(
        color: theme.cardColor,
        borderRadius: const BorderRadius.vertical(top: Radius.circular(24)),
      ),
      child: SafeArea(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text("Sort & Filter", style: theme.textTheme.headlineSmall),
                TextButton(
                  onPressed: _resetFilters,
                  child: const Text("Reset"),
                ),
              ],
            ),
            const SizedBox(height: 24),
            Text("SORT BY",
                style: theme.textTheme.labelMedium
                    ?.copyWith(color: theme.colorScheme.onSurfaceVariant)),
            const SizedBox(height: 8),
            _buildSortDropdown(theme),
            const SizedBox(height: 24),
            Text("CATEGORIES",
                style: theme.textTheme.labelMedium
                    ?.copyWith(color: theme.colorScheme.onSurfaceVariant)),
            const SizedBox(height: 8),
            _buildMultiSelectChipGroup<SubscriptionCategory>(
              allItems: SubscriptionCategory.values,
              selectedItems: _selectedCategories,
              onTap: (item) {
                app_haptics.HapticFeedback.selectionClick();
                setState(() {
                  if (_selectedCategories.contains(item)) {
                    _selectedCategories.remove(item);
                  } else {
                    _selectedCategories.add(item);
                  }
                });
              },
              getLabel: (item) => item.displayName,
            ),
            const SizedBox(height: 24),
            Text("BILLING CYCLES",
                style: theme.textTheme.labelMedium
                    ?.copyWith(color: theme.colorScheme.onSurfaceVariant)),
            const SizedBox(height: 8),
            _buildMultiSelectChipGroup<BillingCycle>(
              allItems: BillingCycle.values
                  .where((c) => c != BillingCycle.custom)
                  .toList(),
              selectedItems: _selectedBillingCycles,
              onTap: (item) {
                app_haptics.HapticFeedback.selectionClick();
                setState(() {
                  if (_selectedBillingCycles.contains(item)) {
                    _selectedBillingCycles.remove(item);
                  } else {
                    _selectedBillingCycles.add(item);
                  }
                });
              },
              getLabel: (item) =>
                  item.name[0].toUpperCase() + item.name.substring(1),
            ),
            const SizedBox(height: 32),
            ElevatedButton(
              onPressed: _applyFiltersAndClose,
              style: ElevatedButton.styleFrom(
                minimumSize: const Size(double.infinity, 50),
                backgroundColor: theme.colorScheme.primary,
                foregroundColor: theme.colorScheme.onPrimary,
              ),
              child: const Text("Apply Filters"),
            ),
            const SizedBox(height: 8),
          ],
        ),
      ),
    );
  }

  // HIER IST DIE ÄNDERUNG FÜR DAS DROPDOWN
  Widget _buildSortDropdown(ThemeData theme) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 4.0),
      decoration: BoxDecoration(
          color: theme.colorScheme.surface,
          borderRadius: BorderRadius.circular(12.0),
          border: Border.all(color: theme.colorScheme.outline)),
      child: DropdownButtonHideUnderline(
        child: DropdownButton<SortOption>(
          value: _selectedSortOption,
          isExpanded: true,
          icon: const Icon(Icons.unfold_more_rounded),
          // --- STYLING FÜR DAS AUFGEKLAPPTE MENÜ ---
          borderRadius: BorderRadius.circular(12.0),
          dropdownColor: theme.cardColor,
          elevation: 4,
          // --- ENDE STYLING ---
          onChanged: (newValue) {
            if (newValue != null) {
              setState(() {
                _selectedSortOption = newValue;
              });
            }
          },
          items: SortOption.values.map((option) {
            return DropdownMenuItem<SortOption>(
              value: option,
              child: Padding(
                // Etwas mehr vertikaler Platz für jedes Element
                padding: const EdgeInsets.symmetric(vertical: 4.0),
                child: Text(option.displayName),
              ),
            );
          }).toList(),
        ),
      ),
    );
  }

  Widget _buildMultiSelectChipGroup<T>({
    required List<T> allItems,
    required List<T> selectedItems,
    required Function(T) onTap,
    required String Function(T) getLabel,
  }) {
    return Wrap(
      spacing: 10.0,
      runSpacing: 10.0,
      children: allItems.map((item) {
        final isSelected = selectedItems.contains(item);
        return CustomGradientFilterChip(
          label: getLabel(item),
          isSelected: isSelected,
          onTap: () => onTap(item),
          animation: _animationController,
        );
      }).toList(),
    );
  }
}

class CustomGradientFilterChip extends StatelessWidget {
  final String label;
  final bool isSelected;
  final VoidCallback onTap;
  final Animation<double> animation;

  const CustomGradientFilterChip({
    super.key,
    required this.label,
    required this.isSelected,
    required this.onTap,
    required this.animation,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final gradientColors = [
      Colors.pink.shade200,
      Colors.purple.shade300,
      Colors.blue.shade300,
      Colors.pink.shade200, // Schließt den Farbkreis
    ];

    return CustomPaint(
      foregroundPainter: isSelected
          ? GradientOutlinePainter(
              animation: animation,
              strokeWidth: 2.0,
              radius: 50.0,
              gradientColors: gradientColors,
            )
          : null,
      child: Material(
        color: Colors.transparent,
        shape: const StadiumBorder(),
        child: InkWell(
          onTap: onTap,
          customBorder: const StadiumBorder(),
          child: AnimatedContainer(
            duration: const Duration(milliseconds: 200),
            padding:
                const EdgeInsets.symmetric(horizontal: 16.0, vertical: 10.0),
            decoration: BoxDecoration(
              color: isSelected
                  ? theme.colorScheme.primary.withOpacity(0.1)
                  : Colors.transparent,
              borderRadius: BorderRadius.circular(50.0),
              border: isSelected ? null : Border.all(color: theme.dividerColor),
            ),
            child: Text(
              label,
              style: theme.textTheme.labelLarge?.copyWith(
                fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
                color: isSelected
                    ? theme.colorScheme.primary
                    : theme.colorScheme.onSurfaceVariant,
              ),
            ),
          ),
        ),
      ),
    );
  }
}


===== FILE: monthly_spending_summary_card.dart =====
===== PATH: lib/features/subscriptions/presentation/widgets/monthly_spending_summary_card.dart =====

// lib/features/subscriptions/presentation/widgets/monthly_spending_summary_card.dart

import 'package:aboapp/features/settings/presentation/cubit/settings_cubit.dart';
import 'package:aboapp/features/subscriptions/domain/entities/subscription_entity.dart';
import 'package:aboapp/widgets/animated_counter_widget.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:intl/intl.dart';

class MonthlySpendingSummaryCard extends StatelessWidget {
  final List<SubscriptionEntity> activeSubscriptions;

  const MonthlySpendingSummaryCard({
    super.key,
    required this.activeSubscriptions,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final settingsState = context.watch<SettingsCubit>().state;

    // Dynamically format currency based on user settings
    final currencyFormat = NumberFormat.currency(
      locale: settingsState.locale.toLanguageTag(),
      symbol: NumberFormat.simpleCurrency(
              locale: settingsState.locale.toLanguageTag())
          .currencySymbol,
      decimalDigits: 2,
    );

    final double totalMonthlySpending = activeSubscriptions.fold(
      0.0,
      (sum, sub) => sum + sub.monthlyEquivalentPrice,
    );

    final double yearlySpending = totalMonthlySpending * 12;

    return Card(
      // The card's appearance is now mainly controlled by the global ModernTheme/ClassicTheme
      // This makes it consistent across the app.
      margin: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
      elevation: theme.cardTheme.elevation,
      shape: theme.cardTheme.shape,
      color: theme.cardTheme.color,
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 24.0, vertical: 20.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Row for Title and Active Count
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  'Monthly Spending', // TODO: Localize
                  style: theme.textTheme.titleMedium?.copyWith(
                    color: theme.colorScheme.onSurfaceVariant,
                  ),
                ),
                Container(
                  padding:
                      const EdgeInsets.symmetric(horizontal: 10, vertical: 4),
                  decoration: BoxDecoration(
                    color: theme.colorScheme.primary.withOpacity(0.1),
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: Text(
                    '${activeSubscriptions.length} Active', // TODO: Localize
                    style: theme.textTheme.labelMedium?.copyWith(
                      color: theme.colorScheme.primary,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
              ],
            ),
            const SizedBox(height: 8.0),

            // Main spending amount (the "Hero" element)
            AnimatedCounterWidget(
              value: totalMonthlySpending,
              formatter: (value) => currencyFormat.format(value),
              style: theme.textTheme.displayMedium!.copyWith(
                color: theme.colorScheme.onSurface,
                fontWeight: FontWeight.bold,
              ),
              duration: const Duration(milliseconds: 700),
            ),
            const SizedBox(height: 16.0),

            // Divider
            Divider(
              color: theme.dividerColor.withOpacity(0.5),
              height: 1,
            ),
            const SizedBox(height: 16.0),

            // Secondary info (Yearly Total)
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  'Yearly Total', // TODO: Localize
                  style: theme.textTheme.bodyMedium?.copyWith(
                    color: theme.colorScheme.onSurfaceVariant,
                  ),
                ),
                AnimatedCounterWidget(
                  value: yearlySpending,
                  formatter: (val) => currencyFormat.format(val),
                  style: theme.textTheme.bodyLarge!.copyWith(
                    fontWeight: FontWeight.w600,
                    color: theme.colorScheme.onSurface,
                  ),
                  duration: const Duration(milliseconds: 600),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}


===== FILE: subscription_card_widget.dart =====
===== PATH: lib/features/subscriptions/presentation/widgets/subscription_card_widget.dart =====

// lib/features/subscriptions/presentation/widgets/subscription_card_widget.dart

import 'package:aboapp/core/theme/app_colors.dart';
import 'package:aboapp/core/utils/currency_formatter.dart';
import 'package:aboapp/core/utils/date_formatter.dart';
import 'package:aboapp/features/settings/presentation/cubit/settings_cubit.dart';
import 'package:aboapp/features/subscriptions/domain/entities/subscription_entity.dart';
import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

class SubscriptionCardWidget extends StatelessWidget {
  final SubscriptionEntity subscription;
  final VoidCallback? onTap;
  final VoidCallback? onLongPress;

  const SubscriptionCardWidget({
    super.key,
    required this.subscription,
    this.onTap,
    this.onLongPress,
  });

  String _getBillingCycleShortLabel(BillingCycle cycle) {
    // TODO: Localize
    switch (cycle) {
      case BillingCycle.weekly:
        return 'wk';
      case BillingCycle.monthly:
        return 'mo';
      case BillingCycle.quarterly:
        return 'qtr';
      case BillingCycle.biAnnual:
        return '6mo';
      case BillingCycle.yearly:
        return 'yr';
      case BillingCycle.custom:
        return 'cust';
    }
  }

  Color _getDaysUntilBillingColor(BuildContext context, int days) {
    final theme = Theme.of(context);
    if (days < 0) return theme.colorScheme.error;
    if (days <= 3) return theme.colorScheme.error.withAlpha(204); // 80% opacity
    if (days <= 7) return AppColors.warning.withAlpha(230); // 90% opacity
    return theme.colorScheme.onSurfaceVariant;
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final settingsState = context.watch<SettingsCubit>().state;

    final daysUntil = subscription.daysUntilBilling;
    final daysLabel = DateFormatter.formatDaysUntil(
      subscription.nextBillingDate,
      todayText: 'Today',
      tomorrowText: 'Tomorrow',
      daysAgoText: '{days} days ago',
      daysFutureText: 'in {days} days',
    );

    return AnimatedOpacity(
      duration: const Duration(milliseconds: 300),
      opacity: subscription.isActive ? 1.0 : 0.7,
      child: Card(
        margin: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
        clipBehavior: Clip.antiAlias,
        child: InkWell(
          onTap: onTap,
          onLongPress: onLongPress,
          child: Padding(
            padding: const EdgeInsets.all(12.0),
            child: Row(
              children: [
                _buildLogo(context, theme),
                const SizedBox(width: 12.0),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        subscription.name,
                        style: theme.textTheme.titleMedium
                            ?.copyWith(fontWeight: FontWeight.w600),
                        maxLines: 1,
                        overflow: TextOverflow.ellipsis,
                      ),
                      const SizedBox(height: 2.0),
                      Text(
                        subscription.category.displayName,
                        style: theme.textTheme.bodySmall?.copyWith(
                          color: theme.colorScheme.onSurfaceVariant,
                        ),
                      ),
                      if (subscription.isInTrial) ...[
                        const SizedBox(height: 4.0),
                        Container(
                          padding: const EdgeInsets.symmetric(
                              horizontal: 6, vertical: 2),
                          decoration: BoxDecoration(
                            color: theme.colorScheme.tertiaryContainer,
                            borderRadius: BorderRadius.circular(6),
                          ),
                          child: Text(
                            'TRIAL',
                            style: theme.textTheme.labelSmall?.copyWith(
                              color: theme.colorScheme.onTertiaryContainer,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                        ),
                      ],
                    ],
                  ),
                ),
                const SizedBox(width: 12.0),
                Column(
                  crossAxisAlignment: CrossAxisAlignment.end,
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Text(
                      '${CurrencyFormatter.format(subscription.price, currencyCode: settingsState.currencyCode, locale: settingsState.locale)} / ${_getBillingCycleShortLabel(subscription.billingCycle)}',
                      style: theme.textTheme.titleSmall?.copyWith(
                        fontWeight: FontWeight.bold,
                        color: theme.colorScheme.primary,
                        decoration: !subscription.isActive
                            ? TextDecoration.lineThrough
                            : TextDecoration.none,
                      ),
                    ),
                    const SizedBox(height: 4.0),
                    Row(
                      children: [
                        Icon(
                          Icons.calendar_today_rounded,
                          size: 12,
                          color: _getDaysUntilBillingColor(context, daysUntil),
                        ),
                        const SizedBox(width: 4),
                        Text(
                          DateFormatter.formatDate(subscription.nextBillingDate,
                              locale: settingsState.locale),
                          style: theme.textTheme.bodySmall?.copyWith(
                            color:
                                _getDaysUntilBillingColor(context, daysUntil),
                            fontWeight: FontWeight.w500,
                          ),
                        ),
                      ],
                    ),
                    Text(
                      daysLabel,
                      style: theme.textTheme.labelSmall?.copyWith(
                        color: _getDaysUntilBillingColor(context, daysUntil),
                        fontStyle: FontStyle.italic,
                      ),
                    ),
                  ],
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildLogo(BuildContext context, ThemeData theme) {
    final hasRemoteLogo =
        subscription.logoUrl != null && subscription.logoUrl!.isNotEmpty;
    final Color bgColor = subscription.color ??
        subscription.category.categoryDisplayIconColor(theme).withAlpha(25);
    final Color fgColor = subscription.color != null
        ? (ThemeData.estimateBrightnessForColor(subscription.color!) ==
                Brightness.dark
            ? Colors.white
            : Colors.black)
        : subscription.category.categoryDisplayIconColor(theme);

    return Stack(
      clipBehavior: Clip.none,
      children: [
        Container(
          width: 52,
          height: 52,
          decoration: BoxDecoration(
            color: bgColor,
            borderRadius: BorderRadius.circular(10.0),
          ),
          child: ClipRRect(
            borderRadius: BorderRadius.circular(10.0),
            child: hasRemoteLogo
                ? CachedNetworkImage(
                    imageUrl: subscription.logoUrl!,
                    width: 52,
                    height: 52,
                    fit: BoxFit.contain,
                    placeholder: (context, url) => Center(
                      child: Icon(
                        subscription.category.displayIcon,
                        color: fgColor.withAlpha(128),
                        size: 28,
                      ),
                    ),
                    errorWidget: (context, url, error) => Center(
                      child: Icon(
                        subscription.category.displayIcon,
                        color: fgColor.withAlpha(178),
                        size: 28,
                      ),
                    ),
                  )
                : Center(
                    child: Text(
                      subscription.name.isNotEmpty
                          ? subscription.name[0].toUpperCase()
                          : '?',
                      style: theme.textTheme.titleLarge?.copyWith(
                          color: fgColor, fontWeight: FontWeight.bold),
                    ),
                  ),
          ),
        ),
        if (!subscription.notificationsEnabled)
          Positioned(
            top: -4,
            right: -4,
            child: Container(
              padding: const EdgeInsets.all(2),
              decoration: BoxDecoration(
                shape: BoxShape.circle,
                color: theme.cardColor.withAlpha(220),
                boxShadow: [
                  BoxShadow(
                    color: Colors.black.withOpacity(0.1),
                    blurRadius: 2,
                    offset: const Offset(0, 1),
                  )
                ],
              ),
              child: Icon(
                Icons.notifications_off_rounded,
                size: 16,
                color: theme.colorScheme.onSurfaceVariant,
              ),
            ),
          ),
      ],
    );
  }
}

extension CategoryDisplayHelpers on SubscriptionCategory {
  Color categoryDisplayIconColor(ThemeData theme) {
    switch (this) {
      case SubscriptionCategory.streaming:
        return AppColors.catStreaming;
      case SubscriptionCategory.software:
        return AppColors.catSoftware;
      case SubscriptionCategory.gaming:
        return AppColors.catGaming;
      case SubscriptionCategory.fitness:
        return AppColors.catFitness;
      case SubscriptionCategory.music:
        return AppColors.catMusic;
      case SubscriptionCategory.news:
        return AppColors.catNews;
      case SubscriptionCategory.cloud:
        return AppColors.catCloud;
      case SubscriptionCategory.utilities:
        return Colors.teal.shade400;
      case SubscriptionCategory.education:
        return Colors.indigo.shade400;
      case SubscriptionCategory.other:
        return AppColors.catOther;
    }
  }

  String get displayName {
    // TODO: Localize these
    switch (this) {
      case SubscriptionCategory.streaming:
        return 'Streaming';
      case SubscriptionCategory.software:
        return 'Software';
      case SubscriptionCategory.gaming:
        return 'Gaming';
      case SubscriptionCategory.fitness:
        return 'Fitness';
      case SubscriptionCategory.music:
        return 'Music';
      case SubscriptionCategory.news:
        return 'News & Mags';
      case SubscriptionCategory.cloud:
        return 'Cloud Storage';
      case SubscriptionCategory.utilities:
        return 'Utilities';
      case SubscriptionCategory.education:
        return 'Education';
      case SubscriptionCategory.other:
        return 'Other';
    }
  }

  IconData get displayIcon {
    switch (this) {
      case SubscriptionCategory.streaming:
        return Icons.live_tv_rounded;
      case SubscriptionCategory.software:
        return Icons.widgets_outlined;
      case SubscriptionCategory.gaming:
        return Icons.gamepad_outlined;
      case SubscriptionCategory.fitness:
        return Icons.fitness_center_rounded;
      case SubscriptionCategory.music:
        return Icons.music_note_rounded;
      case SubscriptionCategory.news:
        return Icons.article_outlined;
      case SubscriptionCategory.cloud:
        return Icons.cloud_outlined;
      case SubscriptionCategory.utilities:
        return Icons.lightbulb_outline_rounded;
      case SubscriptionCategory.education:
        return Icons.school_outlined;
      case SubscriptionCategory.other:
        return Icons.category_rounded;
    }
  }
}


===== FILE: main.dart =====
===== PATH: lib/main.dart =====

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:aboapp/app.dart'; 
import 'package:aboapp/core/di/injection.dart'; 
// import 'package:flutter_bloc/flutter_bloc.dart'; // Unused import

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await configureDependencies();

  await SystemChrome.setPreferredOrientations([
    DeviceOrientation.portraitUp,
    DeviceOrientation.portraitDown,
  ]);

  SystemChrome.setSystemUIOverlayStyle(
    const SystemUiOverlayStyle(
      statusBarColor: Colors.transparent, 
      statusBarIconBrightness: Brightness.dark, 
      systemNavigationBarColor: Colors.transparent, 
      systemNavigationBarIconBrightness: Brightness.dark, 
      systemNavigationBarDividerColor: Colors.transparent,
    ),
  );

  runApp(const AboApp());
}

===== FILE: main_container_screen.dart =====
===== PATH: lib/main_container_screen.dart =====

// lib/main_container_screen.dart

import 'package:aboapp/core/routing/app_router.dart';
import 'package:aboapp/features/settings/presentation/cubit/screens/settings_screen.dart';
import 'package:aboapp/features/settings/presentation/cubit/settings_cubit.dart';
import 'package:aboapp/features/statistics/presentation/cubit/statistics_cubit.dart';
import 'package:aboapp/features/statistics/presentation/screens/statistics_screen.dart';
import 'package:aboapp/features/subscriptions/presentation/cubit/subscription_cubit.dart';
import 'package:aboapp/features/subscriptions/presentation/screens/home_screen.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:go_router/go_router.dart';
import 'package:aboapp/core/utils/haptic_feedback.dart' as app_haptics;

class MainContainerScreen extends StatefulWidget {
  final String location;
  const MainContainerScreen({super.key, required this.location});

  @override
  State<MainContainerScreen> createState() => _MainContainerScreenState();
}

class _MainContainerScreenState extends State<MainContainerScreen> {
  late final PageController _pageController;
  int _currentIndex = 0;

  @override
  void initState() {
    super.initState();
    _currentIndex = _calculatePageIndex(widget.location);
    _pageController = PageController(initialPage: _currentIndex);
  }

  @override
  void didUpdateWidget(covariant MainContainerScreen oldWidget) {
    super.didUpdateWidget(oldWidget);
    final newIndex = _calculatePageIndex(widget.location);
    if (newIndex != _currentIndex) {
      setState(() {
        _currentIndex = newIndex;
      });
      if (_pageController.hasClients &&
          _pageController.page?.round() != newIndex) {
        _pageController.jumpToPage(newIndex);
      }
    }
  }

  @override
  void dispose() {
    _pageController.dispose();
    super.dispose();
  }

  int _calculatePageIndex(String location) {
    if (location.startsWith(AppRoutes.statistics)) return 1;
    if (location.startsWith(AppRoutes.settings)) return 2;
    return 0;
  }

  void _onPageChanged(int index) {
    if (_currentIndex == index) return;
    _updateRoute(index);
  }

  void _updateRoute(int index) {
    setState(() => _currentIndex = index);
    switch (index) {
      case 0:
        context.go(AppRoutes.home);
        break;
      case 1:
        context.go(AppRoutes.statistics);
        break;
      case 2:
        context.go(AppRoutes.settings);
        break;
    }
  }

  void _onBottomNavItemTapped(int index) {
    if (_currentIndex == index) return;
    app_haptics.HapticFeedback.selectionClick();
    _pageController.animateToPage(
      index,
      duration: const Duration(milliseconds: 300),
      curve: Curves.easeInOut,
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: PageView(
        controller: _pageController,
        onPageChanged: _onPageChanged,
        physics: const BouncingScrollPhysics(),
        children: <Widget>[
          const HomeScreen(),
          BlocProvider(
            create: (context) => StatisticsCubit(
              subscriptionCubit: context.read<SubscriptionCubit>(),
              settingsCubit: context.read<SettingsCubit>(),
            ),
            child: const StatisticsScreen(),
          ),
          const SettingsScreen(),
        ],
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          app_haptics.HapticFeedback.lightImpact();
          context.pushNamed(AppRoutes.addSubscription);
        },
        tooltip: 'Add Subscription',
        child: const Icon(Icons.add),
      ),
      floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked,
      bottomNavigationBar: BottomAppBar(
        notchMargin: 8.0,
        child: Row(
          mainAxisSize: MainAxisSize.max,
          mainAxisAlignment: MainAxisAlignment.spaceAround,
          children: <Widget>[
            _buildBottomNavItem(
                icon: Icons.home_filled, label: 'Home', index: 0),
            _buildBottomNavItem(
                icon: Icons.pie_chart_rounded, label: 'Stats', index: 1),
            const SizedBox(width: 48), // The notch space
            _buildBottomNavItem(
                icon: Icons.settings_rounded, label: 'Settings', index: 2),
            _buildBottomNavItem(
                icon: Icons.person_rounded,
                label: 'Profile',
                index: 3), // Example for future use
          ],
        ),
      ),
    );
  }

  Widget _buildBottomNavItem({
    required IconData icon,
    required String label,
    required int index,
  }) {
    final theme = Theme.of(context);
    final isSelected = _currentIndex == index;
    // Index 3 (Profile) ist vorerst deaktiviert
    final bool isDisabled = index > 2;

    final color = isDisabled
        ? theme.colorScheme.onSurface.withOpacity(0.3)
        : isSelected
            ? theme.colorScheme.primary
            : theme.colorScheme.onSurfaceVariant;

    return Expanded(
      child: TapScaleEffect(
        onTap: isDisabled ? null : () => _onBottomNavItemTapped(index),
        child: Padding(
          padding: const EdgeInsets.symmetric(vertical: 8.0),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(icon, color: color, size: 28),
              const SizedBox(height: 2),
              AnimatedContainer(
                duration: const Duration(milliseconds: 200),
                height: 4,
                width: isSelected ? 24 : 0,
                decoration: BoxDecoration(
                  color: theme.colorScheme.primary,
                  borderRadius: BorderRadius.circular(2),
                ),
              )
            ],
          ),
        ),
      ),
    );
  }
}

class TapScaleEffect extends StatefulWidget {
  final Widget child;
  final VoidCallback? onTap;

  const TapScaleEffect({super.key, required this.child, this.onTap});

  @override
  State<TapScaleEffect> createState() => _TapScaleEffectState();
}

class _TapScaleEffectState extends State<TapScaleEffect>
    with SingleTickerProviderStateMixin {
  late final AnimationController _controller;
  late final Animation<double> _scaleAnimation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 150),
    );
    _scaleAnimation = Tween<double>(begin: 1.0, end: 0.9)
        .animate(CurvedAnimation(parent: _controller, curve: Curves.easeOut));
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  void _handleTapDown(TapDownDetails details) {
    _controller.forward();
  }

  void _handleTapUp(TapUpDetails details) {
    Future.delayed(const Duration(milliseconds: 100), () {
      if (mounted) _controller.reverse();
    });
  }

  void _handleTapCancel() {
    _controller.reverse();
  }

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTapDown: widget.onTap != null ? _handleTapDown : null,
      onTapUp: widget.onTap != null ? _handleTapUp : null,
      onTapCancel: widget.onTap != null ? _handleTapCancel : null,
      onTap: widget.onTap,
      child: ScaleTransition(
        scale: _scaleAnimation,
        child: widget.child,
      ),
    );
  }
}


===== FILE: animated_counter_widget.dart =====
===== PATH: lib/widgets/animated_counter_widget.dart =====

import 'package:flutter/material.dart';
// import 'dart:math' as math; // Unused import

class AnimatedCounterWidget extends StatelessWidget {
  final double value;
  final String Function(double) formatter;
  final TextStyle style;
  final Duration duration;
  final Curve curve;
  final bool useFlipAnimation; 

  const AnimatedCounterWidget({
    super.key,
    required this.value,
    required this.formatter,
    required this.style,
    this.duration = const Duration(milliseconds: 500),
    this.curve = Curves.easeOutCubic,
    this.useFlipAnimation = false, 
  });

  @override
  Widget build(BuildContext context) {
    if (useFlipAnimation) {
      return TweenAnimationBuilder<double>(
        tween: Tween<double>(begin: 0, end: value), 
        duration: duration,
        curve: curve,
        builder: (context, animatedValue, child) {
          return Text(formatter(animatedValue), style: style);
        },
      );
    } else {
      return TweenAnimationBuilder<double>(
        tween: Tween<double>(begin: _getBeginValue(), end: value),
        duration: duration,
        curve: curve,
        builder: (context, animatedValue, child) {
          return Text(formatter(animatedValue), style: style);
        },
      );
    }
  }

  double _getBeginValue() {
    return 0.0; 
  }
}

===== FILE: animated_gradient_chip.dart =====
===== PATH: lib/widgets/animated_gradient_chip.dart =====

import 'dart:math';
import 'package:flutter/material.dart';

class AnimatedGradientChip extends StatefulWidget {
  final String label;
  final IconData icon;
  final bool isSelected;
  final ValueChanged<bool> onSelected;
  final List<Color>? gradientColors;
  final Color? selectedColor;

  const AnimatedGradientChip({
    super.key,
    required this.label,
    required this.icon,
    required this.isSelected,
    required this.onSelected,
    this.gradientColors,
    this.selectedColor,
  });

  @override
  State<AnimatedGradientChip> createState() => _AnimatedGradientChipState();
}

class _AnimatedGradientChipState extends State<AnimatedGradientChip>
    with SingleTickerProviderStateMixin {
  late final AnimationController _animationController;

  @override
  void initState() {
    super.initState();
    _animationController = AnimationController(
      vsync: this,
      duration: const Duration(seconds: 4),
    )..repeat();
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final defaultGradient = [
      Colors.pink.shade200,
      Colors.purple.shade200,
      Colors.blue.shade200,
      Colors.pink.shade200,
    ];
    final gradient = widget.gradientColors ?? defaultGradient;
    final Color contentColor = widget.isSelected
        ? (ThemeData.estimateBrightnessForColor(
                    widget.selectedColor ?? theme.colorScheme.primary) ==
                Brightness.dark
            ? Colors.white
            : Colors.black)
        : theme.colorScheme.onSurfaceVariant;
    final Color backgroundColor = widget.isSelected
        ? (widget.selectedColor ?? theme.colorScheme.primary)
        : theme.colorScheme.surface;

    return CustomPaint(
      foregroundPainter: widget.isSelected
          ? GradientOutlinePainter(
              animation: _animationController,
              strokeWidth: 2.0,
              radius: 50.0,
              gradientColors: gradient,
            )
          : null,
      child: Material(
        color: Colors.transparent,
        child: InkWell(
          onTap: () => widget.onSelected(!widget.isSelected),
          borderRadius: BorderRadius.circular(50.0),
          child: AnimatedContainer(
            duration: const Duration(milliseconds: 200),
            padding:
                const EdgeInsets.symmetric(horizontal: 16.0, vertical: 10.0),
            decoration: BoxDecoration(
              color: backgroundColor,
              borderRadius: BorderRadius.circular(50.0),
            ),
            child: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Icon(widget.icon, size: 18, color: contentColor),
                const SizedBox(width: 8.0),
                Text(
                  widget.label,
                  style: theme.textTheme.labelLarge?.copyWith(
                    color: contentColor,
                    fontWeight: widget.isSelected ? FontWeight.bold : null,
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

class GradientOutlinePainter extends CustomPainter {
  final Animation<double> animation;
  final double strokeWidth;
  final double radius;
  final List<Color> gradientColors;

  GradientOutlinePainter({
    required this.animation,
    required this.strokeWidth,
    required this.radius,
    required this.gradientColors,
  }) : super(repaint: animation);

  @override
  void paint(Canvas canvas, Size size) {
    final Rect rect = Offset.zero & size;
    final RRect rrect = RRect.fromRectAndRadius(rect, Radius.circular(radius))
        .deflate(strokeWidth / 2);

    final paint = Paint()
      ..shader = SweepGradient(
        colors: gradientColors,
        startAngle: 0.0,
        endAngle: pi * 2,
        transform: GradientRotation(animation.value * 2 * pi),
      ).createShader(rect)
      ..strokeWidth = strokeWidth
      ..style = PaintingStyle.stroke;

    canvas.drawRRect(rrect, paint);
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => true;
}


===== FILE: animated_gradient_input_border.dart =====
===== PATH: lib/widgets/animated_gradient_input_border.dart =====

import 'dart:math';
import 'package:flutter/material.dart';

class AnimatedGradientInputBorder extends OutlineInputBorder {
  final Animation<double> animation;
  final List<Color> gradientColors;

  const AnimatedGradientInputBorder({
    required this.animation,
    required this.gradientColors,
    super.borderSide = const BorderSide(width: 2.0),
    super.borderRadius = const BorderRadius.all(Radius.circular(12.0)),
    super.gapPadding = 4.0,
  });

  @override
  void paint(
    Canvas canvas,
    Rect rect, {
    double? gapStart,
    double gapExtent = 0.0,
    double gapPercentage = 0.0,
    TextDirection? textDirection,
  }) {
    final Paint paint = borderSide.toPaint();

    paint.shader = SweepGradient(
      colors: gradientColors,
      startAngle: 0.0,
      endAngle: pi * 2,
      transform: GradientRotation(animation.value * 2 * pi),
    ).createShader(rect);

    final Path path = getOuterPath(rect, textDirection: textDirection);
    canvas.drawPath(path, paint);
  }

  @override
  AnimatedGradientInputBorder scale(double t) {
    return AnimatedGradientInputBorder(
      animation: animation,
      gradientColors: gradientColors,
      borderSide: borderSide.scale(t),
      borderRadius: borderRadius * t,
      gapPadding: gapPadding * t,
    );
  }
}


===== FILE: animated_gradient_outline.dart =====
===== PATH: lib/widgets/animated_gradient_outline.dart =====

import 'dart:math';
import 'package:flutter/material.dart';

class AnimatedGradientOutline extends StatefulWidget {
  final Widget child;
  final TextEditingController? controller;
  final String? labelText;
  final String? errorText;
  final double strokeWidth;
  final double radius;
  final List<Color>? gradientColors;
  final double? height; // Hinzugefügt: Optionale feste Höhe

  const AnimatedGradientOutline({
    super.key,
    required this.child,
    this.controller,
    this.labelText,
    this.errorText,
    this.strokeWidth = 2.0,
    this.radius = 12.0,
    this.gradientColors,
    this.height,
  });

  @override
  State<AnimatedGradientOutline> createState() =>
      _AnimatedGradientOutlineState();
}

class _AnimatedGradientOutlineState extends State<AnimatedGradientOutline>
    with SingleTickerProviderStateMixin {
  final FocusNode _focusNode = FocusNode();
  late final AnimationController _animationController;

  bool get _isFloating =>
      _focusNode.hasFocus || (widget.controller?.text.isNotEmpty ?? false);

  @override
  void initState() {
    super.initState();
    _animationController = AnimationController(
      vsync: this,
      duration: const Duration(seconds: 4),
    )..repeat();
    _focusNode.addListener(() => setState(() {}));
    widget.controller?.addListener(() => setState(() {}));
  }

  @override
  void dispose() {
    _animationController.dispose();
    _focusNode.dispose();
    widget.controller?.removeListener(() {});
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final bool hasError = widget.errorText != null;
    final bool isFocused = _focusNode.hasFocus;

    final defaultGradient = [
      Colors.pink.shade200,
      Colors.purple.shade200,
      Colors.blue.shade200,
      Colors.pink.shade200,
    ];

    // KORREKTUR: Veraltete 'withOpacity' entfernt
    final errorGradient = [
      theme.colorScheme.error.withAlpha(180),
      Colors.orange.shade400.withAlpha(180),
      theme.colorScheme.error.withAlpha(180),
    ];

    double labelWidth = 0;
    if ((isFocused || hasError) && widget.labelText != null) {
      final textStyle =
          theme.textTheme.bodySmall?.copyWith(color: theme.colorScheme.primary);
      final textPainter = TextPainter(
        text: TextSpan(text: widget.labelText!, style: textStyle),
        maxLines: 1,
        textDirection: TextDirection.ltr,
      )..layout();
      labelWidth = textPainter.width;
    }

    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Stack(
          children: [
            SizedBox(
              height:
                  widget.height ?? 60.0, // KORREKTUR: Feste Höhe oder Standard
              child: CustomPaint(
                painter: GradientOutlinePainter(
                  isFocused: isFocused || hasError,
                  labelWidth: labelWidth,
                  animation: _animationController,
                  strokeWidth: widget.strokeWidth,
                  radius: widget.radius,
                  gradientColors: hasError
                      ? errorGradient
                      : (widget.gradientColors ?? defaultGradient),
                  backgroundColor: theme.colorScheme.surface,
                ),
              ),
            ),
            Padding(
              padding: const EdgeInsets.only(top: 8.0),
              child: Focus(
                focusNode: _focusNode,
                child: widget.child,
              ),
            ),
            if (widget.labelText != null)
              AnimatedPositioned(
                duration: const Duration(milliseconds: 200),
                curve: Curves.easeOut,
                top: _isFloating ? 6.0 : 18.0,
                left: 16.0,
                child: AnimatedDefaultTextStyle(
                  duration: const Duration(milliseconds: 200),
                  style: _isFloating
                      ? theme.textTheme.bodySmall!.copyWith(
                          color: hasError
                              ? theme.colorScheme.error
                              : theme.colorScheme.primary)
                      : theme.textTheme.bodyLarge!
                          .copyWith(color: theme.colorScheme.onSurfaceVariant),
                  child: Text(widget.labelText!),
                ),
              ),
          ],
        ),
        AnimatedSwitcher(
          duration: const Duration(milliseconds: 200),
          transitionBuilder: (child, animation) {
            return FadeTransition(
              opacity: animation,
              child: SizeTransition(
                  sizeFactor: animation, axis: Axis.vertical, child: child),
            );
          },
          child: hasError
              ? Padding(
                  padding: const EdgeInsets.only(left: 12.0, top: 6.0),
                  child: Row(
                    children: [
                      Icon(Icons.warning_amber_rounded,
                          color: theme.colorScheme.error, size: 16),
                      const SizedBox(width: 8.0),
                      Text(
                        widget.errorText!,
                        style: theme.textTheme.bodyMedium
                            ?.copyWith(color: theme.colorScheme.error),
                      ),
                    ],
                  ),
                )
              : const SizedBox(height: 12.0),
        ),
      ],
    );
  }
}

class GradientOutlinePainter extends CustomPainter {
  final bool isFocused;
  final double labelWidth;
  final Animation<double> animation;
  final double strokeWidth;
  final double radius;
  final List<Color> gradientColors;
  final Color backgroundColor;

  GradientOutlinePainter({
    required this.isFocused,
    this.labelWidth = 0.0,
    required this.animation,
    required this.strokeWidth,
    required this.radius,
    required this.gradientColors,
    required this.backgroundColor,
  }) : super(repaint: animation);

  @override
  void paint(Canvas canvas, Size size) {
    final Rect rect = Offset.zero & size;
    final RRect rrect = RRect.fromRectAndRadius(rect, Radius.circular(radius));

    final backgroundPaint = Paint()..color = backgroundColor;
    canvas.drawRRect(rrect, backgroundPaint);

    if (isFocused) {
      final borderPaint = Paint()
        ..shader = SweepGradient(
          colors: gradientColors,
          startAngle: 0.0,
          endAngle: pi * 2,
          transform: GradientRotation(animation.value * 2 * pi),
        ).createShader(rect)
        ..strokeWidth = strokeWidth
        ..style = PaintingStyle.stroke;

      final Path path = Path()..addRRect(rrect);

      if (labelWidth > 0) {
        const double gapPadding = 4.0;
        final double gapStart = 12.0;
        final double gapExtent = labelWidth + gapPadding * 2;
        final Path gapPath = Path();
        gapPath.addRect(
            Rect.fromLTWH(gapStart - gapPadding, 0, gapExtent, strokeWidth));
        canvas.clipPath(Path.combine(PathOperation.difference, path, gapPath));
      }

      canvas.drawPath(path, borderPaint);
    }
  }

  @override
  bool shouldRepaint(covariant GradientOutlinePainter oldDelegate) {
    return oldDelegate.isFocused != isFocused ||
        oldDelegate.labelWidth != labelWidth ||
        oldDelegate.animation.value != animation.value;
  }
}


===== FILE: empty_state_widget.dart =====
===== PATH: lib/widgets/empty_state_widget.dart =====

import 'package:flutter/material.dart';

class EmptyStateWidget extends StatelessWidget {
  final IconData icon;
  final String title;
  final String message;
  final VoidCallback? onRetry;
  final String? retryText;

  const EmptyStateWidget({
    super.key,
    required this.icon,
    required this.title,
    required this.message,
    this.onRetry,
    this.retryText,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(32.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          crossAxisAlignment: CrossAxisAlignment.center,
          children: <Widget>[
            Icon(
              icon,
              size: 72,
              color: theme.colorScheme.onSurfaceVariant.withOpacity(0.6), // Kept withOpacity
            ),
            const SizedBox(height: 24),
            Text(
              title,
              style: theme.textTheme.headlineSmall?.copyWith(
                color: theme.colorScheme.onSurface,
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 12),
            Text(
              message,
              style: theme.textTheme.bodyMedium?.copyWith(
                color: theme.colorScheme.onSurfaceVariant,
              ),
              textAlign: TextAlign.center,
            ),
            if (onRetry != null) ...[
              const SizedBox(height: 24),
              ElevatedButton.icon(
                icon: const Icon(Icons.refresh_rounded),
                label: Text(retryText ?? 'Try Again'), 
                onPressed: onRetry,
                style: ElevatedButton.styleFrom(
                  padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }
}

===== FILE: pubspec.yaml =====
===== PATH: pubspec.yaml =====

name: aboapp
description: "A Flutter app for subscription management, refactored for clarity and maintainability."
publish_to: 'none' # Prevent accidental publishing

version: 3.0.0+1 # Starting fresh version for the refactor

environment:
  sdk: '>=3.3.0 <4.0.0' # Targeting a recent Dart SDK

dependencies:
  flutter:
    sdk: flutter
  flutter_localizations: # For internationalization
    sdk: flutter

  # State Management
  flutter_bloc: ^8.1.6 

  # Dependency Injection
  get_it: ^7.7.0
  injectable: ^2.5.0

  # Immutable Data Classes & Serialization
  freezed_annotation: ^2.4.1
  json_annotation: ^4.9.0

  # Routing
  go_router: ^14.2.0 

  # UI & Utility
  intl: ^0.19.0 
  uuid: ^4.4.0 
  cached_network_image: ^3.3.1 
  fl_chart: ^0.68.0 
  shimmer: ^3.0.0 
  flutter_native_splash: ^2.4.0 
  cupertino_icons: ^1.0.8 
  animations: ^2.0.11
  collection: ^1.18.0
  percent_indicator: ^4.2.3
  flutter_staggered_grid_view: ^0.7.0 # NEU
  flutter_staggered_animations: ^1.1.1 # NEU

  # Local Storage
  shared_preferences: ^2.2.3

  # Local Notifications (if reminders are a feature)
  # flutter_local_notifications: ^17.0.0 

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^4.0.0 
  build_runner: ^2.4.11
  freezed: ^2.5.2 
  json_serializable: ^6.8.0 
  injectable_generator: ^2.5.0 
  go_router_builder: ^2.7.0 

flutter:
  uses-material-design: true

  assets:
    - assets/l10n/

flutter_native_splash:
  color: "#121212" 
  image: assets/images/app_logo_splash.png 
  android_12:
    color: "#121212"
    image: assets/images/app_logo_splash.png
  fullscreen: true

===== FILE: README.md =====
===== PATH: README.md =====

# aboapp_v4

A new Flutter project.

## Getting Started

This project is a starting point for a Flutter application.

A few resources to get you started if this is your first Flutter project:

- [Lab: Write your first Flutter app](https://docs.flutter.dev/get-started/codelab)
- [Cookbook: Useful Flutter samples](https://docs.flutter.dev/cookbook)

For help getting started with Flutter development, view the
[online documentation](https://docs.flutter.dev/), which offers tutorials,
samples, guidance on mobile development, and a full API reference.


