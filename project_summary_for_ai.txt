============================================================
  PROJECT SUMMARY - Relevant files for project: D:\Hobbies\Projects\aboappv4\aboapp_v4-main\aboapp_v4
  Generated: 2025-06-08 11:43:59
============================================================

===== FILE: analysis_options.yaml =====
===== PATH: analysis_options.yaml =====

# This file configures the analyzer, which statically analyzes Dart code to
# check for errors, warnings, and lints.
#
# The issues identified by the analyzer are surfaced in the UI of Dart-enabled
# IDEs (https://dart.dev/tools#ides-and-editors). The analyzer can also be
# invoked from the command line by running `flutter analyze`.

# The following line activates a set of recommended lints for Flutter apps,
# packages, and plugins designed to encourage good coding practices.
include: package:flutter_lints/flutter.yaml

linter:
  # The lint rules applied to this project can be customized in the
  # section below to disable rules from the `package:flutter_lints/flutter.yaml`
  # included above or to enable additional rules. A list of all available lints
  # and their documentation is published at https://dart.dev/lints.
  #
  # Instead of disabling a lint rule for the entire project in the
  # section below, it can also be suppressed for a single line of code
  # or a specific dart file by using the `// ignore: name_of_lint` and
  # `// ignore_for_file: name_of_lint` syntax on the line or in the file
  # producing the lint.
  rules:
    # avoid_print: false  # Uncomment to disable the `avoid_print` rule
    # prefer_single_quotes: true  # Uncomment to enable the `prefer_single_quotes` rule

# Additional information about this file can be found at
# https://dart.dev/guides/language/analysis-options


===== FILE: build.gradle.kts =====
===== PATH: android/app/build.gradle.kts =====

plugins {
    id("com.android.application")
    id("kotlin-android")
    // The Flutter Gradle Plugin must be applied after the Android and Kotlin Gradle plugins.
    id("dev.flutter.flutter-gradle-plugin")
}

android {
    namespace = "com.example.aboapp_v4"
    compileSdk = flutter.compileSdkVersion
    ndkVersion = flutter.ndkVersion

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_11
        targetCompatibility = JavaVersion.VERSION_11
    }

    kotlinOptions {
        jvmTarget = JavaVersion.VERSION_11.toString()
    }

    defaultConfig {
        // TODO: Specify your own unique Application ID (https://developer.android.com/studio/build/application-id.html).
        applicationId = "com.example.aboapp_v4"
        // You can update the following values to match your application needs.
        // For more information, see: https://flutter.dev/to/review-gradle-config.
        minSdk = flutter.minSdkVersion
        targetSdk = flutter.targetSdkVersion
        versionCode = flutter.versionCode
        versionName = flutter.versionName
    }

    buildTypes {
        release {
            // TODO: Add your own signing config for the release build.
            // Signing with the debug keys for now, so `flutter run --release` works.
            signingConfig = signingConfigs.getByName("debug")
        }
    }
}

flutter {
    source = "../.."
}


===== FILE: AndroidManifest.xml =====
===== PATH: android/app/src/main/AndroidManifest.xml =====

<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <application
        android:label="aboapp_v4"
        android:name="${applicationName}"
        android:icon="@mipmap/ic_launcher">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:launchMode="singleTop"
            android:taskAffinity=""
            android:theme="@style/LaunchTheme"
            android:configChanges="orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode"
            android:hardwareAccelerated="true"
            android:windowSoftInputMode="adjustResize">
            <!-- Specifies an Android theme to apply to this Activity as soon as
                 the Android process has started. This theme is visible to the user
                 while the Flutter UI initializes. After that, this theme continues
                 to determine the Window background behind the Flutter UI. -->
            <meta-data
              android:name="io.flutter.embedding.android.NormalTheme"
              android:resource="@style/NormalTheme"
              />
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
        <!-- Don't delete the meta-data below.
             This is used by the Flutter tool to generate GeneratedPluginRegistrant.java -->
        <meta-data
            android:name="flutterEmbedding"
            android:value="2" />
    </application>
    <!-- Required to query activities that can process text, see:
         https://developer.android.com/training/package-visibility and
         https://developer.android.com/reference/android/content/Intent#ACTION_PROCESS_TEXT.

         In particular, this is used by the Flutter engine in io.flutter.plugin.text.ProcessTextPlugin. -->
    <queries>
        <intent>
            <action android:name="android.intent.action.PROCESS_TEXT"/>
            <data android:mimeType="text/plain"/>
        </intent>
    </queries>
</manifest>


===== FILE: MainActivity.kt =====
===== PATH: android/app/src/main/kotlin/com/example/aboapp_v4/MainActivity.kt =====

package com.example.aboapp_v4

import io.flutter.embedding.android.FlutterActivity

class MainActivity : FlutterActivity()


===== FILE: launch_background.xml =====
===== PATH: android/app/src/main/res/drawable/launch_background.xml =====

<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="@android:color/white" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>


===== FILE: launch_background.xml =====
===== PATH: android/app/src/main/res/drawable-v21/launch_background.xml =====

<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="?android:colorBackground" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>


===== FILE: styles.xml =====
===== PATH: android/app/src/main/res/values/styles.xml =====

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is off -->
    <style name="LaunchTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>


===== FILE: styles.xml =====
===== PATH: android/app/src/main/res/values-night/styles.xml =====

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is on -->
    <style name="LaunchTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>


===== FILE: build.gradle.kts =====
===== PATH: android/build.gradle.kts =====

allprojects {
    repositories {
        google()
        mavenCentral()
    }
}

val newBuildDir: Directory = rootProject.layout.buildDirectory.dir("../../build").get()
rootProject.layout.buildDirectory.value(newBuildDir)

subprojects {
    val newSubprojectBuildDir: Directory = newBuildDir.dir(project.name)
    project.layout.buildDirectory.value(newSubprojectBuildDir)
}
subprojects {
    project.evaluationDependsOn(":app")
}

tasks.register<Delete>("clean") {
    delete(rootProject.layout.buildDirectory)
}


===== FILE: gradle.properties =====
===== PATH: android/gradle.properties =====

org.gradle.jvmargs=-Xmx8G -XX:MaxMetaspaceSize=4G -XX:ReservedCodeCacheSize=512m -XX:+HeapDumpOnOutOfMemoryError
android.useAndroidX=true
android.enableJetifier=true


===== FILE: settings.gradle.kts =====
===== PATH: android/settings.gradle.kts =====

pluginManagement {
    val flutterSdkPath = run {
        val properties = java.util.Properties()
        file("local.properties").inputStream().use { properties.load(it) }
        val flutterSdkPath = properties.getProperty("flutter.sdk")
        require(flutterSdkPath != null) { "flutter.sdk not set in local.properties" }
        flutterSdkPath
    }

    includeBuild("$flutterSdkPath/packages/flutter_tools/gradle")

    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}

plugins {
    id("dev.flutter.flutter-plugin-loader") version "1.0.0"
    id("com.android.application") version "8.7.0" apply false
    id("org.jetbrains.kotlin.android") version "1.8.22" apply false
}

include(":app")


===== FILE: project.pbxproj =====
===== PATH: ios/Runner.xcodeproj/project.pbxproj =====

// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 54;
	objects = {

/* Begin PBXBuildFile section */
		1498D2341E8E89220040F4C2 /* GeneratedPluginRegistrant.m in Sources */ = {isa = PBXBuildFile; fileRef = 1498D2331E8E89220040F4C2 /* GeneratedPluginRegistrant.m */; };
		331C808B294A63AB00263BE5 /* RunnerTests.swift in Sources */ = {isa = PBXBuildFile; fileRef = 331C807B294A618700263BE5 /* RunnerTests.swift */; };
		3B3967161E833CAA004F5970 /* AppFrameworkInfo.plist in Resources */ = {isa = PBXBuildFile; fileRef = 3B3967151E833CAA004F5970 /* AppFrameworkInfo.plist */; };
		74858FAF1ED2DC5600515810 /* AppDelegate.swift in Sources */ = {isa = PBXBuildFile; fileRef = 74858FAE1ED2DC5600515810 /* AppDelegate.swift */; };
		97C146FC1CF9000F007C117D /* Main.storyboard in Resources */ = {isa = PBXBuildFile; fileRef = 97C146FA1CF9000F007C117D /* Main.storyboard */; };
		97C146FE1CF9000F007C117D /* Assets.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = 97C146FD1CF9000F007C117D /* Assets.xcassets */; };
		97C147011CF9000F007C117D /* LaunchScreen.storyboard in Resources */ = {isa = PBXBuildFile; fileRef = 97C146FF1CF9000F007C117D /* LaunchScreen.storyboard */; };
/* End PBXBuildFile section */

/* Begin PBXContainerItemProxy section */
		331C8085294A63A400263BE5 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = 97C146E61CF9000F007C117D /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = 97C146ED1CF9000F007C117D;
			remoteInfo = Runner;
		};
/* End PBXContainerItemProxy section */

/* Begin PBXCopyFilesBuildPhase section */
		9705A1C41CF9048500538489 /* Embed Frameworks */ = {
			isa = PBXCopyFilesBuildPhase;
			buildActionMask = 2147483647;
			dstPath = "";
			dstSubfolderSpec = 10;
			files = (
			);
			name = "Embed Frameworks";
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXCopyFilesBuildPhase section */

/* Begin PBXFileReference section */
		1498D2321E8E86230040F4C2 /* GeneratedPluginRegistrant.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = GeneratedPluginRegistrant.h; sourceTree = "<group>"; };
		1498D2331E8E89220040F4C2 /* GeneratedPluginRegistrant.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GeneratedPluginRegistrant.m; sourceTree = "<group>"; };
		331C807B294A618700263BE5 /* RunnerTests.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = RunnerTests.swift; sourceTree = "<group>"; };
		331C8081294A63A400263BE5 /* RunnerTests.xctest */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = RunnerTests.xctest; sourceTree = BUILT_PRODUCTS_DIR; };
		3B3967151E833CAA004F5970 /* AppFrameworkInfo.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.xml; name = AppFrameworkInfo.plist; path = Flutter/AppFrameworkInfo.plist; sourceTree = "<group>"; };
		74858FAD1ED2DC5600515810 /* Runner-Bridging-Header.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = "Runner-Bridging-Header.h"; sourceTree = "<group>"; };
		74858FAE1ED2DC5600515810 /* AppDelegate.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = AppDelegate.swift; sourceTree = "<group>"; };
		7AFA3C8E1D35360C0083082E /* Release.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; name = Release.xcconfig; path = Flutter/Release.xcconfig; sourceTree = "<group>"; };
		9740EEB21CF90195004384FC /* Debug.xcconfig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.xcconfig; name = Debug.xcconfig; path = Flutter/Debug.xcconfig; sourceTree = "<group>"; };
		9740EEB31CF90195004384FC /* Generated.xcconfig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.xcconfig; name = Generated.xcconfig; path = Flutter/Generated.xcconfig; sourceTree = "<group>"; };
		97C146EE1CF9000F007C117D /* Runner.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = Runner.app; sourceTree = BUILT_PRODUCTS_DIR; };
		97C146FB1CF9000F007C117D /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.storyboard; name = Base; path = Base.lproj/Main.storyboard; sourceTree = "<group>"; };
		97C146FD1CF9000F007C117D /* Assets.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; path = Assets.xcassets; sourceTree = "<group>"; };
		97C147001CF9000F007C117D /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.storyboard; name = Base; path = Base.lproj/LaunchScreen.storyboard; sourceTree = "<group>"; };
		97C147021CF9000F007C117D /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
/* End PBXFileReference section */

/* Begin PBXFrameworksBuildPhase section */
		97C146EB1CF9000F007C117D /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXFrameworksBuildPhase section */

/* Begin PBXGroup section */
		331C8082294A63A400263BE5 /* RunnerTests */ = {
			isa = PBXGroup;
			children = (
				331C807B294A618700263BE5 /* RunnerTests.swift */,
			);
			path = RunnerTests;
			sourceTree = "<group>";
		};
		9740EEB11CF90186004384FC /* Flutter */ = {
			isa = PBXGroup;
			children = (
				3B3967151E833CAA004F5970 /* AppFrameworkInfo.plist */,
				9740EEB21CF90195004384FC /* Debug.xcconfig */,
				7AFA3C8E1D35360C0083082E /* Release.xcconfig */,
				9740EEB31CF90195004384FC /* Generated.xcconfig */,
			);
			name = Flutter;
			sourceTree = "<group>";
		};
		97C146E51CF9000F007C117D = {
			isa = PBXGroup;
			children = (
				9740EEB11CF90186004384FC /* Flutter */,
				97C146F01CF9000F007C117D /* Runner */,
				97C146EF1CF9000F007C117D /* Products */,
				331C8082294A63A400263BE5 /* RunnerTests */,
			);
			sourceTree = "<group>";
		};
		97C146EF1CF9000F007C117D /* Products */ = {
			isa = PBXGroup;
			children = (
				97C146EE1CF9000F007C117D /* Runner.app */,
				331C8081294A63A400263BE5 /* RunnerTests.xctest */,
			);
			name = Products;
			sourceTree = "<group>";
		};
		97C146F01CF9000F007C117D /* Runner */ = {
			isa = PBXGroup;
			children = (
				97C146FA1CF9000F007C117D /* Main.storyboard */,
				97C146FD1CF9000F007C117D /* Assets.xcassets */,
				97C146FF1CF9000F007C117D /* LaunchScreen.storyboard */,
				97C147021CF9000F007C117D /* Info.plist */,
				1498D2321E8E86230040F4C2 /* GeneratedPluginRegistrant.h */,
				1498D2331E8E89220040F4C2 /* GeneratedPluginRegistrant.m */,
				74858FAE1ED2DC5600515810 /* AppDelegate.swift */,
				74858FAD1ED2DC5600515810 /* Runner-Bridging-Header.h */,
			);
			path = Runner;
			sourceTree = "<group>";
		};
/* End PBXGroup section */

/* Begin PBXNativeTarget section */
		331C8080294A63A400263BE5 /* RunnerTests */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 331C8087294A63A400263BE5 /* Build configuration list for PBXNativeTarget "RunnerTests" */;
			buildPhases = (
				331C807D294A63A400263BE5 /* Sources */,
				331C807F294A63A400263BE5 /* Resources */,
			);
			buildRules = (
			);
			dependencies = (
				331C8086294A63A400263BE5 /* PBXTargetDependency */,
			);
			name = RunnerTests;
			productName = RunnerTests;
			productReference = 331C8081294A63A400263BE5 /* RunnerTests.xctest */;
			productType = "com.apple.product-type.bundle.unit-test";
		};
		97C146ED1CF9000F007C117D /* Runner */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 97C147051CF9000F007C117D /* Build configuration list for PBXNativeTarget "Runner" */;
			buildPhases = (
				9740EEB61CF901F6004384FC /* Run Script */,
				97C146EA1CF9000F007C117D /* Sources */,
				97C146EB1CF9000F007C117D /* Frameworks */,
				97C146EC1CF9000F007C117D /* Resources */,
				9705A1C41CF9048500538489 /* Embed Frameworks */,
				3B06AD1E1E4923F5004D2608 /* Thin Binary */,
			);
			buildRules = (
			);
			dependencies = (
			);
			name = Runner;
			productName = Runner;
			productReference = 97C146EE1CF9000F007C117D /* Runner.app */;
			productType = "com.apple.product-type.application";
		};
/* End PBXNativeTarget section */

/* Begin PBXProject section */
		97C146E61CF9000F007C117D /* Project object */ = {
			isa = PBXProject;
			attributes = {
				BuildIndependentTargetsInParallel = YES;
				LastUpgradeCheck = 1510;
				ORGANIZATIONNAME = "";
				TargetAttributes = {
					331C8080294A63A400263BE5 = {
						CreatedOnToolsVersion = 14.0;
						TestTargetID = 97C146ED1CF9000F007C117D;
					};
					97C146ED1CF9000F007C117D = {
						CreatedOnToolsVersion = 7.3.1;
						LastSwiftMigration = 1100;
					};
				};
			};
			buildConfigurationList = 97C146E91CF9000F007C117D /* Build configuration list for PBXProject "Runner" */;
			compatibilityVersion = "Xcode 9.3";
			developmentRegion = en;
			hasScannedForEncodings = 0;
			knownRegions = (
				en,
				Base,
			);
			mainGroup = 97C146E51CF9000F007C117D;
			productRefGroup = 97C146EF1CF9000F007C117D /* Products */;
			projectDirPath = "";
			projectRoot = "";
			targets = (
				97C146ED1CF9000F007C117D /* Runner */,
				331C8080294A63A400263BE5 /* RunnerTests */,
			);
		};
/* End PBXProject section */

/* Begin PBXResourcesBuildPhase section */
		331C807F294A63A400263BE5 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		97C146EC1CF9000F007C117D /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				97C147011CF9000F007C117D /* LaunchScreen.storyboard in Resources */,
				3B3967161E833CAA004F5970 /* AppFrameworkInfo.plist in Resources */,
				97C146FE1CF9000F007C117D /* Assets.xcassets in Resources */,
				97C146FC1CF9000F007C117D /* Main.storyboard in Resources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXResourcesBuildPhase section */

/* Begin PBXShellScriptBuildPhase section */
		3B06AD1E1E4923F5004D2608 /* Thin Binary */ = {
			isa = PBXShellScriptBuildPhase;
			alwaysOutOfDate = 1;
			buildActionMask = 2147483647;
			files = (
			);
			inputPaths = (
				"${TARGET_BUILD_DIR}/${INFOPLIST_PATH}",
			);
			name = "Thin Binary";
			outputPaths = (
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "/bin/sh \"$FLUTTER_ROOT/packages/flutter_tools/bin/xcode_backend.sh\" embed_and_thin";
		};
		9740EEB61CF901F6004384FC /* Run Script */ = {
			isa = PBXShellScriptBuildPhase;
			alwaysOutOfDate = 1;
			buildActionMask = 2147483647;
			files = (
			);
			inputPaths = (
			);
			name = "Run Script";
			outputPaths = (
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "/bin/sh \"$FLUTTER_ROOT/packages/flutter_tools/bin/xcode_backend.sh\" build";
		};
/* End PBXShellScriptBuildPhase section */

/* Begin PBXSourcesBuildPhase section */
		331C807D294A63A400263BE5 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				331C808B294A63AB00263BE5 /* RunnerTests.swift in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		97C146EA1CF9000F007C117D /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				74858FAF1ED2DC5600515810 /* AppDelegate.swift in Sources */,
				1498D2341E8E89220040F4C2 /* GeneratedPluginRegistrant.m in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXSourcesBuildPhase section */

/* Begin PBXTargetDependency section */
		331C8086294A63A400263BE5 /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = 97C146ED1CF9000F007C117D /* Runner */;
			targetProxy = 331C8085294A63A400263BE5 /* PBXContainerItemProxy */;
		};
/* End PBXTargetDependency section */

/* Begin PBXVariantGroup section */
		97C146FA1CF9000F007C117D /* Main.storyboard */ = {
			isa = PBXVariantGroup;
			children = (
				97C146FB1CF9000F007C117D /* Base */,
			);
			name = Main.storyboard;
			sourceTree = "<group>";
		};
		97C146FF1CF9000F007C117D /* LaunchScreen.storyboard */ = {
			isa = PBXVariantGroup;
			children = (
				97C147001CF9000F007C117D /* Base */,
			);
			name = LaunchScreen.storyboard;
			sourceTree = "<group>";
		};
/* End PBXVariantGroup section */

/* Begin XCBuildConfiguration section */
		249021D3217E4FDB00AE95B9 /* Profile */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++0x";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GCC_C_LANGUAGE_STANDARD = gnu99;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 12.0;
				MTL_ENABLE_DEBUG_INFO = NO;
				SDKROOT = iphoneos;
				SUPPORTED_PLATFORMS = iphoneos;
				TARGETED_DEVICE_FAMILY = "1,2";
				VALIDATE_PRODUCT = YES;
			};
			name = Profile;
		};
		249021D4217E4FDB00AE95B9 /* Profile */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 7AFA3C8E1D35360C0083082E /* Release.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CURRENT_PROJECT_VERSION = "$(FLUTTER_BUILD_NUMBER)";
				ENABLE_BITCODE = NO;
				INFOPLIST_FILE = Runner/Info.plist;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				PRODUCT_BUNDLE_IDENTIFIER = com.example.aboappV4;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_OBJC_BRIDGING_HEADER = "Runner/Runner-Bridging-Header.h";
				SWIFT_VERSION = 5.0;
				VERSIONING_SYSTEM = "apple-generic";
			};
			name = Profile;
		};
		331C8088294A63A400263BE5 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.example.aboappV4.RunnerTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_ACTIVE_COMPILATION_CONDITIONS = DEBUG;
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
				SWIFT_VERSION = 5.0;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/Runner.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/Runner";
			};
			name = Debug;
		};
		331C8089294A63A400263BE5 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.example.aboappV4.RunnerTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_VERSION = 5.0;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/Runner.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/Runner";
			};
			name = Release;
		};
		331C808A294A63A400263BE5 /* Profile */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.example.aboappV4.RunnerTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_VERSION = 5.0;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/Runner.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/Runner";
			};
			name = Profile;
		};
		97C147031CF9000F007C117D /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++0x";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = dwarf;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_TESTABILITY = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GCC_C_LANGUAGE_STANDARD = gnu99;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"DEBUG=1",
					"$(inherited)",
				);
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 12.0;
				MTL_ENABLE_DEBUG_INFO = YES;
				ONLY_ACTIVE_ARCH = YES;
				SDKROOT = iphoneos;
				TARGETED_DEVICE_FAMILY = "1,2";
			};
			name = Debug;
		};
		97C147041CF9000F007C117D /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++0x";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GCC_C_LANGUAGE_STANDARD = gnu99;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 12.0;
				MTL_ENABLE_DEBUG_INFO = NO;
				SDKROOT = iphoneos;
				SUPPORTED_PLATFORMS = iphoneos;
				SWIFT_COMPILATION_MODE = wholemodule;
				SWIFT_OPTIMIZATION_LEVEL = "-O";
				TARGETED_DEVICE_FAMILY = "1,2";
				VALIDATE_PRODUCT = YES;
			};
			name = Release;
		};
		97C147061CF9000F007C117D /* Debug */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 9740EEB21CF90195004384FC /* Debug.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CURRENT_PROJECT_VERSION = "$(FLUTTER_BUILD_NUMBER)";
				ENABLE_BITCODE = NO;
				INFOPLIST_FILE = Runner/Info.plist;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				PRODUCT_BUNDLE_IDENTIFIER = com.example.aboappV4;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_OBJC_BRIDGING_HEADER = "Runner/Runner-Bridging-Header.h";
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
				SWIFT_VERSION = 5.0;
				VERSIONING_SYSTEM = "apple-generic";
			};
			name = Debug;
		};
		97C147071CF9000F007C117D /* Release */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 7AFA3C8E1D35360C0083082E /* Release.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CURRENT_PROJECT_VERSION = "$(FLUTTER_BUILD_NUMBER)";
				ENABLE_BITCODE = NO;
				INFOPLIST_FILE = Runner/Info.plist;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				PRODUCT_BUNDLE_IDENTIFIER = com.example.aboappV4;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_OBJC_BRIDGING_HEADER = "Runner/Runner-Bridging-Header.h";
				SWIFT_VERSION = 5.0;
				VERSIONING_SYSTEM = "apple-generic";
			};
			name = Release;
		};
/* End XCBuildConfiguration section */

/* Begin XCConfigurationList section */
		331C8087294A63A400263BE5 /* Build configuration list for PBXNativeTarget "RunnerTests" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				331C8088294A63A400263BE5 /* Debug */,
				331C8089294A63A400263BE5 /* Release */,
				331C808A294A63A400263BE5 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		97C146E91CF9000F007C117D /* Build configuration list for PBXProject "Runner" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				97C147031CF9000F007C117D /* Debug */,
				97C147041CF9000F007C117D /* Release */,
				249021D3217E4FDB00AE95B9 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		97C147051CF9000F007C117D /* Build configuration list for PBXNativeTarget "Runner" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				97C147061CF9000F007C117D /* Debug */,
				97C147071CF9000F007C117D /* Release */,
				249021D4217E4FDB00AE95B9 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
/* End XCConfigurationList section */
	};
	rootObject = 97C146E61CF9000F007C117D /* Project object */;
}


===== FILE: AppDelegate.swift =====
===== PATH: ios/Runner/AppDelegate.swift =====

import Flutter
import UIKit

@main
@objc class AppDelegate: FlutterAppDelegate {
  override func application(
    _ application: UIApplication,
    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
  ) -> Bool {
    GeneratedPluginRegistrant.register(with: self)
    return super.application(application, didFinishLaunchingWithOptions: launchOptions)
  }
}


===== FILE: Contents.json =====
===== PATH: ios/Runner/Assets.xcassets/AppIcon.appiconset/Contents.json =====

{
  "images" : [
    {
      "size" : "20x20",
      "idiom" : "iphone",
      "filename" : "Icon-App-20x20@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "20x20",
      "idiom" : "iphone",
      "filename" : "Icon-App-20x20@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "40x40",
      "idiom" : "iphone",
      "filename" : "Icon-App-40x40@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "40x40",
      "idiom" : "iphone",
      "filename" : "Icon-App-40x40@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "60x60",
      "idiom" : "iphone",
      "filename" : "Icon-App-60x60@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "60x60",
      "idiom" : "iphone",
      "filename" : "Icon-App-60x60@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "20x20",
      "idiom" : "ipad",
      "filename" : "Icon-App-20x20@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "20x20",
      "idiom" : "ipad",
      "filename" : "Icon-App-20x20@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "29x29",
      "idiom" : "ipad",
      "filename" : "Icon-App-29x29@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "29x29",
      "idiom" : "ipad",
      "filename" : "Icon-App-29x29@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "40x40",
      "idiom" : "ipad",
      "filename" : "Icon-App-40x40@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "40x40",
      "idiom" : "ipad",
      "filename" : "Icon-App-40x40@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "76x76",
      "idiom" : "ipad",
      "filename" : "Icon-App-76x76@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "76x76",
      "idiom" : "ipad",
      "filename" : "Icon-App-76x76@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "83.5x83.5",
      "idiom" : "ipad",
      "filename" : "Icon-App-83.5x83.5@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "1024x1024",
      "idiom" : "ios-marketing",
      "filename" : "Icon-App-1024x1024@1x.png",
      "scale" : "1x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}


===== FILE: Contents.json =====
===== PATH: ios/Runner/Assets.xcassets/LaunchImage.imageset/Contents.json =====

{
  "images" : [
    {
      "idiom" : "universal",
      "filename" : "LaunchImage.png",
      "scale" : "1x"
    },
    {
      "idiom" : "universal",
      "filename" : "LaunchImage@2x.png",
      "scale" : "2x"
    },
    {
      "idiom" : "universal",
      "filename" : "LaunchImage@3x.png",
      "scale" : "3x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}


===== FILE: Info.plist =====
===== PATH: ios/Runner/Info.plist =====

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>$(DEVELOPMENT_LANGUAGE)</string>
	<key>CFBundleDisplayName</key>
	<string>Aboapp V4</string>
	<key>CFBundleExecutable</key>
	<string>$(EXECUTABLE_NAME)</string>
	<key>CFBundleIdentifier</key>
	<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>aboapp_v4</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>$(FLUTTER_BUILD_NAME)</string>
	<key>CFBundleSignature</key>
	<string>????</string>
	<key>CFBundleVersion</key>
	<string>$(FLUTTER_BUILD_NUMBER)</string>
	<key>LSRequiresIPhoneOS</key>
	<true/>
	<key>UILaunchStoryboardName</key>
	<string>LaunchScreen</string>
	<key>UIMainStoryboardFile</key>
	<string>Main</string>
	<key>UISupportedInterfaceOrientations</key>
	<array>
		<string>UIInterfaceOrientationPortrait</string>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
	</array>
	<key>UISupportedInterfaceOrientations~ipad</key>
	<array>
		<string>UIInterfaceOrientationPortrait</string>
		<string>UIInterfaceOrientationPortraitUpsideDown</string>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
	</array>
	<key>CADisableMinimumFrameDurationOnPhone</key>
	<true/>
	<key>UIApplicationSupportsIndirectInputEvents</key>
	<true/>
</dict>
</plist>


===== FILE: Runner-Bridging-Header.h =====
===== PATH: ios/Runner/Runner-Bridging-Header.h =====

#import "GeneratedPluginRegistrant.h"


===== FILE: app.dart =====
===== PATH: lib/app.dart =====

import 'package:aboapp/core/di/injection.dart';
import 'package:aboapp/core/routing/app_router.dart';
import 'package:aboapp/core/theme/app_theme.dart';
import 'package:aboapp/features/settings/presentation/cubit/settings_cubit.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:aboapp/core/localization/app_localizations.dart'; // Import your AppLocalizations class

class AboApp extends StatelessWidget {
  const AboApp({super.key});

  @override
  Widget build(BuildContext context) {
    final appRouter = getIt<AppRouter>();

    return MultiBlocProvider(
      providers: [
        BlocProvider<SettingsCubit>(
          create: (context) => getIt<SettingsCubit>()..loadSettings(),
        ),
        // ... other global providers
      ],
      child: BlocBuilder<SettingsCubit, SettingsState>(
        builder: (context, settingsState) {
          return MaterialApp.router(
            title: 'AboApp V3', // This could also be localized if needed early
            debugShowCheckedModeBanner: false,
            theme: AppTheme.lightTheme,
            darkTheme: AppTheme.darkTheme,
            themeMode: settingsState.themeMode,
            routerConfig: appRouter.config(),

            // Localization Setup
            locale: settingsState.locale, // Driven by SettingsCubit
            supportedLocales: const [
              Locale('en', 'US'),
              Locale('de', 'DE'),
            ],
            localizationsDelegates: const [
              AppLocalizations.delegate, // Your custom delegate
              GlobalMaterialLocalizations.delegate,
              GlobalWidgetsLocalizations.delegate,
              GlobalCupertinoLocalizations.delegate,
            ],
            // Optional: Define how to resolve the locale if the device locale isn't exactly matched.
            localeResolutionCallback: (locale, supportedLocales) {
              for (var supportedLocale in supportedLocales) {
                if (supportedLocale.languageCode == locale?.languageCode) {
                  // If country code is also important, add: && supportedLocale.countryCode == locale?.countryCode
                  return supportedLocale;
                }
              }
              // If no exact match is found, fall back to the first supported locale (e.g., English)
              return supportedLocales.first;
            },
          );
        },
      ),
    );
  }
}

===== FILE: injection.config.dart =====
===== PATH: lib/core/di/injection.config.dart =====

// dart format width=80
// GENERATED CODE - DO NOT MODIFY BY HAND

// **************************************************************************
// InjectableConfigGenerator
// **************************************************************************

// ignore_for_file: type=lint
// coverage:ignore-file

// ignore_for_file: no_leading_underscores_for_library_prefixes
import 'package:get_it/get_it.dart' as _i174;
import 'package:injectable/injectable.dart' as _i526;
import 'package:shared_preferences/shared_preferences.dart' as _i460;
import 'package:uuid/uuid.dart' as _i706;

import '../../features/settings/data/datasources/settings_local_datasource.dart'
    as _i723;
import '../../features/settings/data/repositories/settings_repository_impl.dart'
    as _i955;
import '../../features/settings/domain/repositories/settings_repository.dart'
    as _i674;
import '../../features/settings/domain/usecases/get_settings_usecase.dart'
    as _i1029;
import '../../features/settings/domain/usecases/save_currency_setting_usecase.dart'
    as _i851;
import '../../features/settings/domain/usecases/save_locale_setting_usecase.dart'
    as _i682;
import '../../features/settings/domain/usecases/save_theme_setting_usecase.dart'
    as _i150;
import '../../features/settings/presentation/cubit/settings_cubit.dart'
    as _i792;
import '../../features/statistics/presentation/cubit/statistics_cubit.dart'
    as _i1049;
import '../../features/subscriptions/data/datasources/subscription_local_datasource.dart'
    as _i327;
import '../../features/subscriptions/data/repositories/subscription_repository_impl.dart'
    as _i944;
import '../../features/subscriptions/domain/repositories/subscription_repository.dart'
    as _i384;
import '../../features/subscriptions/domain/usecases/add_subscription_usecase.dart'
    as _i734;
import '../../features/subscriptions/domain/usecases/delete_subscription_usecase.dart'
    as _i170;
import '../../features/subscriptions/domain/usecases/get_all_subscriptions_usecase.dart'
    as _i899;
import '../../features/subscriptions/domain/usecases/update_subscription_usecase.dart'
    as _i684;
import '../../features/subscriptions/presentation/cubit/subscription_cubit.dart'
    as _i854;
import '../routing/app_router.dart' as _i282;

// initializes the registration of main-scope dependencies inside of GetIt
_i174.GetIt $initGetIt(
  _i174.GetIt getIt, {
  String? environment,
  _i526.EnvironmentFilter? environmentFilter,
}) {
  final gh = _i526.GetItHelper(
    getIt,
    environment,
    environmentFilter,
  );
  gh.factory<_i1049.StatisticsCubit>(() => _i1049.StatisticsCubit());
  gh.singleton<_i282.AppRouter>(
      () => _i282.AppRouter(gh<_i460.SharedPreferences>()));
  gh.lazySingleton<_i723.SettingsLocalDataSource>(
      () => _i723.SettingsLocalDataSourceImpl(gh<_i460.SharedPreferences>()));
  gh.lazySingleton<_i674.SettingsRepository>(
      () => _i955.SettingsRepositoryImpl(gh<_i723.SettingsLocalDataSource>()));
  gh.lazySingleton<_i327.SubscriptionLocalDataSource>(() =>
      _i327.SubscriptionLocalDataSourceImpl(gh<_i460.SharedPreferences>()));
  gh.lazySingleton<_i384.SubscriptionRepository>(() =>
      _i944.SubscriptionRepositoryImpl(
          localDataSource: gh<_i327.SubscriptionLocalDataSource>()));
  gh.lazySingleton<_i1029.GetSettingsUseCase>(
      () => _i1029.GetSettingsUseCase(gh<_i674.SettingsRepository>()));
  gh.lazySingleton<_i851.SaveCurrencySettingUseCase>(
      () => _i851.SaveCurrencySettingUseCase(gh<_i674.SettingsRepository>()));
  gh.lazySingleton<_i682.SaveLocaleSettingUseCase>(
      () => _i682.SaveLocaleSettingUseCase(gh<_i674.SettingsRepository>()));
  gh.lazySingleton<_i150.SaveThemeSettingUseCase>(
      () => _i150.SaveThemeSettingUseCase(gh<_i674.SettingsRepository>()));
  gh.factory<_i792.SettingsCubit>(() => _i792.SettingsCubit(
        gh<_i1029.GetSettingsUseCase>(),
        gh<_i150.SaveThemeSettingUseCase>(),
        gh<_i682.SaveLocaleSettingUseCase>(),
        gh<_i851.SaveCurrencySettingUseCase>(),
      ));
  gh.lazySingleton<_i734.AddSubscriptionUseCase>(
      () => _i734.AddSubscriptionUseCase(gh<_i384.SubscriptionRepository>()));
  gh.lazySingleton<_i170.DeleteSubscriptionUseCase>(() =>
      _i170.DeleteSubscriptionUseCase(gh<_i384.SubscriptionRepository>()));
  gh.lazySingleton<_i899.GetAllSubscriptionsUseCase>(() =>
      _i899.GetAllSubscriptionsUseCase(gh<_i384.SubscriptionRepository>()));
  gh.lazySingleton<_i684.UpdateSubscriptionUseCase>(() =>
      _i684.UpdateSubscriptionUseCase(gh<_i384.SubscriptionRepository>()));
  gh.factory<_i854.SubscriptionCubit>(() => _i854.SubscriptionCubit(
        gh<_i899.GetAllSubscriptionsUseCase>(),
        gh<_i734.AddSubscriptionUseCase>(),
        gh<_i684.UpdateSubscriptionUseCase>(),
        gh<_i170.DeleteSubscriptionUseCase>(),
        gh<_i706.Uuid>(),
      ));
  return getIt;
}


===== FILE: injection.dart =====
===== PATH: lib/core/di/injection.dart =====

import 'package:get_it/get_it.dart';
import 'package:injectable/injectable.dart';
import 'package:shared_preferences/shared_preferences.dart';
// This import will be generated by build_runner
import 'injection.config.dart'; // Ensure this line exists

final getIt = GetIt.instance;

@InjectableInit(
  initializerName: r'$initGetIt', // Default name for the generated function
  preferRelativeImports: true,   // Prefer relative imports in generated file
  asExtension: false,            // Generate as a function, not an extension
)
Future<void> configureDependencies() async {
  // Register modules and external dependencies manually if they cannot be annotated.
  // SharedPreferences is a common example.
  final sharedPreferences = await SharedPreferences.getInstance();
  getIt.registerSingleton<SharedPreferences>(sharedPreferences);

  // Initialize all modules and injectable dependencies
  $initGetIt(getIt);
}

// Example of a module if you need to provide dependencies that
// are not classes or come from third-party libraries without annotations.
@module
abstract class RegisterExternalDependencies {
  // Example:
  // @lazySingleton
  // Dio get dio => Dio(); // If you were using Dio for network requests
}

===== FILE: app_localizations.dart =====
===== PATH: lib/core/localization/app_localizations.dart =====

import 'dart:async';
import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

class AppLocalizations {
  final Locale locale;
  Map<String, String> _localizedStrings = {};

  AppLocalizations(this.locale);

  static AppLocalizations? of(BuildContext context) {
    return Localizations.of<AppLocalizations>(context, AppLocalizations);
  }

  static const LocalizationsDelegate<AppLocalizations> delegate = _AppLocalizationsDelegate();

  Future<bool> load() async {
    String jsonString = await rootBundle.loadString('assets/l10n/${locale.languageCode}.json');
    Map<String, dynamic> jsonMap = json.decode(jsonString);

    _localizedStrings = jsonMap.map((key, value) {
      return MapEntry(key, value.toString());
    });

    return true;
  }

  String translate(String key, {Map<String, String>? args}) {
    String? translation = _localizedStrings[key];
    if (translation == null) {
      // Fallback or error handling
      // print('Localization Error: Key "$key" not found for locale "${locale.languageCode}"'); // Avoid print
      return key; 
    }

    if (args != null && args.isNotEmpty) {
      args.forEach((argKey, argValue) {
        translation = translation!.replaceAll('{$argKey}', argValue);
      });
    }
    return translation!;
  }
}

class _AppLocalizationsDelegate extends LocalizationsDelegate<AppLocalizations> {
  const _AppLocalizationsDelegate();

  @override
  bool isSupported(Locale locale) {
    return ['en', 'de'].contains(locale.languageCode);
  }

  @override
  Future<AppLocalizations> load(Locale locale) async {
    AppLocalizations localizations = AppLocalizations(locale);
    await localizations.load();
    return localizations;
  }

  @override
  bool shouldReload(_AppLocalizationsDelegate old) => false;
}

===== FILE: app_router.dart =====
===== PATH: lib/core/routing/app_router.dart =====

import 'package:aboapp/features/onboarding/presentation/screens/onboarding_screen.dart';
import 'package:aboapp/features/settings/presentation/cubit/screens/settings_screen.dart'; // Corrected path
import 'package:aboapp/features/statistics/presentation/screens/statistics_screen.dart';
import 'package:aboapp/features/subscriptions/domain/entities/subscription_entity.dart';
import 'package:aboapp/features/subscriptions/presentation/screens/add_edit_subscription_screen.dart';
import 'package:aboapp/features/subscriptions/presentation/screens/home_screen.dart';
import 'package:aboapp/main_container_screen.dart'; 
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:injectable/injectable.dart';
import 'package:shared_preferences/shared_preferences.dart';

abstract class AppRoutes {
  static const String onboarding = '/onboarding';
  static const String home = '/home'; 
  static const String subscriptions = 'subscriptions'; 
  static const String statistics = 'statistics';   
  static const String settings = 'settings';     
  static const String addSubscription = 'add'; 
  static const String editSubscription = 'edit/:id'; 
}

@singleton 
class AppRouter {
  final SharedPreferences _sharedPreferences; 

  AppRouter(this._sharedPreferences);

  static final _rootNavigatorKey = GlobalKey<NavigatorState>();
  static final _shellNavigatorKey = GlobalKey<NavigatorState>(debugLabel: 'ShellNavigator');


  GoRouter config() {
    final bool onboardingComplete = _sharedPreferences.getBool('onboarding_complete') ?? false;

    return GoRouter(
      navigatorKey: _rootNavigatorKey,
      initialLocation: onboardingComplete ? AppRoutes.home : AppRoutes.onboarding,
      debugLogDiagnostics: true, 
      routes: [
        GoRoute(
          path: AppRoutes.onboarding,
          name: AppRoutes.onboarding,
          builder: (context, state) => const OnboardingScreen(),
        ),
        ShellRoute(
          navigatorKey: _shellNavigatorKey,
          builder: (context, state, child) {
            return MainContainerScreen(location: state.matchedLocation, child: child);
          },
          routes: [
            GoRoute(
              path: AppRoutes.home, 
              name: AppRoutes.home, 
              pageBuilder: (context, state) => const NoTransitionPage(
                child: HomeScreen(), 
              ),
              routes: [
                GoRoute(
                  path: AppRoutes.subscriptions, 
                  name: AppRoutes.subscriptions,
                   parentNavigatorKey: _rootNavigatorKey, 
                  builder: (context, state) => const HomeScreen(), 
                ),
                GoRoute(
                  path: AppRoutes.addSubscription, 
                  name: AppRoutes.addSubscription,
                  parentNavigatorKey: _rootNavigatorKey,
                  builder: (context, state) => const AddEditSubscriptionScreen(),
                ),
                GoRoute(
                  path: AppRoutes.editSubscription, 
                  name: AppRoutes.editSubscription,
                  parentNavigatorKey: _rootNavigatorKey,
                  builder: (context, state) {
                    final subscription = state.extra as SubscriptionEntity?;
                    final subscriptionId = state.pathParameters['id'];
                    return AddEditSubscriptionScreen(
                      subscriptionId: subscriptionId,
                      subscription: subscription,
                    );
                  },
                ),
                 GoRoute(
                  path: AppRoutes.statistics, 
                  name: AppRoutes.statistics,
                  pageBuilder: (context, state) => const NoTransitionPage(
                     child: StatisticsScreen(),
                  )
                ),
                GoRoute(
                  path: AppRoutes.settings, 
                  name: AppRoutes.settings,
                   pageBuilder: (context, state) => const NoTransitionPage(
                     child: SettingsScreen(), // Removed const, builder will handle it
                  )
                ),
              ]
            ),
          ],
        ),
      ],
      errorBuilder: (context, state) => Scaffold(
        appBar: AppBar(title: const Text('Page Not Found')),
        body: Center(child: Text('Error: ${state.error}')),
      ),
    );
  }
}

===== FILE: app_colors.dart =====
===== PATH: lib/core/theme/app_colors.dart =====

import 'package:flutter/material.dart';

// This class is not meant to be instantiated.
// It holds static color definitions for the app.
abstract class AppColors {
  // Primary Palette
  static const Color primary = Color(0xFF8B5CF6); // Purple
  static const Color primaryLight = Color(0xFFA78BFA);
  static const Color primaryDark = Color(0xFF7C3AED);
  static const Color onPrimary = Colors.white;

  // Accent/Secondary Palette (Can be same as primary or different)
  static const Color accent = Color(0xFFEC4899); // Pink, as an example accent
  static const Color onAccent = Colors.white;

  // Background & Surface Colors
  static const Color backgroundLight = Color(0xFFF9FAFB); // Off-white
  static const Color surfaceLight = Colors.white;
  static const Color onSurfaceLight = Color(0xFF1F2937); // Dark Gray
  static const Color onSurfaceVariantLight = Color(0xFF6B7280); // Medium Gray

  static const Color backgroundDark = Color(0xFF111827); // Very Dark Blue/Gray
  static const Color surfaceDark = Color(0xFF1F2937); // Dark Gray
  static const Color onSurfaceDark = Color(0xFFF3F4F6); // Light Gray
  static const Color onSurfaceVariantDark = Color(0xFF9CA3AF); // Medium-Light Gray

  // Semantic Colors
  static const Color error = Color(0xFFEF4444); // Red
  static const Color onError = Colors.white;
  static const Color success = Color(0xFF10B981); // Green
  static const Color onSuccess = Colors.white;
  static const Color warning = Color(0xFFF59E0B); // Amber
  static const Color onWarning = Colors.black; // Or white depending on contrast
  static const Color info = Color(0xFF3B82F6); // Blue
  static const Color onInfo = Colors.white;

  // Neutral/Border Colors
  static const Color borderLight = Color(0xFFE5E7EB);
  static const Color borderDark = Color(0xFF374151);

  // Subscription Category Colors (example, can be moved or expanded)
  static const Color catStreaming = Color(0xFFEF4444); // Red
  static const Color catSoftware = Color(0xFF8B5CF6); // Purple (same as primary)
  static const Color catGaming = Color(0xFF10B981);   // Green
  static const Color catFitness = Color(0xFFF59E0B);  // Amber
  static const Color catMusic = Color(0xFF3B82F6);    // Blue
  static const Color catNews = Color(0xFF6366F1);     // Indigo
  static const Color catCloud = Color(0xFF06B6D4);    // Cyan
  static const Color catOther = Color(0xFF6B7280);    // Gray
}

===== FILE: app_theme.dart =====
===== PATH: lib/core/theme/app_theme.dart =====

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:aboapp/core/theme/app_colors.dart';
import 'package:aboapp/core/theme/app_typography.dart';

abstract class AppTheme {
  static ThemeData get lightTheme {
    return ThemeData(
      useMaterial3: true,
      brightness: Brightness.light,
      fontFamily: AppTypography.fontFamily,
      primaryColor: AppColors.primary,
      scaffoldBackgroundColor: AppColors.backgroundLight,
      colorScheme: const ColorScheme(
        brightness: Brightness.light,
        primary: AppColors.primary,
        onPrimary: AppColors.onPrimary,
        primaryContainer: AppColors.primaryLight,
        onPrimaryContainer: AppColors.primaryDark,
        secondary: AppColors.accent,
        onSecondary: AppColors.onAccent,
        secondaryContainer: Color(0xFFFDE2EC),
        onSecondaryContainer: Color(0xFF7C2454),
        tertiary: AppColors.info,
        onTertiary: AppColors.onInfo,
        tertiaryContainer: Color(0xFFD8E6FD),
        onTertiaryContainer: Color(0xFF0F4C81),
        error: AppColors.error,
        onError: AppColors.onError,
        errorContainer: Color(0xFFFFDAD6),
        onErrorContainer: Color(0xFF410002),
        surface: AppColors.backgroundLight, // Was background
        onSurface: AppColors.onSurfaceLight, // Was onBackground
        surfaceContainerHighest: AppColors.borderLight, // Was surfaceVariant
        onSurfaceVariant: AppColors.onSurfaceVariantLight,
        outline: AppColors.borderLight,
        outlineVariant: Color(0xFFCAC4D0),
        shadow: Color(0x1A000000), // Colors.black.withOpacity(0.1)
        scrim: Color(0x4D000000),  // Colors.black.withOpacity(0.3)
        inverseSurface: AppColors.surfaceDark,
        onInverseSurface: AppColors.onSurfaceDark,
        inversePrimary: AppColors.primaryDark,
        surfaceTint: AppColors.primary,
      ),
      textTheme: _buildTextTheme(base: ThemeData.light().textTheme, onSurfaceColor: AppColors.onSurfaceLight),
      appBarTheme: const AppBarTheme(
        elevation: 0,
        backgroundColor: AppColors.backgroundLight,
        foregroundColor: AppColors.onSurfaceLight,
        systemOverlayStyle: SystemUiOverlayStyle.dark,
        titleTextStyle: AppTypography.titleLarge,
        iconTheme: IconThemeData(color: AppColors.onSurfaceLight),
      ),
      cardTheme: CardTheme(
        elevation: 1.0,
        color: AppColors.surfaceLight,
        surfaceTintColor: Colors.transparent,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(12.0),
          side: const BorderSide(color: AppColors.borderLight, width: 0.5),
        ),
        margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          backgroundColor: AppColors.primary,
          foregroundColor: AppColors.onPrimary,
          textStyle: AppTypography.labelLarge,
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24.0)),
          elevation: 2.0,
        ),
      ),
      textButtonTheme: TextButtonThemeData(
        style: TextButton.styleFrom(
          foregroundColor: AppColors.primary,
          textStyle: AppTypography.labelLarge.copyWith(fontWeight: FontWeight.w600),
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24.0)),
        ),
      ),
      inputDecorationTheme: InputDecorationTheme(
        filled: true,
        fillColor: const Color(0x80FFFFFF), // AppColors.surfaceLight.withOpacity(0.5)
        contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12.0),
          borderSide: const BorderSide(color: AppColors.borderLight),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12.0),
          borderSide: const BorderSide(color: AppColors.borderLight),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12.0),
          borderSide: const BorderSide(color: AppColors.primary, width: 2.0),
        ),
        errorBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12.0),
          borderSide: const BorderSide(color: AppColors.error, width: 1.5),
        ),
        focusedErrorBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12.0),
          borderSide: const BorderSide(color: AppColors.error, width: 2.0),
        ),
        labelStyle: AppTypography.bodyMedium.copyWith(color: AppColors.onSurfaceVariantLight),
        hintStyle: AppTypography.bodyMedium.copyWith(color: AppColors.onSurfaceVariantLight.withOpacity(0.7)), // Kept withOpacity as it's not const
        floatingLabelStyle: AppTypography.bodySmall.copyWith(color: AppColors.primary),
      ),
      chipTheme: ChipThemeData(
        backgroundColor: AppColors.borderLight,
        selectedColor: AppColors.primary,
        labelStyle: AppTypography.labelMedium.copyWith(color: AppColors.onSurfaceVariantLight),
        secondaryLabelStyle: AppTypography.labelMedium.copyWith(color: AppColors.onPrimary),
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20.0)),
        iconTheme: const IconThemeData(color: AppColors.onSurfaceVariantLight, size: 18),
      ),
      floatingActionButtonTheme: const FloatingActionButtonThemeData(
        backgroundColor: AppColors.primary,
        foregroundColor: AppColors.onPrimary,
        elevation: 4.0,
      ),
      bottomNavigationBarTheme: BottomNavigationBarThemeData(
        backgroundColor: AppColors.surfaceLight,
        selectedItemColor: AppColors.primary,
        unselectedItemColor: AppColors.onSurfaceVariantLight,
        selectedLabelStyle: AppTypography.labelSmall,
        unselectedLabelStyle: AppTypography.labelSmall,
        elevation: 2.0,
      ),
    );
  }

  static ThemeData get darkTheme {
    return ThemeData(
      useMaterial3: true,
      brightness: Brightness.dark,
      fontFamily: AppTypography.fontFamily,
      primaryColor: AppColors.primary,
      scaffoldBackgroundColor: AppColors.backgroundDark,
      colorScheme: const ColorScheme(
        brightness: Brightness.dark,
        primary: AppColors.primaryLight,
        onPrimary: AppColors.onPrimary,
        primaryContainer: AppColors.primaryDark,
        onPrimaryContainer: AppColors.primaryLight,
        secondary: AppColors.accent,
        onSecondary: AppColors.onAccent,
        secondaryContainer: Color(0xFF7C2454),
        onSecondaryContainer: Color(0xFFFDE2EC),
        tertiary: AppColors.info,
        onTertiary: AppColors.onInfo,
        tertiaryContainer: Color(0xFF0F4C81),
        onTertiaryContainer: Color(0xFFD8E6FD),
        error: AppColors.error,
        onError: AppColors.onError,
        errorContainer: Color(0xFF93000A),
        onErrorContainer: Color(0xFFFFDAD6),
        surface: AppColors.backgroundDark, // Was background
        onSurface: AppColors.onSurfaceDark, // Was onBackground
        surfaceContainerHighest: AppColors.borderDark, // Was surfaceVariant
        onSurfaceVariant: AppColors.onSurfaceVariantDark,
        outline: AppColors.borderDark,
        outlineVariant: Color(0xFF49454F),
        shadow: Color(0x33000000), // Colors.black.withOpacity(0.2)
        scrim: Color(0x66000000),  // Colors.black.withOpacity(0.4)
        inverseSurface: AppColors.surfaceLight,
        onInverseSurface: AppColors.onSurfaceLight,
        inversePrimary: AppColors.primary,
        surfaceTint: AppColors.primaryLight,
      ),
      textTheme: _buildTextTheme(base: ThemeData.dark().textTheme, onSurfaceColor: AppColors.onSurfaceDark),
      appBarTheme: const AppBarTheme(
        elevation: 0,
        backgroundColor: AppColors.backgroundDark,
        foregroundColor: AppColors.onSurfaceDark,
        systemOverlayStyle: SystemUiOverlayStyle.light,
        titleTextStyle: AppTypography.titleLarge,
        iconTheme: IconThemeData(color: AppColors.onSurfaceDark),
      ),
      cardTheme: CardTheme(
        elevation: 1.0,
        color: AppColors.surfaceDark,
        surfaceTintColor: Colors.transparent,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(12.0),
          side: const BorderSide(color: AppColors.borderDark, width: 0.5),
        ),
        margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          backgroundColor: AppColors.primaryLight,
          foregroundColor: AppColors.primaryDark,
          textStyle: AppTypography.labelLarge,
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24.0)),
          elevation: 2.0,
        ),
      ),
      textButtonTheme: TextButtonThemeData(
        style: TextButton.styleFrom(
          foregroundColor: AppColors.primaryLight,
          textStyle: AppTypography.labelLarge.copyWith(fontWeight: FontWeight.w600),
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24.0)),
        ),
      ),
       inputDecorationTheme: InputDecorationTheme(
        filled: true,
        fillColor: const Color(0x801F2937), // AppColors.surfaceDark.withOpacity(0.5)
        contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12.0),
          borderSide: const BorderSide(color: AppColors.borderDark),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12.0),
          borderSide: const BorderSide(color: AppColors.borderDark),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12.0),
          borderSide: const BorderSide(color: AppColors.primaryLight, width: 2.0),
        ),
        errorBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12.0),
          borderSide: const BorderSide(color: AppColors.error, width: 1.5),
        ),
        focusedErrorBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12.0),
          borderSide: const BorderSide(color: AppColors.error, width: 2.0),
        ),
        labelStyle: AppTypography.bodyMedium.copyWith(color: AppColors.onSurfaceVariantDark),
        hintStyle: AppTypography.bodyMedium.copyWith(color: AppColors.onSurfaceVariantDark.withOpacity(0.7)), // Kept withOpacity
        floatingLabelStyle: AppTypography.bodySmall.copyWith(color: AppColors.primaryLight),
      ),
      chipTheme: ChipThemeData(
        backgroundColor: AppColors.borderDark,
        selectedColor: AppColors.primaryLight,
        labelStyle: AppTypography.labelMedium.copyWith(color: AppColors.onSurfaceVariantDark),
        secondaryLabelStyle: AppTypography.labelMedium.copyWith(color: AppColors.primaryDark),
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20.0)),
        iconTheme: const IconThemeData(color: AppColors.onSurfaceVariantDark, size: 18),
      ),
      floatingActionButtonTheme: const FloatingActionButtonThemeData(
        backgroundColor: AppColors.primaryLight,
        foregroundColor: AppColors.primaryDark,
        elevation: 4.0,
      ),
      bottomNavigationBarTheme: BottomNavigationBarThemeData(
        backgroundColor: AppColors.surfaceDark,
        selectedItemColor: AppColors.primaryLight,
        unselectedItemColor: AppColors.onSurfaceVariantDark,
        selectedLabelStyle: AppTypography.labelSmall,
        unselectedLabelStyle: AppTypography.labelSmall,
        elevation: 2.0,
      ),
    );
  }

  static TextTheme _buildTextTheme({required TextTheme base, required Color onSurfaceColor}) {
    return base.copyWith(
      displayLarge: AppTypography.displayLarge.copyWith(color: onSurfaceColor),
      displayMedium: AppTypography.displayMedium.copyWith(color: onSurfaceColor),
      displaySmall: AppTypography.displaySmall.copyWith(color: onSurfaceColor),
      headlineLarge: AppTypography.headlineLarge.copyWith(color: onSurfaceColor),
      headlineMedium: AppTypography.headlineMedium.copyWith(color: onSurfaceColor),
      headlineSmall: AppTypography.headlineSmall.copyWith(color: onSurfaceColor),
      titleLarge: AppTypography.titleLarge.copyWith(color: onSurfaceColor),
      titleMedium: AppTypography.titleMedium.copyWith(color: onSurfaceColor),
      titleSmall: AppTypography.titleSmall.copyWith(color: onSurfaceColor),
      bodyLarge: AppTypography.bodyLarge.copyWith(color: onSurfaceColor),
      bodyMedium: AppTypography.bodyMedium.copyWith(color: onSurfaceColor),
      bodySmall: AppTypography.bodySmall.copyWith(color: onSurfaceColor),
      labelLarge: AppTypography.labelLarge.copyWith(color: onSurfaceColor),
      labelMedium: AppTypography.labelMedium.copyWith(color: onSurfaceColor),
      labelSmall: AppTypography.labelSmall.copyWith(color: onSurfaceColor),
    ).apply(
      bodyColor: onSurfaceColor,
      displayColor: onSurfaceColor,
    );
  }
}

extension SemanticThemeColors on ThemeData {
  Color get success => brightness == Brightness.light ? AppColors.success : AppColors.success; 
  Color get onSuccess => brightness == Brightness.light ? AppColors.onSuccess : AppColors.onSuccess;
  Color get warning => brightness == Brightness.light ? AppColors.warning : AppColors.warning;
  Color get onWarning => brightness == Brightness.light ? AppColors.onWarning : AppColors.onWarning;
  Color get info => brightness == Brightness.light ? AppColors.info : AppColors.info;
  Color get onInfo => brightness == Brightness.light ? AppColors.onInfo : AppColors.onInfo;
}

===== FILE: app_typography.dart =====
===== PATH: lib/core/theme/app_typography.dart =====

import 'package:flutter/material.dart';

// This class is not meant to be instantiated.
// It holds static TextStyle definitions for the app, based on Material Design 3.
// The font family 'Inter' is assumed to be set in pubspec.yaml and main theme.
abstract class AppTypography {
  static const String fontFamily = 'Inter';

  // Display Styles
  static const TextStyle displayLarge = TextStyle(
    fontFamily: fontFamily,
    fontSize: 57,
    fontWeight: FontWeight.w400,
    letterSpacing: -0.25,
    height: 1.12, // 64px line height
  );
  static const TextStyle displayMedium = TextStyle(
    fontFamily: fontFamily,
    fontSize: 45,
    fontWeight: FontWeight.w400,
    letterSpacing: 0,
    height: 1.15, // 52px line height
  );
  static const TextStyle displaySmall = TextStyle(
    fontFamily: fontFamily,
    fontSize: 36,
    fontWeight: FontWeight.w400,
    letterSpacing: 0,
    height: 1.22, // 44px line height
  );

  // Headline Styles
  static const TextStyle headlineLarge = TextStyle(
    fontFamily: fontFamily,
    fontSize: 32,
    fontWeight: FontWeight.w400,
    letterSpacing: 0,
    height: 1.25, // 40px line height
  );
  static const TextStyle headlineMedium = TextStyle(
    fontFamily: fontFamily,
    fontSize: 28,
    fontWeight: FontWeight.w400,
    letterSpacing: 0,
    height: 1.28, // 36px line height
  );
  static const TextStyle headlineSmall = TextStyle(
    fontFamily: fontFamily,
    fontSize: 24,
    fontWeight: FontWeight.w400,
    letterSpacing: 0,
    height: 1.33, // 32px line height
  );

  // Title Styles
  static const TextStyle titleLarge = TextStyle(
    fontFamily: fontFamily,
    fontSize: 22,
    fontWeight: FontWeight.w500, // Medium weight for titles
    letterSpacing: 0,
    height: 1.27, // 28px line height
  );
  static const TextStyle titleMedium = TextStyle(
    fontFamily: fontFamily,
    fontSize: 16,
    fontWeight: FontWeight.w500,
    letterSpacing: 0.15,
    height: 1.5, // 24px line height
  );
  static const TextStyle titleSmall = TextStyle(
    fontFamily: fontFamily,
    fontSize: 14,
    fontWeight: FontWeight.w500,
    letterSpacing: 0.1,
    height: 1.43, // 20px line height
  );

  // Label Styles
  static const TextStyle labelLarge = TextStyle(
    fontFamily: fontFamily,
    fontSize: 14,
    fontWeight: FontWeight.w500,
    letterSpacing: 0.1,
    height: 1.43, // 20px line height
  );
  static const TextStyle labelMedium = TextStyle(
    fontFamily: fontFamily,
    fontSize: 12,
    fontWeight: FontWeight.w500,
    letterSpacing: 0.5,
    height: 1.33, // 16px line height
  );
  static const TextStyle labelSmall = TextStyle(
    fontFamily: fontFamily,
    fontSize: 11,
    fontWeight: FontWeight.w500,
    letterSpacing: 0.5,
    height: 1.45, // 16px line height
  );

  // Body Styles
  static const TextStyle bodyLarge = TextStyle(
    fontFamily: fontFamily,
    fontSize: 16,
    fontWeight: FontWeight.w400,
    letterSpacing: 0.5,
    height: 1.5, // 24px line height
  );
  static const TextStyle bodyMedium = TextStyle(
    fontFamily: fontFamily,
    fontSize: 14,
    fontWeight: FontWeight.w400,
    letterSpacing: 0.25,
    height: 1.43, // 20px line height
  );
  static const TextStyle bodySmall = TextStyle(
    fontFamily: fontFamily,
    fontSize: 12,
    fontWeight: FontWeight.w400,
    letterSpacing: 0.4,
    height: 1.33, // 16px line height
  );
}

===== FILE: color_serializer.dart =====
===== PATH: lib/core/utils/color_serializer.dart =====

import 'package:flutter/material.dart';
import 'package:json_annotation/json_annotation.dart';

class ColorSerializer implements JsonConverter<Color?, int?> {
  const ColorSerializer();

  @override
  Color? fromJson(int? json) {
    return json == null ? null : Color(json);
  }

  @override
  int? toJson(Color? color) {
    return color?.value;
  }
}

===== FILE: currency_formatter.dart =====
===== PATH: lib/core/utils/currency_formatter.dart =====

import 'package:intl/intl.dart';
import 'package:flutter/material.dart'; // For Locale

class CurrencyFormatter {
  static String format(
    double amount, {
    required String currencyCode, 
    Locale? locale,             
    int? decimalDigits,         
  }) {
    String localeString;
    if (locale != null) {
      localeString = locale.toLanguageTag().replaceAll('-', '_');
    } else {
      switch (currencyCode.toUpperCase()) {
        case 'USD':
        case 'CAD':
        case 'AUD':
          localeString = 'en_US';
          break;
        case 'EUR':
          localeString = 'de_DE'; 
          break;
        case 'GBP':
          localeString = 'en_GB';
          break;
        case 'JPY':
          localeString = 'ja_JP';
          break;
        case 'CHF':
          localeString = 'de_CH';
          break;
        default:
          localeString = 'en_US'; 
      }
    }

    try {
      final format = NumberFormat.currency(
        locale: localeString,
        symbol: getCurrencySymbol(currencyCode), 
        decimalDigits: decimalDigits ?? _getDefaultDecimalDigits(currencyCode),
      );
      return format.format(amount);
    } catch (e) {
      // print("Currency formatting error for $currencyCode with locale $localeString: $e"); // Avoid print
      return '${getCurrencySymbol(currencyCode)}${amount.toStringAsFixed(decimalDigits ?? 2)}';
    }
  }

  static String getCurrencySymbol(String currencyCode) {
    final Map<String, String> symbols = {
      'USD': '\$',
      'EUR': '€',
      'GBP': '£',
      'JPY': '¥',
      'CHF': 'CHF', 
      'CAD': 'CA\$',
      'AUD': 'A\$',
    };
    return symbols[currencyCode.toUpperCase()] ?? currencyCode;
  }

  static int _getDefaultDecimalDigits(String currencyCode) {
    switch (currencyCode.toUpperCase()) {
      case 'JPY':
        return 0; 
      case 'USD':
      case 'EUR':
      case 'GBP':
      case 'CHF':
      case 'CAD':
      case 'AUD':
      default:
        return 2;
    }
  }

  static double? tryParse(String formattedAmount) {
    String cleaned = formattedAmount
        .replaceAll(RegExp(r'[$\€£¥CHF]'), '') 
        .replaceAll(',', '') 
        .trim();
    return double.tryParse(cleaned);
  }
}

===== FILE: date_formatter.dart =====
===== PATH: lib/core/utils/date_formatter.dart =====

import 'package:intl/intl.dart';
import 'package:flutter/material.dart'; // For Locale

class DateFormatter {
  static String formatDate(DateTime? date, {Locale? locale}) {
    if (date == null) return 'N/A'; 
    final String localeString = locale?.toLanguageTag().replaceAll('-', '_') ?? 'en_US'; 
    return DateFormat('dd MMM, yyyy', localeString).format(date);
  }

  static String formatShortDate(DateTime? date, {Locale? locale}) {
    if (date == null) return 'N/A';
    final String localeString = locale?.toLanguageTag().replaceAll('-', '_') ?? 'en_US';
    return DateFormat.yMd(localeString).format(date); 
  }
  
  static String formatMonthYear(DateTime? date, {Locale? locale}) {
    if (date == null) return 'N/A';
    final String localeString = locale?.toLanguageTag().replaceAll('-', '_') ?? 'en_US';
    return DateFormat.yMMMM(localeString).format(date); 
  }

  static String formatDaysUntil(DateTime date, {Locale? locale, String? overdueText, String? todayText, String? tomorrowText, String? daysAgoText, String? daysFutureText}) {
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    final targetDay = DateTime(date.year, date.month, date.day);
    final differenceInDays = targetDay.difference(today).inDays;

    // final String currentOverdueText = overdueText ?? '{days} days ago'; // Variable was unused
    final currentTodayText = todayText ?? 'Today';
    final currentTomorrowText = tomorrowText ?? 'Tomorrow';
    final currentDaysAgoText = daysAgoText ?? '{days} days ago'; 
    final currentDaysFutureText = daysFutureText ?? 'in {days} days';

    if (differenceInDays < 0) {
      return currentDaysAgoText.replaceAll('{days}', differenceInDays.abs().toString());
    } else if (differenceInDays == 0) {
      return currentTodayText;
    } else if (differenceInDays == 1) {
      return currentTomorrowText;
    } else {
      return currentDaysFutureText.replaceAll('{days}', differenceInDays.toString());
    }
  }

  static String formatTime(DateTime? time, {Locale? locale}) {
    if (time == null) return 'N/A';
    final String localeString = locale?.toLanguageTag().replaceAll('-', '_') ?? 'en_US';
    return DateFormat.jm(localeString).format(time); 
  }

  static String formatDateTime(DateTime? dateTime, {Locale? locale}) {
    if (dateTime == null) return 'N/A';
    final String localeString = locale?.toLanguageTag().replaceAll('-', '_') ?? 'en_US';
    return DateFormat.yMMMMEEEEd(localeString).add_jm().format(dateTime); 
  }
}

===== FILE: haptic_feedback.dart =====
===== PATH: lib/core/utils/haptic_feedback.dart =====

import 'package:flutter/services.dart';

/// A utility class for providing haptic feedback.
/// This wraps the standard Flutter HapticFeedback methods for consistent use.
class HapticFeedback {
  HapticFeedback._(); // Private constructor to prevent instantiation.

  /// Provides a light haptic feedback.
  /// Typically used for minor interactions or successes.
  static Future<void> lightImpact() async {
    await SystemChannels.platform.invokeMethod<void>('HapticFeedback.vibrate', 'HapticFeedbackType.lightImpact');
    // Or using the direct method if you prefer and it suits your Flutter version's direct support:
    // await SystemSound.play(SystemSoundType.click); // This is more of a sound, but often used similarly
    // await HapticFeedback.lightImpact(); // Use this if your Flutter version has it directly and it's reliable.
  }

  /// Provides a medium haptic feedback.
  /// Suitable for more significant actions or confirmations.
  static Future<void> mediumImpact() async {
    await SystemChannels.platform.invokeMethod<void>('HapticFeedback.vibrate', 'HapticFeedbackType.mediumImpact');
    // await HapticFeedback.mediumImpact();
  }

  /// Provides a heavy haptic feedback.
  /// Best reserved for critical actions or errors.
  static Future<void> heavyImpact() async {
    await SystemChannels.platform.invokeMethod<void>('HapticFeedback.vibrate', 'HapticFeedbackType.heavyImpact');
    // await HapticFeedback.heavyImpact();
  }

  /// Provides a haptic feedback for a selection change.
  /// Commonly used in pickers or when an item selection changes.
  static Future<void> selectionClick() async {
    await SystemChannels.platform.invokeMethod<void>('HapticFeedback.vibrate', 'HapticFeedbackType.selectionClick');
    // await HapticFeedback.selectionClick();
  }

  /// Provides a warning haptic feedback pattern (not standard on all platforms).
  /// If specific warning patterns are needed, they might require platform-specific implementations
  /// or a plugin that offers more advanced haptics.
  /// For a simple alternative, you might use heavyImpact or a custom short vibration sequence.
  static Future<void> warningImpact() async {
    // iOS often has specific notification feedback types (success, warning, error)
    // Android is more generic. Heavy impact can serve as a general strong feedback.
    await heavyImpact(); 
  }
}

===== FILE: onboarding_screen.dart =====
===== PATH: lib/features/onboarding/presentation/screens/onboarding_screen.dart =====

import 'package:aboapp/core/routing/app_router.dart';
import 'package:aboapp/features/onboarding/presentation/widgets/onboarding_page_content_widget.dart';
import 'package:aboapp/features/onboarding/presentation/widgets/page_indicator_widget.dart';
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:aboapp/core/di/injection.dart'; 

class OnboardingScreen extends StatefulWidget {
  const OnboardingScreen({super.key});

  @override
  State<OnboardingScreen> createState() => _OnboardingScreenState();
}

class _OnboardingScreenData {
  final String titleKey;
  final String descriptionKey;
  final IconData iconData;
  final Color iconColor;

  _OnboardingScreenData({
    required this.titleKey,
    required this.descriptionKey,
    required this.iconData,
    required this.iconColor,
  });
}

class _OnboardingScreenState extends State<OnboardingScreen> {
  final PageController _pageController = PageController();
  int _currentPageIndex = 0;

  late final List<_OnboardingScreenData> _onboardingPages;


  @override
  void initState() {
    super.initState();
    // Initialized here because context is needed for Theme.of(context)
    // Deferring full context-dependent initialization to build or didChangeDependencies might be safer for Theme access
    // For now, direct color usage is replaced for simplicity for this fix.
    // It's better to initialize this in didChangeDependencies if theme colors are used.
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    // Initialize _onboardingPages here if they depend on Theme.of(context)
     _onboardingPages = [
      _OnboardingScreenData(
        titleKey: 'onboarding_page1_title',
        descriptionKey: 'onboarding_page1_desc',
        iconData: Icons.account_balance_wallet_outlined,
        iconColor: Theme.of(context).colorScheme.primary, 
      ),
      _OnboardingScreenData(
        titleKey: 'onboarding_page2_title',
        descriptionKey: 'onboarding_page2_desc', 
        iconData: Icons.add_circle_outline_rounded,
        iconColor: Colors.green.shade600,
      ),
      _OnboardingScreenData(
        titleKey: 'onboarding_page3_title',
        descriptionKey: 'onboarding_page3_desc',
        iconData: Icons.pie_chart_outline_rounded,
        iconColor: Colors.orange.shade700,
      ),
      _OnboardingScreenData(
        titleKey: 'onboarding_page4_title',
        descriptionKey: 'onboarding_page4_desc',
        iconData: Icons.notifications_active_outlined,
        iconColor: Colors.purple.shade600,
      ),
    ];
  }


  @override
  void dispose() {
    _pageController.dispose();
    super.dispose();
  }

  Future<void> _completeOnboarding() async {
    final prefs = getIt<SharedPreferences>();
    await prefs.setBool('onboarding_complete', true);
    if (mounted) {
      context.goNamed(AppRoutes.home);
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Scaffold(
      body: SafeArea(
        child: Column(
          children: <Widget>[
            if (_currentPageIndex < _onboardingPages.length - 1)
              Align(
                alignment: Alignment.topRight,
                child: Padding(
                  padding: const EdgeInsets.only(top: 8.0, right: 16.0),
                  child: TextButton(
                    onPressed: _completeOnboarding,
                    child: Text('Skip', style: TextStyle(color: theme.colorScheme.primary)), 
                  ),
                ),
              )
            else
              const SizedBox(height: 56), 

            Expanded(
              child: PageView.builder(
                controller: _pageController,
                itemCount: _onboardingPages.length,
                onPageChanged: (index) {
                  setState(() {
                    _currentPageIndex = index;
                  });
                },
                itemBuilder: (context, index) {
                  final pageData = _onboardingPages[index];
                  return OnboardingPageContentWidget(
                    title: pageData.titleKey.replaceAll('_', ' ').split(' ').map((e) => e[0].toUpperCase() + e.substring(1)).join(' '), 
                    description: pageData.descriptionKey.replaceAll('_', ' ').split(' ').map((e) => e[0].toUpperCase() + e.substring(1)).join(' '), 
                    iconData: pageData.iconData,
                    iconColor: pageData.iconColor,
                  );
                },
              ),
            ),

            Padding(
              padding: const EdgeInsets.symmetric(vertical: 24.0),
              child: PageIndicatorWidget(
                currentPageIndex: _currentPageIndex,
                pageCount: _onboardingPages.length,
                activeColor: theme.colorScheme.primary,
                inactiveColor: theme.colorScheme.onSurface.withOpacity(0.2), // Kept withOpacity for non-const dynamic color
              ),
            ),

            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 24.0, vertical: 16.0),
              child: SizedBox(
                width: double.infinity,
                child: ElevatedButton(
                  style: ElevatedButton.styleFrom(
                    padding: const EdgeInsets.symmetric(vertical: 16.0),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(30.0),
                    ),
                  ),
                  onPressed: () {
                    if (_currentPageIndex < _onboardingPages.length - 1) {
                      _pageController.nextPage(
                        duration: const Duration(milliseconds: 400),
                        curve: Curves.easeInOut,
                      );
                    } else {
                      _completeOnboarding();
                    }
                  },
                  child: Text(
                    _currentPageIndex < _onboardingPages.length - 1
                        ? 'Next' 
                        : 'Get Started', 
                    style: theme.textTheme.labelLarge?.copyWith(fontWeight: FontWeight.bold),
                  ),
                ),
              ),
            ),
            const SizedBox(height: 16), 
          ],
        ),
      ),
    );
  }
}

===== FILE: onboarding_page_content_widget.dart =====
===== PATH: lib/features/onboarding/presentation/widgets/onboarding_page_content_widget.dart =====

import 'package:flutter/material.dart';

class OnboardingPageContentWidget extends StatelessWidget {
  final String title;
  final String description;
  final IconData iconData; // Using IconData for simplicity
  final Color iconColor;   // Color for the icon and its background accent

  const OnboardingPageContentWidget({
    super.key,
    required this.title,
    required this.description,
    required this.iconData,
    required this.iconColor,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final screenSize = MediaQuery.of(context).size;

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 32.0, vertical: 24.0),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        crossAxisAlignment: CrossAxisAlignment.center,
        children: <Widget>[
          Container(
            width: screenSize.width * 0.4, // Responsive icon container
            height: screenSize.width * 0.4,
            decoration: BoxDecoration(
              color: iconColor.withOpacity(0.15), // Subtle background
              shape: BoxShape.circle,
            ),
            child: Icon(
              iconData,
              size: screenSize.width * 0.2, // Responsive icon size
              color: iconColor,
            ),
          ),
          const SizedBox(height: 48.0),
          Text(
            title,
            textAlign: TextAlign.center,
            style: theme.textTheme.headlineSmall?.copyWith(
              fontWeight: FontWeight.bold,
              color: theme.colorScheme.onBackground,
            ),
          ),
          const SizedBox(height: 16.0),
          Text(
            description,
            textAlign: TextAlign.center,
            style: theme.textTheme.bodyLarge?.copyWith(
              color: theme.colorScheme.onSurfaceVariant,
              height: 1.5, // Improved line spacing
            ),
          ),
        ],
      ),
    );
  }
}

===== FILE: page_indicator_widget.dart =====
===== PATH: lib/features/onboarding/presentation/widgets/page_indicator_widget.dart =====

import 'package:flutter/material.dart';

class PageIndicatorWidget extends StatelessWidget {
  final int currentPageIndex;
  final int pageCount;
  final Color activeColor;
  final Color inactiveColor;

  const PageIndicatorWidget({
    super.key,
    required this.currentPageIndex,
    required this.pageCount,
    required this.activeColor,
    required this.inactiveColor,
  });

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      children: List.generate(pageCount, (index) {
        return AnimatedContainer(
          duration: const Duration(milliseconds: 300),
          curve: Curves.easeOutCubic,
          margin: const EdgeInsets.symmetric(horizontal: 4.0),
          width: currentPageIndex == index ? 24.0 : 8.0, // Active indicator is wider
          height: 8.0,
          decoration: BoxDecoration(
            color: currentPageIndex == index ? activeColor : inactiveColor,
            borderRadius: BorderRadius.circular(4.0),
          ),
        );
      }),
    );
  }
}

===== FILE: settings_local_datasource.dart =====
===== PATH: lib/features/settings/data/datasources/settings_local_datasource.dart =====

import 'dart:convert';
import 'package:aboapp/features/settings/data/models/settings_model.dart';
import 'package:aboapp/features/settings/domain/entities/settings_entity.dart'; 
import 'package:flutter/material.dart'; 
import 'package:injectable/injectable.dart';
import 'package:shared_preferences/shared_preferences.dart';

abstract class SettingsLocalDataSource {
  Future<SettingsModel> getSettings();
  Future<void> saveThemeMode(ThemeMode themeMode);
  Future<void> saveLocale(Locale locale);
  Future<void> saveCurrencyCode(String currencyCode);
}

const String settingsKey = 'APP_SETTINGS';
const String themeModeKey = 'APP_THEME_MODE';
const String localeLangKey = 'APP_LOCALE_LANG';
const String localeCountryKey = 'APP_LOCALE_COUNTRY';
const String currencyCodeKey = 'APP_CURRENCY_CODE';


@LazySingleton(as: SettingsLocalDataSource)
class SettingsLocalDataSourceImpl implements SettingsLocalDataSource {
  final SharedPreferences sharedPreferences;

  SettingsLocalDataSourceImpl(this.sharedPreferences);

  @override
  Future<SettingsModel> getSettings() async {
    final jsonString = sharedPreferences.getString(settingsKey);
    if (jsonString != null) {
      try {
        return SettingsModel.fromJson(jsonDecode(jsonString) as Map<String, dynamic>);
      } catch (e) {
        // print('Error parsing settings from SharedPreferences: $e'); // Avoid print
        await sharedPreferences.remove(settingsKey);
        return SettingsModel.fromEntity(SettingsEntity.defaultSettings());
      }
    } else {
      return SettingsModel.fromEntity(SettingsEntity.defaultSettings());
    }
  }

  Future<void> _saveSettingsModel(SettingsModel settings) async {
    await sharedPreferences.setString(settingsKey, jsonEncode(settings.toJson()));
  }

  @override
  Future<void> saveThemeMode(ThemeMode themeMode) async {
    final currentSettings = await getSettings();
    await _saveSettingsModel(currentSettings.copyWith(themeMode: themeMode));
  }

  @override
  Future<void> saveLocale(Locale locale) async {
    final currentSettings = await getSettings();
    await _saveSettingsModel(currentSettings.copyWith(locale: locale));
  }

  @override
  Future<void> saveCurrencyCode(String currencyCode) async {
    final currentSettings = await getSettings();
    await _saveSettingsModel(currentSettings.copyWith(currencyCode: currencyCode));
  }
}

===== FILE: settings_model.dart =====
===== PATH: lib/features/settings/data/models/settings_model.dart =====

import 'package:aboapp/features/settings/domain/entities/settings_entity.dart';
import 'package:flutter/material.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

part 'settings_model.freezed.dart';
part 'settings_model.g.dart';

// --- Custom converters (no changes) ---
class ThemeModeConverter implements JsonConverter<ThemeMode, String> {
  const ThemeModeConverter();
  @override
  ThemeMode fromJson(String json) => ThemeMode.values
      .firstWhere((e) => e.toString() == json, orElse: () => ThemeMode.system);
  @override
  String toJson(ThemeMode object) => object.toString();
}

class LocaleConverter implements JsonConverter<Locale, String> {
  const LocaleConverter();
  @override
  Locale fromJson(String json) {
    final parts = json.split('_');
    return parts.length == 2 ? Locale(parts[0], parts[1]) : Locale(parts[0]);
  }

  @override
  String toJson(Locale object) => object.toLanguageTag().replaceAll('-', '_');
}

// --- End of converters ---

@freezed
// ANNOTATION MOVED TO THE CLASS ITSELF
@JsonSerializable(explicitToJson: true)
class SettingsModel with _$SettingsModel {
  // NO PRIVATE CONSTRUCTOR HERE

  const factory SettingsModel({
    @ThemeModeConverter() required ThemeMode themeMode,
    @LocaleConverter() required Locale locale,
    required String currencyCode,
  }) = _SettingsModel;

  factory SettingsModel.fromJson(Map<String, dynamic> json) =>
      _$SettingsModelFromJson(json);

  // Helper methods are outside the Freezed class definition
  // We will make them extensions instead for cleanliness.
}

// --- Helper methods moved to extensions ---
extension SettingsModelHelpers on SettingsModel {
  SettingsEntity toEntity() {
    return SettingsEntity(
      themeMode: themeMode,
      locale: locale,
      currencyCode: currencyCode,
    );
  }
}

extension SettingsModelFromEntity on SettingsModel {
  static SettingsModel fromEntity(SettingsEntity entity) {
    return SettingsModel(
      themeMode: entity.themeMode,
      locale: entity.locale,
      currencyCode: entity.currencyCode,
    );
  }
}


===== FILE: settings_model.freezed.dart =====
===== PATH: lib/features/settings/data/models/settings_model.freezed.dart =====

// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'settings_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

SettingsModel _$SettingsModelFromJson(Map<String, dynamic> json) {
  return _SettingsModel.fromJson(json);
}

/// @nodoc
mixin _$SettingsModel {
  @ThemeModeConverter()
  ThemeMode get themeMode => throw _privateConstructorUsedError;
  @LocaleConverter()
  Locale get locale => throw _privateConstructorUsedError;
  String get currencyCode => throw _privateConstructorUsedError;

  /// Serializes this SettingsModel to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of SettingsModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SettingsModelCopyWith<SettingsModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SettingsModelCopyWith<$Res> {
  factory $SettingsModelCopyWith(
          SettingsModel value, $Res Function(SettingsModel) then) =
      _$SettingsModelCopyWithImpl<$Res, SettingsModel>;
  @useResult
  $Res call(
      {@ThemeModeConverter() ThemeMode themeMode,
      @LocaleConverter() Locale locale,
      String currencyCode});
}

/// @nodoc
class _$SettingsModelCopyWithImpl<$Res, $Val extends SettingsModel>
    implements $SettingsModelCopyWith<$Res> {
  _$SettingsModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SettingsModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? themeMode = null,
    Object? locale = null,
    Object? currencyCode = null,
  }) {
    return _then(_value.copyWith(
      themeMode: null == themeMode
          ? _value.themeMode
          : themeMode // ignore: cast_nullable_to_non_nullable
              as ThemeMode,
      locale: null == locale
          ? _value.locale
          : locale // ignore: cast_nullable_to_non_nullable
              as Locale,
      currencyCode: null == currencyCode
          ? _value.currencyCode
          : currencyCode // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SettingsModelImplCopyWith<$Res>
    implements $SettingsModelCopyWith<$Res> {
  factory _$$SettingsModelImplCopyWith(
          _$SettingsModelImpl value, $Res Function(_$SettingsModelImpl) then) =
      __$$SettingsModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@ThemeModeConverter() ThemeMode themeMode,
      @LocaleConverter() Locale locale,
      String currencyCode});
}

/// @nodoc
class __$$SettingsModelImplCopyWithImpl<$Res>
    extends _$SettingsModelCopyWithImpl<$Res, _$SettingsModelImpl>
    implements _$$SettingsModelImplCopyWith<$Res> {
  __$$SettingsModelImplCopyWithImpl(
      _$SettingsModelImpl _value, $Res Function(_$SettingsModelImpl) _then)
      : super(_value, _then);

  /// Create a copy of SettingsModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? themeMode = null,
    Object? locale = null,
    Object? currencyCode = null,
  }) {
    return _then(_$SettingsModelImpl(
      themeMode: null == themeMode
          ? _value.themeMode
          : themeMode // ignore: cast_nullable_to_non_nullable
              as ThemeMode,
      locale: null == locale
          ? _value.locale
          : locale // ignore: cast_nullable_to_non_nullable
              as Locale,
      currencyCode: null == currencyCode
          ? _value.currencyCode
          : currencyCode // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$SettingsModelImpl implements _SettingsModel {
  const _$SettingsModelImpl(
      {@ThemeModeConverter() required this.themeMode,
      @LocaleConverter() required this.locale,
      required this.currencyCode});

  factory _$SettingsModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$SettingsModelImplFromJson(json);

  @override
  @ThemeModeConverter()
  final ThemeMode themeMode;
  @override
  @LocaleConverter()
  final Locale locale;
  @override
  final String currencyCode;

  @override
  String toString() {
    return 'SettingsModel(themeMode: $themeMode, locale: $locale, currencyCode: $currencyCode)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SettingsModelImpl &&
            (identical(other.themeMode, themeMode) ||
                other.themeMode == themeMode) &&
            (identical(other.locale, locale) || other.locale == locale) &&
            (identical(other.currencyCode, currencyCode) ||
                other.currencyCode == currencyCode));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, themeMode, locale, currencyCode);

  /// Create a copy of SettingsModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SettingsModelImplCopyWith<_$SettingsModelImpl> get copyWith =>
      __$$SettingsModelImplCopyWithImpl<_$SettingsModelImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$SettingsModelImplToJson(
      this,
    );
  }
}

abstract class _SettingsModel implements SettingsModel {
  const factory _SettingsModel(
      {@ThemeModeConverter() required final ThemeMode themeMode,
      @LocaleConverter() required final Locale locale,
      required final String currencyCode}) = _$SettingsModelImpl;

  factory _SettingsModel.fromJson(Map<String, dynamic> json) =
      _$SettingsModelImpl.fromJson;

  @override
  @ThemeModeConverter()
  ThemeMode get themeMode;
  @override
  @LocaleConverter()
  Locale get locale;
  @override
  String get currencyCode;

  /// Create a copy of SettingsModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SettingsModelImplCopyWith<_$SettingsModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}


===== FILE: settings_repository_impl.dart =====
===== PATH: lib/features/settings/data/repositories/settings_repository_impl.dart =====

import 'package:aboapp/features/settings/data/datasources/settings_local_datasource.dart';
import 'package:aboapp/features/settings/domain/entities/settings_entity.dart';
import 'package:aboapp/features/settings/domain/repositories/settings_repository.dart';
import 'package:flutter/material.dart'; 
import 'package:injectable/injectable.dart';

@LazySingleton(as: SettingsRepository)
class SettingsRepositoryImpl implements SettingsRepository {
  final SettingsLocalDataSource localDataSource;

  SettingsRepositoryImpl(this.localDataSource);

  @override
  Future<SettingsEntity> getSettings() async {
    try {
      final settingsModel = await localDataSource.getSettings();
      return settingsModel.toEntity();
    } catch (e) {
      // print('Error in SettingsRepositoryImpl.getSettings: $e'); // Avoid print
      return SettingsEntity.defaultSettings();
    }
  }

  @override
  Future<void> saveThemeMode(ThemeMode themeMode) async {
    await localDataSource.saveThemeMode(themeMode);
  }

  @override
  Future<void> saveLocale(Locale locale) async {
    await localDataSource.saveLocale(locale);
  }

  @override
  Future<void> saveCurrencyCode(String currencyCode) async {
    await localDataSource.saveCurrencyCode(currencyCode);
  }
}

===== FILE: settings_entity.dart =====
===== PATH: lib/features/settings/domain/entities/settings_entity.dart =====

import 'package:flutter/material.dart'; // For ThemeMode and Locale
import 'package:freezed_annotation/freezed_annotation.dart';

part 'settings_entity.freezed.dart';

@freezed
class SettingsEntity with _$SettingsEntity {
  const factory SettingsEntity({
    required ThemeMode themeMode,
    required Locale locale,
    required String currencyCode, // e.g., "USD", "EUR"
    // Add other app-wide settings here if needed
    // Example: bool enableNotificationsGlobally,
  }) = _SettingsEntity;

  // Default settings
  factory SettingsEntity.defaultSettings() => const SettingsEntity(
        themeMode: ThemeMode.system,
        locale: Locale('en', 'US'), // Default to English (US)
        currencyCode: 'USD', // Default to USD
      );
}

===== FILE: settings_entity.freezed.dart =====
===== PATH: lib/features/settings/domain/entities/settings_entity.freezed.dart =====

// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'settings_entity.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$SettingsEntity {
  ThemeMode get themeMode => throw _privateConstructorUsedError;
  Locale get locale => throw _privateConstructorUsedError;
  String get currencyCode => throw _privateConstructorUsedError;

  /// Create a copy of SettingsEntity
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SettingsEntityCopyWith<SettingsEntity> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SettingsEntityCopyWith<$Res> {
  factory $SettingsEntityCopyWith(
          SettingsEntity value, $Res Function(SettingsEntity) then) =
      _$SettingsEntityCopyWithImpl<$Res, SettingsEntity>;
  @useResult
  $Res call({ThemeMode themeMode, Locale locale, String currencyCode});
}

/// @nodoc
class _$SettingsEntityCopyWithImpl<$Res, $Val extends SettingsEntity>
    implements $SettingsEntityCopyWith<$Res> {
  _$SettingsEntityCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SettingsEntity
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? themeMode = null,
    Object? locale = null,
    Object? currencyCode = null,
  }) {
    return _then(_value.copyWith(
      themeMode: null == themeMode
          ? _value.themeMode
          : themeMode // ignore: cast_nullable_to_non_nullable
              as ThemeMode,
      locale: null == locale
          ? _value.locale
          : locale // ignore: cast_nullable_to_non_nullable
              as Locale,
      currencyCode: null == currencyCode
          ? _value.currencyCode
          : currencyCode // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SettingsEntityImplCopyWith<$Res>
    implements $SettingsEntityCopyWith<$Res> {
  factory _$$SettingsEntityImplCopyWith(_$SettingsEntityImpl value,
          $Res Function(_$SettingsEntityImpl) then) =
      __$$SettingsEntityImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({ThemeMode themeMode, Locale locale, String currencyCode});
}

/// @nodoc
class __$$SettingsEntityImplCopyWithImpl<$Res>
    extends _$SettingsEntityCopyWithImpl<$Res, _$SettingsEntityImpl>
    implements _$$SettingsEntityImplCopyWith<$Res> {
  __$$SettingsEntityImplCopyWithImpl(
      _$SettingsEntityImpl _value, $Res Function(_$SettingsEntityImpl) _then)
      : super(_value, _then);

  /// Create a copy of SettingsEntity
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? themeMode = null,
    Object? locale = null,
    Object? currencyCode = null,
  }) {
    return _then(_$SettingsEntityImpl(
      themeMode: null == themeMode
          ? _value.themeMode
          : themeMode // ignore: cast_nullable_to_non_nullable
              as ThemeMode,
      locale: null == locale
          ? _value.locale
          : locale // ignore: cast_nullable_to_non_nullable
              as Locale,
      currencyCode: null == currencyCode
          ? _value.currencyCode
          : currencyCode // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$SettingsEntityImpl implements _SettingsEntity {
  const _$SettingsEntityImpl(
      {required this.themeMode,
      required this.locale,
      required this.currencyCode});

  @override
  final ThemeMode themeMode;
  @override
  final Locale locale;
  @override
  final String currencyCode;

  @override
  String toString() {
    return 'SettingsEntity(themeMode: $themeMode, locale: $locale, currencyCode: $currencyCode)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SettingsEntityImpl &&
            (identical(other.themeMode, themeMode) ||
                other.themeMode == themeMode) &&
            (identical(other.locale, locale) || other.locale == locale) &&
            (identical(other.currencyCode, currencyCode) ||
                other.currencyCode == currencyCode));
  }

  @override
  int get hashCode => Object.hash(runtimeType, themeMode, locale, currencyCode);

  /// Create a copy of SettingsEntity
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SettingsEntityImplCopyWith<_$SettingsEntityImpl> get copyWith =>
      __$$SettingsEntityImplCopyWithImpl<_$SettingsEntityImpl>(
          this, _$identity);
}

abstract class _SettingsEntity implements SettingsEntity {
  const factory _SettingsEntity(
      {required final ThemeMode themeMode,
      required final Locale locale,
      required final String currencyCode}) = _$SettingsEntityImpl;

  @override
  ThemeMode get themeMode;
  @override
  Locale get locale;
  @override
  String get currencyCode;

  /// Create a copy of SettingsEntity
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SettingsEntityImplCopyWith<_$SettingsEntityImpl> get copyWith =>
      throw _privateConstructorUsedError;
}


===== FILE: settings_repository.dart =====
===== PATH: lib/features/settings/domain/repositories/settings_repository.dart =====

import 'package:aboapp/features/settings/domain/entities/settings_entity.dart';
import 'package:flutter/material.dart'; // For ThemeMode and Locale

abstract class SettingsRepository {
  Future<SettingsEntity> getSettings();
  Future<void> saveThemeMode(ThemeMode themeMode);
  Future<void> saveLocale(Locale locale);
  Future<void> saveCurrencyCode(String currencyCode);
  // Future<void> saveSettings(SettingsEntity settings); // Alternative: save all at once
}

===== FILE: get_settings_usecase.dart =====
===== PATH: lib/features/settings/domain/usecases/get_settings_usecase.dart =====

import 'package:aboapp/features/settings/domain/entities/settings_entity.dart';
import 'package:aboapp/features/settings/domain/repositories/settings_repository.dart';
import 'package:injectable/injectable.dart';

@lazySingleton
class GetSettingsUseCase {
  final SettingsRepository repository;

  GetSettingsUseCase(this.repository);

  Future<SettingsEntity> call() async {
    return await repository.getSettings();
  }
}

===== FILE: save_currency_setting_usecase.dart =====
===== PATH: lib/features/settings/domain/usecases/save_currency_setting_usecase.dart =====

import 'package:aboapp/features/settings/domain/repositories/settings_repository.dart';
import 'package:injectable/injectable.dart';

@lazySingleton
class SaveCurrencySettingUseCase {
  final SettingsRepository repository;

  SaveCurrencySettingUseCase(this.repository);

  Future<void> call(String currencyCode) async {
    return await repository.saveCurrencyCode(currencyCode);
  }
}

===== FILE: save_locale_setting_usecase.dart =====
===== PATH: lib/features/settings/domain/usecases/save_locale_setting_usecase.dart =====

import 'package:aboapp/features/settings/domain/repositories/settings_repository.dart';
import 'package:flutter/material.dart'; // For Locale
import 'package:injectable/injectable.dart';

@lazySingleton
class SaveLocaleSettingUseCase {
  final SettingsRepository repository;

  SaveLocaleSettingUseCase(this.repository);

  Future<void> call(Locale locale) async {
    return await repository.saveLocale(locale);
  }
}

===== FILE: save_theme_setting_usecase.dart =====
===== PATH: lib/features/settings/domain/usecases/save_theme_setting_usecase.dart =====

import 'package:aboapp/features/settings/domain/repositories/settings_repository.dart';
import 'package:flutter/material.dart'; // For ThemeMode
import 'package:injectable/injectable.dart';

@lazySingleton
class SaveThemeSettingUseCase {
  final SettingsRepository repository;

  SaveThemeSettingUseCase(this.repository);

  Future<void> call(ThemeMode themeMode) async {
    return await repository.saveThemeMode(themeMode);
  }
}

===== FILE: settings_screen.dart =====
===== PATH: lib/features/settings/presentation/cubit/screens/settings_screen.dart =====

import 'package:aboapp/features/settings/presentation/cubit/settings_cubit.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

class SettingsScreen extends StatelessWidget {
  const SettingsScreen({super.key});

  String _getThemeModeDisplayName(BuildContext context, ThemeMode themeMode) {
    switch (themeMode) {
      case ThemeMode.system:
        return 'System Default'; 
      case ThemeMode.light:
        return 'Light'; 
      case ThemeMode.dark:
        return 'Dark'; 
    }
  }

  String _getLocaleDisplayName(BuildContext context, Locale locale) {
    if (locale.languageCode == 'en') {
      return 'English'; 
    } else if (locale.languageCode == 'de') {
      return 'Deutsch (German)'; 
    }
    return locale.toLanguageTag(); 
  }
  
  static const Map<String, String> _supportedCurrencies = {
    'USD': 'USD - United States Dollar (\$)',
    'EUR': 'EUR - Euro (€)',
    'GBP': 'GBP - British Pound (£)',
    'JPY': 'JPY - Japanese Yen (¥)',
    'CHF': 'CHF - Swiss Franc (CHF)',
  };


  @override
  Widget build(BuildContext context) {
    // final theme = Theme.of(context); // Unused variable

    return Scaffold(
      body: BlocBuilder<SettingsCubit, SettingsState>(
        builder: (context, state) {
          if (state.isLoading && state.themeMode == ThemeMode.system && state.locale.languageCode == 'en') { 
            return const Center(child: CircularProgressIndicator.adaptive());
          }
          if (state.error != null) {
            return Center(child: Text('Error loading settings: ${state.error}')); // TODO: Localize
          }

          return ListView(
            padding: const EdgeInsets.all(8.0),
            children: <Widget>[
              _buildSectionHeader(context, 'Appearance'), 
              ListTile(
                leading: const Icon(Icons.brightness_6_rounded),
                title: const Text('Theme'), 
                subtitle: Text(_getThemeModeDisplayName(context, state.themeMode)),
                onTap: () => _showThemeModeDialog(context, state.themeMode),
              ),
              const Divider(),
              _buildSectionHeader(context, 'Regional'), 
              ListTile(
                leading: const Icon(Icons.language_rounded),
                title: const Text('Language'), 
                subtitle: Text(_getLocaleDisplayName(context, state.locale)),
                onTap: () => _showLocaleDialog(context, state.locale),
              ),
              ListTile(
                leading: const Icon(Icons.attach_money_rounded),
                title: const Text('Currency'), 
                subtitle: Text(_supportedCurrencies[state.currencyCode] ?? state.currencyCode),
                onTap: () => _showCurrencyDialog(context, state.currencyCode),
              ),
              const Divider(),
              _buildSectionHeader(context, 'About'), 
              ListTile(
                leading: const Icon(Icons.info_outline_rounded),
                title: const Text('About AboApp'), 
                subtitle: const Text('Version 3.0.0 - Refactored'), 
                onTap: () {
                  showDialog(
                    context: context,
                    builder: (ctx) => AlertDialog(
                      title: const Text('About AboApp'), 
                      content: const Text('Subscription management made easy.\nVersion 3.0.0'), 
                      actions: [TextButton(onPressed: () => Navigator.of(ctx).pop(), child: const Text('Close'))], 
                    ),
                  );
                },
              ),
            ],
          );
        },
      ),
    );
  }

  Widget _buildSectionHeader(BuildContext context, String title) {
    return Padding(
      padding: const EdgeInsets.only(top: 16.0, bottom: 8.0, left: 16.0, right: 16.0),
      child: Text(
        title,
        style: Theme.of(context).textTheme.titleSmall?.copyWith(
              color: Theme.of(context).colorScheme.primary,
              fontWeight: FontWeight.w600,
            ),
      ),
    );
  }

  void _showThemeModeDialog(BuildContext context, ThemeMode currentThemeMode) {
    showDialog(
      context: context,
      builder: (BuildContext dialogContext) {
        return AlertDialog(
          title: const Text('Select Theme'), 
          content: Column(
            mainAxisSize: MainAxisSize.min,
            children: ThemeMode.values.map((themeMode) {
              return RadioListTile<ThemeMode>(
                title: Text(_getThemeModeDisplayName(context, themeMode)),
                value: themeMode,
                groupValue: currentThemeMode,
                onChanged: (ThemeMode? value) {
                  if (value != null) {
                    context.read<SettingsCubit>().updateThemeMode(value);
                    Navigator.of(dialogContext).pop();
                  }
                },
              );
            }).toList(),
          ),
          actions: <Widget>[
            TextButton(
              child: const Text('Cancel'), 
              onPressed: () => Navigator.of(dialogContext).pop(),
            ),
          ],
        );
      },
    );
  }

  void _showLocaleDialog(BuildContext context, Locale currentLocale) {
    const List<Locale> supportedLocales = [
      Locale('en', 'US'),
      Locale('de', 'DE'),
    ];

    showDialog(
      context: context,
      builder: (BuildContext dialogContext) {
        return AlertDialog(
          title: const Text('Select Language'), 
          content: SizedBox(
            width: double.maxFinite,
            child: ListView.builder(
              shrinkWrap: true,
              itemCount: supportedLocales.length,
              itemBuilder: (BuildContext context, int index) {
                final locale = supportedLocales[index];
                return RadioListTile<Locale>(
                  title: Text(_getLocaleDisplayName(context, locale)),
                  value: locale,
                  groupValue: currentLocale,
                  onChanged: (Locale? value) {
                    if (value != null) {
                      context.read<SettingsCubit>().updateLocale(value);
                      Navigator.of(dialogContext).pop();
                    }
                  },
                );
              },
            ),
          ),
          actions: <Widget>[
            TextButton(
              child: const Text('Cancel'), 
              onPressed: () => Navigator.of(dialogContext).pop(),
            ),
          ],
        );
      },
    );
  }
  
  void _showCurrencyDialog(BuildContext context, String currentCurrencyCode) {
    showDialog(
      context: context,
      builder: (BuildContext dialogContext) {
        return AlertDialog(
          title: const Text('Select Currency'), 
          content: SizedBox(
            width: double.maxFinite,
            child: ListView(
              shrinkWrap: true,
              children: _supportedCurrencies.entries.map((entry) {
                return RadioListTile<String>(
                  title: Text(entry.value), 
                  value: entry.key, 
                  groupValue: currentCurrencyCode,
                  onChanged: (String? value) {
                    if (value != null) {
                      context.read<SettingsCubit>().updateCurrencyCode(value);
                       Navigator.of(dialogContext).pop();
                    }
                  },
                );
              }).toList(),
            ),
          ),
          actions: <Widget>[
            TextButton(
              child: const Text('Cancel'), 
              onPressed: () => Navigator.of(dialogContext).pop(),
            ),
          ],
        );
      },
    );
  }
}

===== FILE: settings_cubit.dart =====
===== PATH: lib/features/settings/presentation/cubit/settings_cubit.dart =====

import 'package:aboapp/features/settings/domain/usecases/get_settings_usecase.dart';
import 'package:aboapp/features/settings/domain/usecases/save_currency_setting_usecase.dart';
import 'package:aboapp/features/settings/domain/usecases/save_locale_setting_usecase.dart';
import 'package:aboapp/features/settings/domain/usecases/save_theme_setting_usecase.dart';
import 'package:flutter/material.dart'; 
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:injectable/injectable.dart';

part 'settings_state.dart';
part 'settings_cubit.freezed.dart'; 

@injectable
class SettingsCubit extends Cubit<SettingsState> {
  final GetSettingsUseCase _getSettings;
  final SaveThemeSettingUseCase _saveThemeSetting;
  final SaveLocaleSettingUseCase _saveLocaleSetting;
  final SaveCurrencySettingUseCase _saveCurrencySetting;

  SettingsCubit(
    this._getSettings,
    this._saveThemeSetting,
    this._saveLocaleSetting,
    this._saveCurrencySetting,
  ) : super(SettingsState.initial());

  Future<void> loadSettings() async {
    emit(state.copyWith(isLoading: true, error: null));
    try {
      final settingsEntity = await _getSettings();
      emit(state.copyWith(
        themeMode: settingsEntity.themeMode,
        locale: settingsEntity.locale,
        currencyCode: settingsEntity.currencyCode,
        isLoading: false,
      ));
    } catch (e) {
      emit(state.copyWith(isLoading: false, error: e.toString()));
    }
  }

  Future<void> updateThemeMode(ThemeMode newThemeMode) async {
    emit(state.copyWith(isLoading: true, error: null));
    try {
      await _saveThemeSetting(newThemeMode);
      emit(state.copyWith(themeMode: newThemeMode, isLoading: false));
    } catch (e) {
      emit(state.copyWith(isLoading: false, error: e.toString()));
    }
  }

  Future<void> updateLocale(Locale newLocale) async {
    emit(state.copyWith(isLoading: true, error: null));
    try {
      await _saveLocaleSetting(newLocale);
      emit(state.copyWith(locale: newLocale, isLoading: false));
    } catch (e) {
      emit(state.copyWith(isLoading: false, error: e.toString()));
    }
  }

  Future<void> updateCurrencyCode(String newCurrencyCode) async {
    emit(state.copyWith(isLoading: true, error: null));
    try {
      await _saveCurrencySetting(newCurrencyCode);
      emit(state.copyWith(currencyCode: newCurrencyCode, isLoading: false));
    } catch (e) {
      emit(state.copyWith(isLoading: false, error: e.toString()));
    }
  }
}

===== FILE: settings_cubit.freezed.dart =====
===== PATH: lib/features/settings/presentation/cubit/settings_cubit.freezed.dart =====

// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'settings_cubit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$SettingsState {
  ThemeMode get themeMode => throw _privateConstructorUsedError;
  Locale get locale => throw _privateConstructorUsedError;
  String get currencyCode => throw _privateConstructorUsedError;
  bool get isLoading => throw _privateConstructorUsedError;
  String? get error => throw _privateConstructorUsedError;

  /// Create a copy of SettingsState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SettingsStateCopyWith<SettingsState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SettingsStateCopyWith<$Res> {
  factory $SettingsStateCopyWith(
          SettingsState value, $Res Function(SettingsState) then) =
      _$SettingsStateCopyWithImpl<$Res, SettingsState>;
  @useResult
  $Res call(
      {ThemeMode themeMode,
      Locale locale,
      String currencyCode,
      bool isLoading,
      String? error});
}

/// @nodoc
class _$SettingsStateCopyWithImpl<$Res, $Val extends SettingsState>
    implements $SettingsStateCopyWith<$Res> {
  _$SettingsStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SettingsState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? themeMode = null,
    Object? locale = null,
    Object? currencyCode = null,
    Object? isLoading = null,
    Object? error = freezed,
  }) {
    return _then(_value.copyWith(
      themeMode: null == themeMode
          ? _value.themeMode
          : themeMode // ignore: cast_nullable_to_non_nullable
              as ThemeMode,
      locale: null == locale
          ? _value.locale
          : locale // ignore: cast_nullable_to_non_nullable
              as Locale,
      currencyCode: null == currencyCode
          ? _value.currencyCode
          : currencyCode // ignore: cast_nullable_to_non_nullable
              as String,
      isLoading: null == isLoading
          ? _value.isLoading
          : isLoading // ignore: cast_nullable_to_non_nullable
              as bool,
      error: freezed == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SettingsStateImplCopyWith<$Res>
    implements $SettingsStateCopyWith<$Res> {
  factory _$$SettingsStateImplCopyWith(
          _$SettingsStateImpl value, $Res Function(_$SettingsStateImpl) then) =
      __$$SettingsStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {ThemeMode themeMode,
      Locale locale,
      String currencyCode,
      bool isLoading,
      String? error});
}

/// @nodoc
class __$$SettingsStateImplCopyWithImpl<$Res>
    extends _$SettingsStateCopyWithImpl<$Res, _$SettingsStateImpl>
    implements _$$SettingsStateImplCopyWith<$Res> {
  __$$SettingsStateImplCopyWithImpl(
      _$SettingsStateImpl _value, $Res Function(_$SettingsStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of SettingsState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? themeMode = null,
    Object? locale = null,
    Object? currencyCode = null,
    Object? isLoading = null,
    Object? error = freezed,
  }) {
    return _then(_$SettingsStateImpl(
      themeMode: null == themeMode
          ? _value.themeMode
          : themeMode // ignore: cast_nullable_to_non_nullable
              as ThemeMode,
      locale: null == locale
          ? _value.locale
          : locale // ignore: cast_nullable_to_non_nullable
              as Locale,
      currencyCode: null == currencyCode
          ? _value.currencyCode
          : currencyCode // ignore: cast_nullable_to_non_nullable
              as String,
      isLoading: null == isLoading
          ? _value.isLoading
          : isLoading // ignore: cast_nullable_to_non_nullable
              as bool,
      error: freezed == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$SettingsStateImpl implements _SettingsState {
  const _$SettingsStateImpl(
      {required this.themeMode,
      required this.locale,
      required this.currencyCode,
      this.isLoading = false,
      this.error});

  @override
  final ThemeMode themeMode;
  @override
  final Locale locale;
  @override
  final String currencyCode;
  @override
  @JsonKey()
  final bool isLoading;
  @override
  final String? error;

  @override
  String toString() {
    return 'SettingsState(themeMode: $themeMode, locale: $locale, currencyCode: $currencyCode, isLoading: $isLoading, error: $error)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SettingsStateImpl &&
            (identical(other.themeMode, themeMode) ||
                other.themeMode == themeMode) &&
            (identical(other.locale, locale) || other.locale == locale) &&
            (identical(other.currencyCode, currencyCode) ||
                other.currencyCode == currencyCode) &&
            (identical(other.isLoading, isLoading) ||
                other.isLoading == isLoading) &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, themeMode, locale, currencyCode, isLoading, error);

  /// Create a copy of SettingsState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SettingsStateImplCopyWith<_$SettingsStateImpl> get copyWith =>
      __$$SettingsStateImplCopyWithImpl<_$SettingsStateImpl>(this, _$identity);
}

abstract class _SettingsState implements SettingsState {
  const factory _SettingsState(
      {required final ThemeMode themeMode,
      required final Locale locale,
      required final String currencyCode,
      final bool isLoading,
      final String? error}) = _$SettingsStateImpl;

  @override
  ThemeMode get themeMode;
  @override
  Locale get locale;
  @override
  String get currencyCode;
  @override
  bool get isLoading;
  @override
  String? get error;

  /// Create a copy of SettingsState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SettingsStateImplCopyWith<_$SettingsStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}


===== FILE: settings_state.dart =====
===== PATH: lib/features/settings/presentation/cubit/settings_state.dart =====

part of 'settings_cubit.dart';

@freezed
class SettingsState with _$SettingsState {
  const factory SettingsState({
    required ThemeMode themeMode,
    required Locale locale,
    required String currencyCode,
    @Default(false) bool isLoading,
    String? error,
  }) = _SettingsState;

  factory SettingsState.initial() => const SettingsState( // Added const
        themeMode: ThemeMode.system, 
        locale: Locale('en', 'US'), 
        currencyCode: 'USD', 
      );
}

===== FILE: statistics_cubit.dart =====
===== PATH: lib/features/statistics/presentation/cubit/statistics_cubit.dart =====

import 'package:aboapp/features/subscriptions/domain/entities/subscription_entity.dart';
import 'package:fl_chart/fl_chart.dart'; 
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:injectable/injectable.dart';
import 'package:collection/collection.dart'; 

part 'statistics_state.dart';
part 'statistics_cubit.freezed.dart';

@injectable
class StatisticsCubit extends Cubit<StatisticsState> {
  StatisticsCubit() : super(const StatisticsState.initial());

  void generateStatistics(List<SubscriptionEntity> allSubscriptions, {int? yearForTrend}) {
    emit(const StatisticsState.loading());

    final activeSubscriptions = allSubscriptions.where((s) => s.isActive).toList();

    if (activeSubscriptions.isEmpty) {
      emit(const StatisticsState.empty(message: 'No active subscriptions to generate statistics.')); // TODO: Localize
      return;
    }

    try {
      final totalMonthlyEquivalent = activeSubscriptions.sumByDouble((s) => s.monthlyEquivalentPrice);
      final totalYearlyEquivalent = totalMonthlyEquivalent * 12;

      final Map<SubscriptionCategory, double> categoryTotals = {};
      for (var sub in activeSubscriptions) {
        categoryTotals.update(
          sub.category,
          (value) => value + sub.monthlyEquivalentPrice,
          ifAbsent: () => sub.monthlyEquivalentPrice,
        );
      }
      final List<CategorySpending> categorySpendingData = categoryTotals.entries.map((entry) {
        return CategorySpending(
          category: entry.key,
          totalAmount: entry.value,
          percentage: totalMonthlyEquivalent > 0 ? (entry.value / totalMonthlyEquivalent) : 0.0,
        );
      }).sortedBy<num>((cs) => cs.totalAmount).reversed.toList(); 

      final Map<BillingCycle, List<SubscriptionEntity>> subsByBillingCycle = {};
      for (var sub in activeSubscriptions) {
        subsByBillingCycle.putIfAbsent(sub.billingCycle, () => []).add(sub);
      }
      final List<BillingTypeSpending> billingTypeSpendingData = subsByBillingCycle.entries.map((entry) {
        final cycleTotalMonthlyEquiv = entry.value.sumByDouble((s) => s.monthlyEquivalentPrice);
        return BillingTypeSpending(
          billingCycle: entry.key,
          totalAmount: cycleTotalMonthlyEquiv,
          subscriptionCount: entry.value.length,
          percentageOfTotal: totalMonthlyEquivalent > 0 ? (cycleTotalMonthlyEquiv / totalMonthlyEquivalent) : 0.0,
        );
      }).sortedBy<num>((bs) => bs.totalAmount).reversed.toList(); 


      final List<SubscriptionEntity> topSpendingSubscriptions = List.from(activeSubscriptions)
        ..sort((a, b) => b.monthlyEquivalentPrice.compareTo(a.monthlyEquivalentPrice));
      final topN = topSpendingSubscriptions.take(5).toList();

      final int trendYear = yearForTrend ?? DateTime.now().year;
      final List<FlSpot> spots = [];
      double maxSpendingInYear = 0.0;
      for (int month = 1; month <= 12; month++) {
        double monthlyTotalForTrend = 0.0;
        for (final sub in activeSubscriptions) {
          if (sub.startDate != null &&
              (sub.startDate!.year < trendYear || (sub.startDate!.year == trendYear && sub.startDate!.month <= month))) {
            monthlyTotalForTrend += sub.monthlyEquivalentPrice;
          }
        }
        spots.add(FlSpot(month.toDouble(), monthlyTotalForTrend));
        if (monthlyTotalForTrend > maxSpendingInYear) {
          maxSpendingInYear = monthlyTotalForTrend;
        }
      }
      final spendingTrendData = MonthlySpendingTrendData(
        year: trendYear,
        spots: spots,
        maxSpendingInYear: maxSpendingInYear,
      );

      emit(StatisticsState.loaded(
        activeSubscriptions: activeSubscriptions,
        categorySpendingData: categorySpendingData,
        billingTypeSpendingData: billingTypeSpendingData,
        topSpendingSubscriptions: topN,
        spendingTrendData: spendingTrendData,
        totalMonthlyEquivalentSpending: totalMonthlyEquivalent,
        totalYearlyEquivalentSpending: totalYearlyEquivalent,
        selectedYearForTrend: trendYear,
      ));
    } catch (e) {
      emit(StatisticsState.error(message: "Failed to generate statistics: ${e.toString()}"));
    }
  }
  
  void changeTrendYear(List<SubscriptionEntity> allSubscriptions, int newYear) {
    generateStatistics(allSubscriptions, yearForTrend: newYear);
  }
}

extension SumByDouble<T> on Iterable<T> {
  double sumByDouble(double Function(T element) f) {
    double sum = 0;
    for (var element in this) {
      sum += f(element);
    }
    return sum;
  }
}

===== FILE: statistics_cubit.freezed.dart =====
===== PATH: lib/features/statistics/presentation/cubit/statistics_cubit.freezed.dart =====

// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'statistics_cubit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$StatisticsState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            List<SubscriptionEntity> activeSubscriptions,
            List<CategorySpending> categorySpendingData,
            List<BillingTypeSpending> billingTypeSpendingData,
            List<SubscriptionEntity> topSpendingSubscriptions,
            MonthlySpendingTrendData spendingTrendData,
            double totalMonthlyEquivalentSpending,
            double totalYearlyEquivalentSpending,
            int selectedYearForTrend)
        loaded,
    required TResult Function(String message) error,
    required TResult Function(String message) empty,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(
            List<SubscriptionEntity> activeSubscriptions,
            List<CategorySpending> categorySpendingData,
            List<BillingTypeSpending> billingTypeSpendingData,
            List<SubscriptionEntity> topSpendingSubscriptions,
            MonthlySpendingTrendData spendingTrendData,
            double totalMonthlyEquivalentSpending,
            double totalYearlyEquivalentSpending,
            int selectedYearForTrend)?
        loaded,
    TResult? Function(String message)? error,
    TResult? Function(String message)? empty,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            List<SubscriptionEntity> activeSubscriptions,
            List<CategorySpending> categorySpendingData,
            List<BillingTypeSpending> billingTypeSpendingData,
            List<SubscriptionEntity> topSpendingSubscriptions,
            MonthlySpendingTrendData spendingTrendData,
            double totalMonthlyEquivalentSpending,
            double totalYearlyEquivalentSpending,
            int selectedYearForTrend)?
        loaded,
    TResult Function(String message)? error,
    TResult Function(String message)? empty,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
    required TResult Function(_Empty value) empty,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
    TResult? Function(_Empty value)? empty,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    TResult Function(_Empty value)? empty,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StatisticsStateCopyWith<$Res> {
  factory $StatisticsStateCopyWith(
          StatisticsState value, $Res Function(StatisticsState) then) =
      _$StatisticsStateCopyWithImpl<$Res, StatisticsState>;
}

/// @nodoc
class _$StatisticsStateCopyWithImpl<$Res, $Val extends StatisticsState>
    implements $StatisticsStateCopyWith<$Res> {
  _$StatisticsStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of StatisticsState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$InitialImplCopyWith<$Res> {
  factory _$$InitialImplCopyWith(
          _$InitialImpl value, $Res Function(_$InitialImpl) then) =
      __$$InitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitialImplCopyWithImpl<$Res>
    extends _$StatisticsStateCopyWithImpl<$Res, _$InitialImpl>
    implements _$$InitialImplCopyWith<$Res> {
  __$$InitialImplCopyWithImpl(
      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)
      : super(_value, _then);

  /// Create a copy of StatisticsState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$InitialImpl implements _Initial {
  const _$InitialImpl();

  @override
  String toString() {
    return 'StatisticsState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            List<SubscriptionEntity> activeSubscriptions,
            List<CategorySpending> categorySpendingData,
            List<BillingTypeSpending> billingTypeSpendingData,
            List<SubscriptionEntity> topSpendingSubscriptions,
            MonthlySpendingTrendData spendingTrendData,
            double totalMonthlyEquivalentSpending,
            double totalYearlyEquivalentSpending,
            int selectedYearForTrend)
        loaded,
    required TResult Function(String message) error,
    required TResult Function(String message) empty,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(
            List<SubscriptionEntity> activeSubscriptions,
            List<CategorySpending> categorySpendingData,
            List<BillingTypeSpending> billingTypeSpendingData,
            List<SubscriptionEntity> topSpendingSubscriptions,
            MonthlySpendingTrendData spendingTrendData,
            double totalMonthlyEquivalentSpending,
            double totalYearlyEquivalentSpending,
            int selectedYearForTrend)?
        loaded,
    TResult? Function(String message)? error,
    TResult? Function(String message)? empty,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            List<SubscriptionEntity> activeSubscriptions,
            List<CategorySpending> categorySpendingData,
            List<BillingTypeSpending> billingTypeSpendingData,
            List<SubscriptionEntity> topSpendingSubscriptions,
            MonthlySpendingTrendData spendingTrendData,
            double totalMonthlyEquivalentSpending,
            double totalYearlyEquivalentSpending,
            int selectedYearForTrend)?
        loaded,
    TResult Function(String message)? error,
    TResult Function(String message)? empty,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
    required TResult Function(_Empty value) empty,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
    TResult? Function(_Empty value)? empty,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    TResult Function(_Empty value)? empty,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements StatisticsState {
  const factory _Initial() = _$InitialImpl;
}

/// @nodoc
abstract class _$$LoadingImplCopyWith<$Res> {
  factory _$$LoadingImplCopyWith(
          _$LoadingImpl value, $Res Function(_$LoadingImpl) then) =
      __$$LoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadingImplCopyWithImpl<$Res>
    extends _$StatisticsStateCopyWithImpl<$Res, _$LoadingImpl>
    implements _$$LoadingImplCopyWith<$Res> {
  __$$LoadingImplCopyWithImpl(
      _$LoadingImpl _value, $Res Function(_$LoadingImpl) _then)
      : super(_value, _then);

  /// Create a copy of StatisticsState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$LoadingImpl implements _Loading {
  const _$LoadingImpl();

  @override
  String toString() {
    return 'StatisticsState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            List<SubscriptionEntity> activeSubscriptions,
            List<CategorySpending> categorySpendingData,
            List<BillingTypeSpending> billingTypeSpendingData,
            List<SubscriptionEntity> topSpendingSubscriptions,
            MonthlySpendingTrendData spendingTrendData,
            double totalMonthlyEquivalentSpending,
            double totalYearlyEquivalentSpending,
            int selectedYearForTrend)
        loaded,
    required TResult Function(String message) error,
    required TResult Function(String message) empty,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(
            List<SubscriptionEntity> activeSubscriptions,
            List<CategorySpending> categorySpendingData,
            List<BillingTypeSpending> billingTypeSpendingData,
            List<SubscriptionEntity> topSpendingSubscriptions,
            MonthlySpendingTrendData spendingTrendData,
            double totalMonthlyEquivalentSpending,
            double totalYearlyEquivalentSpending,
            int selectedYearForTrend)?
        loaded,
    TResult? Function(String message)? error,
    TResult? Function(String message)? empty,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            List<SubscriptionEntity> activeSubscriptions,
            List<CategorySpending> categorySpendingData,
            List<BillingTypeSpending> billingTypeSpendingData,
            List<SubscriptionEntity> topSpendingSubscriptions,
            MonthlySpendingTrendData spendingTrendData,
            double totalMonthlyEquivalentSpending,
            double totalYearlyEquivalentSpending,
            int selectedYearForTrend)?
        loaded,
    TResult Function(String message)? error,
    TResult Function(String message)? empty,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
    required TResult Function(_Empty value) empty,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
    TResult? Function(_Empty value)? empty,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    TResult Function(_Empty value)? empty,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _Loading implements StatisticsState {
  const factory _Loading() = _$LoadingImpl;
}

/// @nodoc
abstract class _$$LoadedImplCopyWith<$Res> {
  factory _$$LoadedImplCopyWith(
          _$LoadedImpl value, $Res Function(_$LoadedImpl) then) =
      __$$LoadedImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {List<SubscriptionEntity> activeSubscriptions,
      List<CategorySpending> categorySpendingData,
      List<BillingTypeSpending> billingTypeSpendingData,
      List<SubscriptionEntity> topSpendingSubscriptions,
      MonthlySpendingTrendData spendingTrendData,
      double totalMonthlyEquivalentSpending,
      double totalYearlyEquivalentSpending,
      int selectedYearForTrend});
}

/// @nodoc
class __$$LoadedImplCopyWithImpl<$Res>
    extends _$StatisticsStateCopyWithImpl<$Res, _$LoadedImpl>
    implements _$$LoadedImplCopyWith<$Res> {
  __$$LoadedImplCopyWithImpl(
      _$LoadedImpl _value, $Res Function(_$LoadedImpl) _then)
      : super(_value, _then);

  /// Create a copy of StatisticsState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? activeSubscriptions = null,
    Object? categorySpendingData = null,
    Object? billingTypeSpendingData = null,
    Object? topSpendingSubscriptions = null,
    Object? spendingTrendData = null,
    Object? totalMonthlyEquivalentSpending = null,
    Object? totalYearlyEquivalentSpending = null,
    Object? selectedYearForTrend = null,
  }) {
    return _then(_$LoadedImpl(
      activeSubscriptions: null == activeSubscriptions
          ? _value._activeSubscriptions
          : activeSubscriptions // ignore: cast_nullable_to_non_nullable
              as List<SubscriptionEntity>,
      categorySpendingData: null == categorySpendingData
          ? _value._categorySpendingData
          : categorySpendingData // ignore: cast_nullable_to_non_nullable
              as List<CategorySpending>,
      billingTypeSpendingData: null == billingTypeSpendingData
          ? _value._billingTypeSpendingData
          : billingTypeSpendingData // ignore: cast_nullable_to_non_nullable
              as List<BillingTypeSpending>,
      topSpendingSubscriptions: null == topSpendingSubscriptions
          ? _value._topSpendingSubscriptions
          : topSpendingSubscriptions // ignore: cast_nullable_to_non_nullable
              as List<SubscriptionEntity>,
      spendingTrendData: null == spendingTrendData
          ? _value.spendingTrendData
          : spendingTrendData // ignore: cast_nullable_to_non_nullable
              as MonthlySpendingTrendData,
      totalMonthlyEquivalentSpending: null == totalMonthlyEquivalentSpending
          ? _value.totalMonthlyEquivalentSpending
          : totalMonthlyEquivalentSpending // ignore: cast_nullable_to_non_nullable
              as double,
      totalYearlyEquivalentSpending: null == totalYearlyEquivalentSpending
          ? _value.totalYearlyEquivalentSpending
          : totalYearlyEquivalentSpending // ignore: cast_nullable_to_non_nullable
              as double,
      selectedYearForTrend: null == selectedYearForTrend
          ? _value.selectedYearForTrend
          : selectedYearForTrend // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$LoadedImpl implements _Loaded {
  const _$LoadedImpl(
      {required final List<SubscriptionEntity> activeSubscriptions,
      required final List<CategorySpending> categorySpendingData,
      required final List<BillingTypeSpending> billingTypeSpendingData,
      required final List<SubscriptionEntity> topSpendingSubscriptions,
      required this.spendingTrendData,
      required this.totalMonthlyEquivalentSpending,
      required this.totalYearlyEquivalentSpending,
      required this.selectedYearForTrend})
      : _activeSubscriptions = activeSubscriptions,
        _categorySpendingData = categorySpendingData,
        _billingTypeSpendingData = billingTypeSpendingData,
        _topSpendingSubscriptions = topSpendingSubscriptions;

  final List<SubscriptionEntity> _activeSubscriptions;
  @override
  List<SubscriptionEntity> get activeSubscriptions {
    if (_activeSubscriptions is EqualUnmodifiableListView)
      return _activeSubscriptions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_activeSubscriptions);
  }

// Source data
  final List<CategorySpending> _categorySpendingData;
// Source data
  @override
  List<CategorySpending> get categorySpendingData {
    if (_categorySpendingData is EqualUnmodifiableListView)
      return _categorySpendingData;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_categorySpendingData);
  }

  final List<BillingTypeSpending> _billingTypeSpendingData;
  @override
  List<BillingTypeSpending> get billingTypeSpendingData {
    if (_billingTypeSpendingData is EqualUnmodifiableListView)
      return _billingTypeSpendingData;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_billingTypeSpendingData);
  }

  final List<SubscriptionEntity> _topSpendingSubscriptions;
  @override
  List<SubscriptionEntity> get topSpendingSubscriptions {
    if (_topSpendingSubscriptions is EqualUnmodifiableListView)
      return _topSpendingSubscriptions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_topSpendingSubscriptions);
  }

// Top N subscriptions by monthly equiv.
  @override
  final MonthlySpendingTrendData spendingTrendData;
  @override
  final double totalMonthlyEquivalentSpending;
  @override
  final double totalYearlyEquivalentSpending;
  @override
  final int selectedYearForTrend;

  @override
  String toString() {
    return 'StatisticsState.loaded(activeSubscriptions: $activeSubscriptions, categorySpendingData: $categorySpendingData, billingTypeSpendingData: $billingTypeSpendingData, topSpendingSubscriptions: $topSpendingSubscriptions, spendingTrendData: $spendingTrendData, totalMonthlyEquivalentSpending: $totalMonthlyEquivalentSpending, totalYearlyEquivalentSpending: $totalYearlyEquivalentSpending, selectedYearForTrend: $selectedYearForTrend)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoadedImpl &&
            const DeepCollectionEquality()
                .equals(other._activeSubscriptions, _activeSubscriptions) &&
            const DeepCollectionEquality()
                .equals(other._categorySpendingData, _categorySpendingData) &&
            const DeepCollectionEquality().equals(
                other._billingTypeSpendingData, _billingTypeSpendingData) &&
            const DeepCollectionEquality().equals(
                other._topSpendingSubscriptions, _topSpendingSubscriptions) &&
            (identical(other.spendingTrendData, spendingTrendData) ||
                other.spendingTrendData == spendingTrendData) &&
            (identical(other.totalMonthlyEquivalentSpending,
                    totalMonthlyEquivalentSpending) ||
                other.totalMonthlyEquivalentSpending ==
                    totalMonthlyEquivalentSpending) &&
            (identical(other.totalYearlyEquivalentSpending,
                    totalYearlyEquivalentSpending) ||
                other.totalYearlyEquivalentSpending ==
                    totalYearlyEquivalentSpending) &&
            (identical(other.selectedYearForTrend, selectedYearForTrend) ||
                other.selectedYearForTrend == selectedYearForTrend));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_activeSubscriptions),
      const DeepCollectionEquality().hash(_categorySpendingData),
      const DeepCollectionEquality().hash(_billingTypeSpendingData),
      const DeepCollectionEquality().hash(_topSpendingSubscriptions),
      spendingTrendData,
      totalMonthlyEquivalentSpending,
      totalYearlyEquivalentSpending,
      selectedYearForTrend);

  /// Create a copy of StatisticsState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$LoadedImplCopyWith<_$LoadedImpl> get copyWith =>
      __$$LoadedImplCopyWithImpl<_$LoadedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            List<SubscriptionEntity> activeSubscriptions,
            List<CategorySpending> categorySpendingData,
            List<BillingTypeSpending> billingTypeSpendingData,
            List<SubscriptionEntity> topSpendingSubscriptions,
            MonthlySpendingTrendData spendingTrendData,
            double totalMonthlyEquivalentSpending,
            double totalYearlyEquivalentSpending,
            int selectedYearForTrend)
        loaded,
    required TResult Function(String message) error,
    required TResult Function(String message) empty,
  }) {
    return loaded(
        activeSubscriptions,
        categorySpendingData,
        billingTypeSpendingData,
        topSpendingSubscriptions,
        spendingTrendData,
        totalMonthlyEquivalentSpending,
        totalYearlyEquivalentSpending,
        selectedYearForTrend);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(
            List<SubscriptionEntity> activeSubscriptions,
            List<CategorySpending> categorySpendingData,
            List<BillingTypeSpending> billingTypeSpendingData,
            List<SubscriptionEntity> topSpendingSubscriptions,
            MonthlySpendingTrendData spendingTrendData,
            double totalMonthlyEquivalentSpending,
            double totalYearlyEquivalentSpending,
            int selectedYearForTrend)?
        loaded,
    TResult? Function(String message)? error,
    TResult? Function(String message)? empty,
  }) {
    return loaded?.call(
        activeSubscriptions,
        categorySpendingData,
        billingTypeSpendingData,
        topSpendingSubscriptions,
        spendingTrendData,
        totalMonthlyEquivalentSpending,
        totalYearlyEquivalentSpending,
        selectedYearForTrend);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            List<SubscriptionEntity> activeSubscriptions,
            List<CategorySpending> categorySpendingData,
            List<BillingTypeSpending> billingTypeSpendingData,
            List<SubscriptionEntity> topSpendingSubscriptions,
            MonthlySpendingTrendData spendingTrendData,
            double totalMonthlyEquivalentSpending,
            double totalYearlyEquivalentSpending,
            int selectedYearForTrend)?
        loaded,
    TResult Function(String message)? error,
    TResult Function(String message)? empty,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(
          activeSubscriptions,
          categorySpendingData,
          billingTypeSpendingData,
          topSpendingSubscriptions,
          spendingTrendData,
          totalMonthlyEquivalentSpending,
          totalYearlyEquivalentSpending,
          selectedYearForTrend);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
    required TResult Function(_Empty value) empty,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
    TResult? Function(_Empty value)? empty,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    TResult Function(_Empty value)? empty,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class _Loaded implements StatisticsState {
  const factory _Loaded(
      {required final List<SubscriptionEntity> activeSubscriptions,
      required final List<CategorySpending> categorySpendingData,
      required final List<BillingTypeSpending> billingTypeSpendingData,
      required final List<SubscriptionEntity> topSpendingSubscriptions,
      required final MonthlySpendingTrendData spendingTrendData,
      required final double totalMonthlyEquivalentSpending,
      required final double totalYearlyEquivalentSpending,
      required final int selectedYearForTrend}) = _$LoadedImpl;

  List<SubscriptionEntity> get activeSubscriptions; // Source data
  List<CategorySpending> get categorySpendingData;
  List<BillingTypeSpending> get billingTypeSpendingData;
  List<SubscriptionEntity>
      get topSpendingSubscriptions; // Top N subscriptions by monthly equiv.
  MonthlySpendingTrendData get spendingTrendData;
  double get totalMonthlyEquivalentSpending;
  double get totalYearlyEquivalentSpending;
  int get selectedYearForTrend;

  /// Create a copy of StatisticsState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$LoadedImplCopyWith<_$LoadedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ErrorImplCopyWith<$Res> {
  factory _$$ErrorImplCopyWith(
          _$ErrorImpl value, $Res Function(_$ErrorImpl) then) =
      __$$ErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$ErrorImplCopyWithImpl<$Res>
    extends _$StatisticsStateCopyWithImpl<$Res, _$ErrorImpl>
    implements _$$ErrorImplCopyWith<$Res> {
  __$$ErrorImplCopyWithImpl(
      _$ErrorImpl _value, $Res Function(_$ErrorImpl) _then)
      : super(_value, _then);

  /// Create a copy of StatisticsState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$ErrorImpl(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ErrorImpl implements _Error {
  const _$ErrorImpl({required this.message});

  @override
  final String message;

  @override
  String toString() {
    return 'StatisticsState.error(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ErrorImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  /// Create a copy of StatisticsState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>
      __$$ErrorImplCopyWithImpl<_$ErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            List<SubscriptionEntity> activeSubscriptions,
            List<CategorySpending> categorySpendingData,
            List<BillingTypeSpending> billingTypeSpendingData,
            List<SubscriptionEntity> topSpendingSubscriptions,
            MonthlySpendingTrendData spendingTrendData,
            double totalMonthlyEquivalentSpending,
            double totalYearlyEquivalentSpending,
            int selectedYearForTrend)
        loaded,
    required TResult Function(String message) error,
    required TResult Function(String message) empty,
  }) {
    return error(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(
            List<SubscriptionEntity> activeSubscriptions,
            List<CategorySpending> categorySpendingData,
            List<BillingTypeSpending> billingTypeSpendingData,
            List<SubscriptionEntity> topSpendingSubscriptions,
            MonthlySpendingTrendData spendingTrendData,
            double totalMonthlyEquivalentSpending,
            double totalYearlyEquivalentSpending,
            int selectedYearForTrend)?
        loaded,
    TResult? Function(String message)? error,
    TResult? Function(String message)? empty,
  }) {
    return error?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            List<SubscriptionEntity> activeSubscriptions,
            List<CategorySpending> categorySpendingData,
            List<BillingTypeSpending> billingTypeSpendingData,
            List<SubscriptionEntity> topSpendingSubscriptions,
            MonthlySpendingTrendData spendingTrendData,
            double totalMonthlyEquivalentSpending,
            double totalYearlyEquivalentSpending,
            int selectedYearForTrend)?
        loaded,
    TResult Function(String message)? error,
    TResult Function(String message)? empty,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
    required TResult Function(_Empty value) empty,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
    TResult? Function(_Empty value)? empty,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    TResult Function(_Empty value)? empty,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _Error implements StatisticsState {
  const factory _Error({required final String message}) = _$ErrorImpl;

  String get message;

  /// Create a copy of StatisticsState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EmptyImplCopyWith<$Res> {
  factory _$$EmptyImplCopyWith(
          _$EmptyImpl value, $Res Function(_$EmptyImpl) then) =
      __$$EmptyImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$EmptyImplCopyWithImpl<$Res>
    extends _$StatisticsStateCopyWithImpl<$Res, _$EmptyImpl>
    implements _$$EmptyImplCopyWith<$Res> {
  __$$EmptyImplCopyWithImpl(
      _$EmptyImpl _value, $Res Function(_$EmptyImpl) _then)
      : super(_value, _then);

  /// Create a copy of StatisticsState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$EmptyImpl(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$EmptyImpl implements _Empty {
  const _$EmptyImpl({required this.message});

  @override
  final String message;

  @override
  String toString() {
    return 'StatisticsState.empty(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EmptyImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  /// Create a copy of StatisticsState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$EmptyImplCopyWith<_$EmptyImpl> get copyWith =>
      __$$EmptyImplCopyWithImpl<_$EmptyImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            List<SubscriptionEntity> activeSubscriptions,
            List<CategorySpending> categorySpendingData,
            List<BillingTypeSpending> billingTypeSpendingData,
            List<SubscriptionEntity> topSpendingSubscriptions,
            MonthlySpendingTrendData spendingTrendData,
            double totalMonthlyEquivalentSpending,
            double totalYearlyEquivalentSpending,
            int selectedYearForTrend)
        loaded,
    required TResult Function(String message) error,
    required TResult Function(String message) empty,
  }) {
    return empty(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(
            List<SubscriptionEntity> activeSubscriptions,
            List<CategorySpending> categorySpendingData,
            List<BillingTypeSpending> billingTypeSpendingData,
            List<SubscriptionEntity> topSpendingSubscriptions,
            MonthlySpendingTrendData spendingTrendData,
            double totalMonthlyEquivalentSpending,
            double totalYearlyEquivalentSpending,
            int selectedYearForTrend)?
        loaded,
    TResult? Function(String message)? error,
    TResult? Function(String message)? empty,
  }) {
    return empty?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            List<SubscriptionEntity> activeSubscriptions,
            List<CategorySpending> categorySpendingData,
            List<BillingTypeSpending> billingTypeSpendingData,
            List<SubscriptionEntity> topSpendingSubscriptions,
            MonthlySpendingTrendData spendingTrendData,
            double totalMonthlyEquivalentSpending,
            double totalYearlyEquivalentSpending,
            int selectedYearForTrend)?
        loaded,
    TResult Function(String message)? error,
    TResult Function(String message)? empty,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
    required TResult Function(_Empty value) empty,
  }) {
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
    TResult? Function(_Empty value)? empty,
  }) {
    return empty?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    TResult Function(_Empty value)? empty,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class _Empty implements StatisticsState {
  const factory _Empty({required final String message}) = _$EmptyImpl;

  String get message;

  /// Create a copy of StatisticsState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$EmptyImplCopyWith<_$EmptyImpl> get copyWith =>
      throw _privateConstructorUsedError;
}


===== FILE: statistics_state.dart =====
===== PATH: lib/features/statistics/presentation/cubit/statistics_state.dart =====

part of 'statistics_cubit.dart';

// Data structures for charts (can be classes or records)
class CategorySpending {
  final SubscriptionCategory category;
  final double totalAmount;
  final double percentage; // Percentage of total spending

  CategorySpending({
    required this.category,
    required this.totalAmount,
    required this.percentage,
  });
}

class BillingTypeSpending {
  final BillingCycle billingCycle;
  final double totalAmount; // Monthly equivalent
  final int subscriptionCount;
  final double percentageOfTotal; // Percentage of total monthly equivalent spending

  BillingTypeSpending({
    required this.billingCycle,
    required this.totalAmount,
    required this.subscriptionCount,
    required this.percentageOfTotal,
  });
}

class MonthlySpendingTrendData {
  final int year;
  final List<FlSpot> spots; // x: month (1-12), y: total spending
  final double maxSpendingInYear;

  MonthlySpendingTrendData({
    required this.year,
    required this.spots,
    required this.maxSpendingInYear,
  });
}

@freezed
class StatisticsState with _$StatisticsState {
  const factory StatisticsState.initial() = _Initial;
  const factory StatisticsState.loading() = _Loading;
  const factory StatisticsState.loaded({
    required List<SubscriptionEntity> activeSubscriptions, // Source data
    required List<CategorySpending> categorySpendingData,
    required List<BillingTypeSpending> billingTypeSpendingData,
    required List<SubscriptionEntity> topSpendingSubscriptions, // Top N subscriptions by monthly equiv.
    required MonthlySpendingTrendData spendingTrendData,
    required double totalMonthlyEquivalentSpending,
    required double totalYearlyEquivalentSpending,
    required int selectedYearForTrend, // The year currently displayed in the trend chart
  }) = _Loaded;
  const factory StatisticsState.error({required String message}) = _Error;
  const factory StatisticsState.empty({required String message}) = _Empty;
}

===== FILE: statistics_screen.dart =====
===== PATH: lib/features/statistics/presentation/screens/statistics_screen.dart =====

import 'package:aboapp/features/statistics/presentation/cubit/statistics_cubit.dart';
import 'package:aboapp/features/statistics/presentation/widgets/billing_type_breakdown_card.dart';
import 'package:aboapp/features/statistics/presentation/widgets/category_spending_pie_chart_card.dart';
import 'package:aboapp/features/statistics/presentation/widgets/overall_spending_summary_card.dart';
import 'package:aboapp/features/statistics/presentation/widgets/spending_trend_line_chart_card.dart';
import 'package:aboapp/features/statistics/presentation/widgets/top_subscriptions_list_card.dart';
import 'package:aboapp/features/subscriptions/presentation/cubit/subscription_cubit.dart'; // Removed hide Error
import 'package:aboapp/widgets/empty_state_widget.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

class StatisticsScreen extends StatefulWidget {
  const StatisticsScreen({super.key});

  @override
  State<StatisticsScreen> createState() => _StatisticsScreenState();
}

class _StatisticsScreenState extends State<StatisticsScreen> {
  int _selectedYearForTrend = DateTime.now().year;

  @override
  void initState() {
    super.initState();
    final subscriptionState = context.read<SubscriptionCubit>().state;
    subscriptionState.whenOrNull(
      loaded: (allSubs, _, __, ___, ____, _____) {
        if (mounted) {
          context
              .read<StatisticsCubit>()
              .generateStatistics(allSubs, yearForTrend: _selectedYearForTrend);
        }
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Scaffold(
      body: MultiBlocListener(
        listeners: [
          BlocListener<SubscriptionCubit, SubscriptionState>(
            listener: (context, subState) {
              subState.whenOrNull(
                loaded: (allSubs, _, __, ___, ____, _____) {
                  context.read<StatisticsCubit>().generateStatistics(allSubs,
                      yearForTrend: _selectedYearForTrend);
                },
              );
            },
          ),
        ],
        child: BlocBuilder<StatisticsCubit, StatisticsState>(
          builder: (context, statsState) {
            return statsState.when(
              initial: () =>
                  const Center(child: CircularProgressIndicator.adaptive()),
              loading: () =>
                  const Center(child: CircularProgressIndicator.adaptive()),
              empty: (message) => EmptyStateWidget(
                icon: Icons.sentiment_dissatisfied_rounded,
                title: 'No Statistics Yet',
                message: message,
              ),
              error: (message) => EmptyStateWidget(
                icon: Icons.error_outline_rounded,
                title: 'Error Loading Statistics',
                message: message,
                onRetry: () {
                  final subCubitState = context.read<SubscriptionCubit>().state;
                  subCubitState.whenOrNull(
                    loaded: (allSubs, _, __, ___, ____, _____) => context
                        .read<StatisticsCubit>()
                        .generateStatistics(allSubs,
                            yearForTrend: _selectedYearForTrend),
                  );
                },
                retryText: 'Retry',
              ),
              loaded: (
                activeSubscriptions,
                categorySpendingData,
                billingTypeSpendingData,
                topSpendingSubscriptions,
                spendingTrendData,
                totalMonthlyEquivalentSpending,
                totalYearlyEquivalentSpending,
                selectedYearForTrend,
              ) {
                if (_selectedYearForTrend != selectedYearForTrend) {
                  _selectedYearForTrend = selectedYearForTrend;
                }
                return RefreshIndicator(
                  onRefresh: () async {
                    final subCubitState =
                        context.read<SubscriptionCubit>().state;
                    // Removed await from void result
                    subCubitState.maybeWhen(
                      loaded: (allSubs, _, __, ___, ____, _____) {
                        context.read<StatisticsCubit>().generateStatistics(
                            allSubs,
                            yearForTrend: _selectedYearForTrend);
                      },
                      orElse: () {},
                    );
                  },
                  child: CustomScrollView(
                    slivers: <Widget>[
                      SliverAppBar(
                        title: const Text('Statistics'),
                        floating: true,
                        snap: true,
                        actions: [
                          _buildYearSelector(
                              context, theme, selectedYearForTrend),
                        ],
                      ),
                      SliverPadding(
                        padding: const EdgeInsets.all(12.0),
                        sliver: SliverList(
                          delegate: SliverChildListDelegate.fixed([
                            // Added const
                            OverallSpendingSummaryCard(
                              totalMonthlySpending:
                                  totalMonthlyEquivalentSpending, // These are already passed
                              totalYearlySpending:
                                  totalYearlyEquivalentSpending,
                            ),
                            SizedBox(height: 12),
                            CategorySpendingPieChartCard(
                              categorySpendingData:
                                  categorySpendingData, // Passed
                            ),
                            SizedBox(height: 12),
                            BillingTypeBreakdownCard(
                              billingTypeSpendingData:
                                  billingTypeSpendingData, // Passed
                            ),
                            SizedBox(height: 12),
                            SpendingTrendLineChartCard(
                              spendingTrendData: spendingTrendData, // Passed
                            ),
                            SizedBox(height: 12),
                            TopSubscriptionsListCard(
                              topSubscriptions:
                                  topSpendingSubscriptions, // Passed
                            ),
                            SizedBox(height: 24),
                          ]),
                        ),
                      ),
                    ],
                  ),
                );
              },
            );
          },
        ),
      ),
    );
  }

  Widget _buildYearSelector(
      BuildContext context, ThemeData theme, int currentYear) {
    return Padding(
      padding: const EdgeInsets.only(right: 8.0),
      child: DropdownButtonHideUnderline(
        child: DropdownButton<int>(
          value: currentYear,
          icon: Icon(Icons.calendar_today_rounded,
              size: 18, color: theme.colorScheme.onSurfaceVariant),
          style: theme.textTheme.bodySmall
              ?.copyWith(color: theme.colorScheme.onSurfaceVariant),
          dropdownColor: theme.colorScheme
              .surfaceContainerHighest, // Corrected deprecated member
          items: List.generate(5, (index) => DateTime.now().year - index)
              .map((year) => DropdownMenuItem<int>(
                    value: year,
                    child: Text(year.toString()),
                  ))
              .toList(),
          onChanged: (newYear) {
            if (newYear != null && newYear != currentYear) {
              setState(() {
                _selectedYearForTrend = newYear;
              });
              final subCubitState = context.read<SubscriptionCubit>().state;
              subCubitState.whenOrNull(
                loaded: (allSubs, _, __, ___, ____, _____) => context
                    .read<StatisticsCubit>()
                    .changeTrendYear(allSubs, newYear),
              );
            }
          },
        ),
      ),
    );
  }
}


===== FILE: billing_type_breakdown_card.dart =====
===== PATH: lib/features/statistics/presentation/widgets/billing_type_breakdown_card.dart =====

import 'package:aboapp/features/statistics/presentation/cubit/statistics_cubit.dart'; // For BillingTypeSpending
import 'package:aboapp/features/subscriptions/domain/entities/subscription_entity.dart'; // For BillingCycle
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';

class BillingTypeBreakdownCard extends StatelessWidget {
  final List<BillingTypeSpending> billingTypeSpendingData;

  const BillingTypeBreakdownCard({
    super.key,
    required this.billingTypeSpendingData,
  });
  
  String _getBillingCycleLabel(BuildContext context, BillingCycle cycle) {
    // TODO: Localize
    switch (cycle) {
      case BillingCycle.weekly: return 'Weekly';
      case BillingCycle.monthly: return 'Monthly';
      case BillingCycle.quarterly: return 'Quarterly';
      case BillingCycle.biAnnual: return 'Bi-Annual';
      case BillingCycle.yearly: return 'Yearly';
      case BillingCycle.custom: return 'Custom';
    }
  }

  Color _getBillingCycleColor(BuildContext context, BillingCycle cycle) {
    // Use a consistent color mapping, possibly from AppColors or theme extensions
    final colors = [
      Colors.blue.shade300, Colors.purple.shade300, Colors.teal.shade300,
      Colors.orange.shade300, Colors.red.shade300, Colors.grey.shade400
    ];
    return colors[cycle.index % colors.length];
  }


  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    // TODO: Use locale/currency from SettingsCubit
    final currencyFormat = NumberFormat.currency(locale: 'de_DE', symbol: '€', decimalDigits: 0);

    if (billingTypeSpendingData.isEmpty) {
      return Card(
        elevation: 1.0,
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Center(
            child: Text(
              'No billing type data available.', // TODO: Localize
              style: theme.textTheme.bodyMedium,
            ),
          ),
        ),
      );
    }
    
    final totalMonthlyEquivalentSpending = billingTypeSpendingData.fold<double>(0, (sum, item) => sum + item.totalAmount);


    return Card(
      elevation: 1.0,
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Breakdown by Billing Cycle', // TODO: Localize
              style: theme.textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 8),
             Text(
              '(Based on Monthly Equivalent Cost)', // TODO: Localize
              style: theme.textTheme.bodySmall?.copyWith(color: theme.colorScheme.onSurfaceVariant),
            ),
            const SizedBox(height: 16),
            if (totalMonthlyEquivalentSpending > 0)
              LayoutBuilder(
                builder: (context, constraints) {
                  return ClipRRect(
                    borderRadius: BorderRadius.circular(8),
                    child: Row(
                      children: billingTypeSpendingData.map((item) {
                        final percentage = item.percentageOfTotal;
                        return Expanded(
                          flex: (percentage * 100).toInt().clamp(1, 100),
                          child: Container(
                            height: 24,
                            color: _getBillingCycleColor(context, item.billingCycle),
                          ),
                        );
                      }).toList(),
                    ),
                  );
                }
              ),
            const SizedBox(height: 16),
            ...billingTypeSpendingData.map((item) {
              return Padding(
                padding: const EdgeInsets.only(bottom: 8.0),
                child: Row(
                  children: [
                    Container(
                      width: 12,
                      height: 12,
                      decoration: BoxDecoration(
                        color: _getBillingCycleColor(context, item.billingCycle),
                        borderRadius: BorderRadius.circular(3.0),
                      ),
                    ),
                    const SizedBox(width: 8.0),
                    Expanded(
                      flex: 3,
                      child: Text(
                        _getBillingCycleLabel(context, item.billingCycle),
                        style: theme.textTheme.bodyMedium,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                    Expanded(
                      flex: 2,
                      child: Text(
                        '${item.subscriptionCount} sub${item.subscriptionCount == 1 ? "" : "s"}', // TODO: Localize
                        style: theme.textTheme.bodySmall?.copyWith(color: theme.colorScheme.onSurfaceVariant),
                        textAlign: TextAlign.end,
                      ),
                    ),
                    const SizedBox(width: 12.0),
                    Expanded(
                      flex: 3,
                      child: Text(
                        currencyFormat.format(item.totalAmount),
                        style: theme.textTheme.bodyMedium?.copyWith(fontWeight: FontWeight.w600),
                        textAlign: TextAlign.end,
                      ),
                    ),
                     const SizedBox(width: 8.0),
                     Expanded(
                       flex: 2,
                       child: Text(
                        '(${(item.percentageOfTotal * 100).toStringAsFixed(0)}%)',
                        style: theme.textTheme.bodySmall?.copyWith(color: theme.colorScheme.onSurfaceVariant),
                        textAlign: TextAlign.end,
                                         ),
                     ),
                  ],
                ),
              );
            }),
          ],
        ),
      ),
    );
  }
}

===== FILE: category_spending_pie_chart_card.dart =====
===== PATH: lib/features/statistics/presentation/widgets/category_spending_pie_chart_card.dart =====

import 'package:aboapp/features/statistics/presentation/cubit/statistics_cubit.dart'; 
import 'package:aboapp/features/subscriptions/presentation/widgets/subscription_card_widget.dart'; // Import for CategoryDisplayHelpers
import 'package:fl_chart/fl_chart.dart';
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
// import 'package:aboapp/features/subscriptions/domain/entities/subscription_entity.dart'; // Unused import

class CategorySpendingPieChartCard extends StatefulWidget {
  final List<CategorySpending> categorySpendingData;

  const CategorySpendingPieChartCard({
    super.key,
    required this.categorySpendingData,
  });

  @override
  State<CategorySpendingPieChartCard> createState() => _CategorySpendingPieChartCardState();
}

class _CategorySpendingPieChartCardState extends State<CategorySpendingPieChartCard> {
  int? _touchedIndex;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    // TODO: Use locale/currency from SettingsCubit
    final currencyFormat = NumberFormat.currency(locale: 'de_DE', symbol: '€', decimalDigits: 0); 

    if (widget.categorySpendingData.isEmpty) {
      return Card(
        elevation: 1.0,
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Center(
            child: Text(
              'No category spending data available.', // TODO: Localize
              style: theme.textTheme.bodyMedium,
            ),
          ),
        ),
      );
    }
    
    final relevantData = widget.categorySpendingData.where((d) => d.totalAmount > 0.01).toList();
    if (relevantData.isEmpty) {
       return Card(
        elevation: 1.0,
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Center(
            child: Text(
              'No significant category spending.', // TODO: Localize
              style: theme.textTheme.bodyMedium,
            ),
          ),
        ),
      );
    }


    return Card(
      elevation: 1.0,
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Spending by Category', // TODO: Localize
              style: theme.textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 24),
            SizedBox(
              height: 180, 
              child: PieChart(
                PieChartData(
                  pieTouchData: PieTouchData(
                    touchCallback: (FlTouchEvent event, pieTouchResponse) {
                      setState(() {
                        if (!event.isInterestedForInteractions ||
                            pieTouchResponse == null ||
                            pieTouchResponse.touchedSection == null) {
                          _touchedIndex = -1;
                          return;
                        }
                        _touchedIndex = pieTouchResponse.touchedSection!.touchedSectionIndex;
                      });
                    },
                  ),
                  borderData: FlBorderData(show: false),
                  sectionsSpace: 2,
                  centerSpaceRadius: 45, 
                  sections: _generatePieChartSections(theme, relevantData),
                ),
              ),
            ),
            const SizedBox(height: 24),
            _buildLegend(theme, currencyFormat, relevantData),
          ],
        ),
      ),
    );
  }

  List<PieChartSectionData> _generatePieChartSections(ThemeData theme, List<CategorySpending> data) {
    return List.generate(data.length, (i) {
      final isTouched = i == _touchedIndex;
      final fontSize = isTouched ? 14.0 : 10.0;
      final radius = isTouched ? 70.0 : 60.0;
      final categoryData = data[i];

      return PieChartSectionData(
        color: categoryData.category.categoryDisplayIconColor(theme), 
        value: categoryData.totalAmount,
        title: '${(categoryData.percentage * 100).toStringAsFixed(0)}%',
        radius: radius,
        titleStyle: TextStyle(
          fontSize: fontSize,
          fontWeight: FontWeight.bold,
          color: ThemeData.estimateBrightnessForColor(categoryData.category.categoryDisplayIconColor(theme)) == Brightness.dark
                 ? Colors.white : Colors.black,
          shadows: const [Shadow(color: Colors.black26, blurRadius: 1)],
        ),
      );
    });
  }

  Widget _buildLegend(ThemeData theme, NumberFormat currencyFormat, List<CategorySpending> data) {
    return Wrap(
      spacing: 16.0,
      runSpacing: 8.0,
      alignment: WrapAlignment.center,
      children: data.map((categoryData) {
        final isTouched = data.indexOf(categoryData) == _touchedIndex;
        return AnimatedContainer(
          duration: const Duration(milliseconds: 150),
          padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
          decoration: BoxDecoration(
            color: isTouched ? categoryData.category.categoryDisplayIconColor(theme).withOpacity(0.2) : Colors.transparent,
            borderRadius: BorderRadius.circular(6),
          ),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              Container(
                width: 12,
                height: 12,
                decoration: BoxDecoration(
                  color: categoryData.category.categoryDisplayIconColor(theme),
                  shape: BoxShape.circle,
                ),
              ),
              const SizedBox(width: 6),
              Text(
                categoryData.category.displayName, // Using extension getter
                style: theme.textTheme.bodySmall?.copyWith(
                  fontWeight: isTouched ? FontWeight.bold : FontWeight.normal,
                ),
              ),
              const SizedBox(width: 4),
              Text(
                '(${currencyFormat.format(categoryData.totalAmount)})',
                 style: theme.textTheme.labelSmall?.copyWith(
                  color: theme.colorScheme.onSurfaceVariant,
                  fontWeight: isTouched ? FontWeight.bold : FontWeight.normal,
                ),
              )
            ],
          ),
        );
      }).toList(),
    );
  }
}


===== FILE: overall_spending_summary_card.dart =====
===== PATH: lib/features/statistics/presentation/widgets/overall_spending_summary_card.dart =====

import 'package:aboapp/widgets/animated_counter_widget.dart';
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';

class OverallSpendingSummaryCard extends StatelessWidget {
  final double totalMonthlySpending;
  final double totalYearlySpending;

  const OverallSpendingSummaryCard({
    super.key,
    required this.totalMonthlySpending,
    required this.totalYearlySpending,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    // TODO: Use locale/currency from SettingsCubit
    final currencyFormat = NumberFormat.currency(locale: 'de_DE', symbol: '€', decimalDigits: 2);

    return Card(
      elevation: 1.0,
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Spending Overview', // TODO: Localize
              style: theme.textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 16),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceAround,
              children: [
                _buildMetric(
                  context,
                  label: 'Monthly Total', // TODO: Localize
                  value: totalMonthlySpending,
                  currencyFormat: currencyFormat,
                  style: theme.textTheme.headlineSmall!.copyWith(
                    color: theme.colorScheme.primary,
                    fontWeight: FontWeight.bold,
                  ),
                  labelStyle: theme.textTheme.bodySmall!,
                ),
                _buildMetric(
                  context,
                  label: 'Yearly Total', // TODO: Localize
                  value: totalYearlySpending,
                  currencyFormat: currencyFormat,
                  style: theme.textTheme.titleLarge!.copyWith(
                    color: theme.colorScheme.secondary,
                     fontWeight: FontWeight.w600,
                  ),
                   labelStyle: theme.textTheme.bodySmall!,
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildMetric(
    BuildContext context, {
    required String label,
    required double value,
    required NumberFormat currencyFormat,
    required TextStyle style,
    required TextStyle labelStyle,
  }) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.center,
      children: [
        AnimatedCounterWidget(
          value: value,
          formatter: (val) => currencyFormat.format(val),
          style: style,
        ),
        const SizedBox(height: 2),
        Text(
          label,
          style: labelStyle.copyWith(color: Theme.of(context).colorScheme.onSurfaceVariant),
        ),
      ],
    );
  }
}

===== FILE: spending_trend_line_chart_card.dart =====
===== PATH: lib/features/statistics/presentation/widgets/spending_trend_line_chart_card.dart =====

import 'package:aboapp/features/statistics/presentation/cubit/statistics_cubit.dart'; 
import 'package:fl_chart/fl_chart.dart';
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';

class SpendingTrendLineChartCard extends StatelessWidget {
  final MonthlySpendingTrendData spendingTrendData;

  const SpendingTrendLineChartCard({
    super.key,
    required this.spendingTrendData,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    // TODO: Use locale/currency from SettingsCubit
    final currencyFormat = NumberFormat.currency(locale: 'de_DE', symbol: '€', decimalDigits: 0);

    if (spendingTrendData.spots.isEmpty) {
       return Card(
        elevation: 1.0,
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Center(
            child: Text(
              'No spending trend data available for ${spendingTrendData.year}.', // TODO: Localize
              style: theme.textTheme.bodyMedium,
            ),
          ),
        ),
      );
    }

    return Card(
      elevation: 1.0,
      child: Padding(
        padding: const EdgeInsets.fromLTRB(16, 16, 20, 20), 
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Spending Trend - ${spendingTrendData.year}', // TODO: Localize
              style: theme.textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 24),
            SizedBox(
              height: 200,
              child: LineChart(
                LineChartData(
                  gridData: FlGridData(
                    show: true,
                    drawVerticalLine: false,
                    horizontalInterval: (spendingTrendData.maxSpendingInYear > 0 ? spendingTrendData.maxSpendingInYear / 4 : 50.0).clamp(10.0, double.infinity), // Ensure double
                    getDrawingHorizontalLine: (value) {
                      return FlLine(
                        color: theme.dividerColor.withOpacity(0.5), // Kept withOpacity for dynamic non-const color
                        strokeWidth: 0.5,
                      );
                    },
                  ),
                  titlesData: FlTitlesData(
                    show: true,
                    rightTitles: const AxisTitles(sideTitles: SideTitles(showTitles: false)),
                    topTitles: const AxisTitles(sideTitles: SideTitles(showTitles: false)),
                    bottomTitles: AxisTitles(
                      sideTitles: SideTitles(
                        showTitles: true,
                        reservedSize: 30,
                        interval: 2, 
                        getTitlesWidget: (value, meta) {
                          // TODO: Localize month abbreviations
                          const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                          final int monthIndex = value.toInt() - 1;
                          if (monthIndex >= 0 && monthIndex < months.length) {
                            return SideTitleWidget(
                              axisSide: meta.axisSide,
                              space: 8.0,
                              child: Text(months[monthIndex], style: theme.textTheme.bodySmall),
                            );
                          }
                          return const Text('');
                        },
                      ),
                    ),
                    leftTitles: AxisTitles(
                      sideTitles: SideTitles(
                        showTitles: true,
                        reservedSize: 48,
                        getTitlesWidget: (value, meta) {
                          if (value == meta.max || value == meta.min) return const Text(''); 
                          return SideTitleWidget(
                            axisSide: meta.axisSide,
                            space: 4.0,
                            child: Text(currencyFormat.format(value), style: theme.textTheme.bodySmall),
                          );
                        },
                      ),
                    ),
                  ),
                  borderData: FlBorderData(show: false),
                  minX: 1,
                  maxX: 12,
                  minY: 0,
                  maxY: spendingTrendData.maxSpendingInYear > 0 ? spendingTrendData.maxSpendingInYear * 1.1 : 100, 
                  lineBarsData: [
                    LineChartBarData(
                      spots: spendingTrendData.spots,
                      isCurved: true,
                      gradient: LinearGradient(
                        colors: [theme.colorScheme.primary, theme.colorScheme.secondary],
                      ),
                      barWidth: 3.5,
                      isStrokeCapRound: true,
                      dotData: FlDotData(
                        show: true,
                        getDotPainter: (spot, percent, barData, index) =>
                            FlDotCirclePainter(
                                radius: 4,
                                color: Color.lerp(theme.colorScheme.primary, theme.colorScheme.secondary, percent / 100) ?? theme.colorScheme.primary,
                                strokeWidth: 1.5,
                                strokeColor: theme.cardColor, 
                        ),
                      ),
                      belowBarData: BarAreaData(
                        show: true,
                        gradient: LinearGradient(
                          colors: [
                            theme.colorScheme.primary.withOpacity(0.2),    // Kept withOpacity
                            theme.colorScheme.secondary.withOpacity(0.05), // Kept withOpacity
                          ],
                          begin: Alignment.topCenter,
                          end: Alignment.bottomCenter,
                        ),
                      ),
                    ),
                  ],
                  lineTouchData: LineTouchData(
                    handleBuiltInTouches: true,
                    touchTooltipData: LineTouchTooltipData(
                      getTooltipColor: (spot) => theme.colorScheme.surfaceContainerHighest, // Corrected: was tooltipBgColor
                      getTooltipItems: (List<LineBarSpot> touchedBarSpots) {
                        return touchedBarSpots.map((barSpot) {
                          final flSpot = barSpot;
                          // TODO: Localize month name and currency
                          final monthName = DateFormat.MMMM().format(DateTime(spendingTrendData.year, flSpot.x.toInt()));
                          return LineTooltipItem(
                            '$monthName: ${currencyFormat.format(flSpot.y)}\n',
                            TextStyle(
                              color: theme.colorScheme.onSurfaceVariant,
                              fontWeight: FontWeight.bold,
                            ),
                          );
                        }).toList();
                      },
                    ),
                  ),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

===== FILE: top_subscriptions_list_card.dart =====
===== PATH: lib/features/statistics/presentation/widgets/top_subscriptions_list_card.dart =====

import 'package:aboapp/features/subscriptions/domain/entities/subscription_entity.dart';
import 'package:aboapp/features/subscriptions/presentation/widgets/subscription_card_widget.dart'; // For CategoryDisplayHelpers
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';

class TopSubscriptionsListCard extends StatelessWidget {
  final List<SubscriptionEntity> topSubscriptions;

  const TopSubscriptionsListCard({
    super.key,
    required this.topSubscriptions,
  });
  
  // _getBillingCycleShortLabel removed as it was unused in this file

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    // TODO: Use locale/currency from SettingsCubit
    final currencyFormat = NumberFormat.currency(locale: 'de_DE', symbol: '€', decimalDigits: 2);

    if (topSubscriptions.isEmpty) {
      return Card(
        elevation: 1.0,
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Center(
            child: Text(
              'No subscriptions to display in top list.', // TODO: Localize
              style: theme.textTheme.bodyMedium,
            ),
          ),
        ),
      );
    }

    return Card(
      elevation: 1.0,
      child: Padding(
        padding: const EdgeInsets.symmetric(vertical: 8.0), 
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Padding(
              padding: const EdgeInsets.only(left: 16.0, top: 8.0, right: 16.0, bottom: 4.0),
              child: Text(
                'Top Spending Subscriptions', // TODO: Localize
                style: theme.textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold),
              ),
            ),
             Padding(
              padding: const EdgeInsets.only(left: 16.0, right: 16.0, bottom: 8.0),
              child: Text(
                '(Based on Monthly Equivalent Cost)', // TODO: Localize
                 style: theme.textTheme.bodySmall?.copyWith(color: theme.colorScheme.onSurfaceVariant),
              ),
            ),
            ListView.separated(
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(), 
              itemCount: topSubscriptions.length,
              itemBuilder: (context, index) {
                final sub = topSubscriptions[index];
                final rank = index + 1;
                return ListTile(
                  contentPadding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 4.0),
                  leading: CircleAvatar(
                    radius: 16,
                    backgroundColor: theme.colorScheme.primaryContainer,
                    child: Text(
                      '$rank',
                      style: theme.textTheme.labelSmall?.copyWith(
                        color: theme.colorScheme.onPrimaryContainer,
                        fontWeight: FontWeight.bold
                      ),
                    ),
                  ),
                  title: Text(
                    sub.name,
                    style: theme.textTheme.titleSmall?.copyWith(fontWeight: FontWeight.w500),
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
                  subtitle: Text(
                    sub.category.displayName, // Use extension from subscription_card_widget
                    style: theme.textTheme.bodySmall?.copyWith(color: theme.colorScheme.onSurfaceVariant),
                  ),
                  trailing: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    crossAxisAlignment: CrossAxisAlignment.end,
                    children: [
                      Text(
                        currencyFormat.format(sub.monthlyEquivalentPrice),
                        style: theme.textTheme.bodyMedium?.copyWith(fontWeight: FontWeight.bold),
                      ),
                      Text(
                        'per month', // TODO: Localize (as it's monthly equivalent)
                         style: theme.textTheme.labelSmall?.copyWith(color: theme.colorScheme.onSurfaceVariant),
                      )
                    ],
                  ),
                );
              },
              separatorBuilder: (context, index) => const Divider(height: 1, indent: 16, endIndent: 16),
            ),
          ],
        ),
      ),
    );
  }
}

===== FILE: subscription_local_datasource.dart =====
===== PATH: lib/features/subscriptions/data/datasources/subscription_local_datasource.dart =====

import 'dart:convert';
import 'package:aboapp/features/subscriptions/data/models/subscription_model.dart';
import 'package:injectable/injectable.dart';
import 'package:shared_preferences/shared_preferences.dart';

abstract class SubscriptionLocalDataSource {
  Future<List<SubscriptionModel>> getAllSubscriptions();
  Future<void> saveSubscription(SubscriptionModel subscription);
  Future<void> deleteSubscription(String id);
  Future<void> updateSubscription(SubscriptionModel subscription);
  Future<void> cacheSubscriptions(List<SubscriptionModel> subscriptions);
}

const String cachedSubscriptionsKey = 'CACHED_SUBSCRIPTIONS';

@LazySingleton(as: SubscriptionLocalDataSource)
class SubscriptionLocalDataSourceImpl implements SubscriptionLocalDataSource {
  final SharedPreferences sharedPreferences;

  SubscriptionLocalDataSourceImpl(this.sharedPreferences);

  @override
  Future<List<SubscriptionModel>> getAllSubscriptions() async {
    final jsonStringList = sharedPreferences.getStringList(cachedSubscriptionsKey);
    if (jsonStringList != null) {
      try {
        return jsonStringList
            .map((jsonString) =>
                SubscriptionModel.fromJson(jsonDecode(jsonString) as Map<String, dynamic>))
            .toList();
      } catch (e) {
        // Handle corrupted data, e.g., by clearing it or logging
        await sharedPreferences.remove(cachedSubscriptionsKey);
        throw Exception('Failed to parse subscriptions from local storage: $e');
      }
    } else {
      return [];
    }
  }

  @override
  Future<void> cacheSubscriptions(List<SubscriptionModel> subscriptions) async {
    final List<String> jsonStringList =
        subscriptions.map((sub) => jsonEncode(sub.toJson())).toList();
    await sharedPreferences.setStringList(cachedSubscriptionsKey, jsonStringList);
  }

  @override
  Future<void> saveSubscription(SubscriptionModel subscription) async {
    final subscriptions = await getAllSubscriptions();
    subscriptions.add(subscription);
    await cacheSubscriptions(subscriptions);
  }

  @override
  Future<void> updateSubscription(SubscriptionModel subscription) async {
    final subscriptions = await getAllSubscriptions();
    final index = subscriptions.indexWhere((sub) => sub.id == subscription.id);
    if (index != -1) {
      subscriptions[index] = subscription;
      await cacheSubscriptions(subscriptions);
    } else {
      // Optionally handle case where subscription to update is not found
      // For now, it just won't do anything if not found.
      // Or, throw an exception:
      // throw Exception('Subscription with id ${subscription.id} not found for update.');
    }
  }

  @override
  Future<void> deleteSubscription(String id) async {
    final subscriptions = await getAllSubscriptions();
    subscriptions.removeWhere((sub) => sub.id == id);
    await cacheSubscriptions(subscriptions);
  }
}

===== FILE: subscription_model.dart =====
===== PATH: lib/features/subscriptions/data/models/subscription_model.dart =====

import 'package:aboapp/core/utils/color_serializer.dart';
import 'package:aboapp/features/subscriptions/domain/entities/subscription_entity.dart';
import 'package:flutter/material.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

part 'subscription_model.freezed.dart';
part 'subscription_model.g.dart';

@freezed
// ANNOTATION MOVED TO THE CLASS ITSELF
@JsonSerializable(explicitToJson: true)
class SubscriptionModel with _$SubscriptionModel {
  // NO PRIVATE CONSTRUCTOR HERE

  const factory SubscriptionModel({
    required String id,
    required String name,
    required double price,
    @JsonKey(unknownEnumValue: BillingCycle.custom)
    required BillingCycle billingCycle,
    required DateTime nextBillingDate,
    @JsonKey(unknownEnumValue: SubscriptionCategory.other)
    required SubscriptionCategory category,
    DateTime? startDate,
    String? description,
    String? logoUrl,
    @ColorSerializer() Color? color,
    @Default(true) bool isActive,
    @Default(true) bool notificationsEnabled,
    @Default(7) int notificationDaysBefore,
    DateTime? trialEndDate,
    Map<String, dynamic>? customCycleDetails,
    String? notes,
  }) = _SubscriptionModel;

  factory SubscriptionModel.fromJson(Map<String, dynamic> json) =>
      _$SubscriptionModelFromJson(json);
}

// --- Helper methods moved to extensions ---
extension SubscriptionModelHelpers on SubscriptionModel {
  SubscriptionEntity toEntity() {
    return SubscriptionEntity(
      id: id,
      name: name,
      price: price,
      billingCycle: billingCycle,
      nextBillingDate: nextBillingDate,
      category: category,
      startDate: startDate,
      description: description,
      logoUrl: logoUrl,
      color: color,
      isActive: isActive,
      notificationsEnabled: notificationsEnabled,
      notificationDaysBefore: notificationDaysBefore,
      trialEndDate: trialEndDate,
      customCycleDetails: customCycleDetails,
      notes: notes,
    );
  }
}

extension SubscriptionModelFromEntity on SubscriptionModel {
  static SubscriptionModel fromEntity(SubscriptionEntity entity) {
    return SubscriptionModel(
      id: entity.id,
      name: entity.name,
      price: entity.price,
      billingCycle: entity.billingCycle,
      nextBillingDate: entity.nextBillingDate,
      category: entity.category,
      startDate: entity.startDate,
      description: entity.description,
      logoUrl: entity.logoUrl,
      color: entity.color,
      isActive: entity.isActive,
      notificationsEnabled: entity.notificationsEnabled,
      notificationDaysBefore: entity.notificationDaysBefore,
      trialEndDate: entity.trialEndDate,
      customCycleDetails: entity.customCycleDetails,
      notes: entity.notes,
    );
  }
}


===== FILE: subscription_model.freezed.dart =====
===== PATH: lib/features/subscriptions/data/models/subscription_model.freezed.dart =====

// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'subscription_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

SubscriptionModel _$SubscriptionModelFromJson(Map<String, dynamic> json) {
  return _SubscriptionModel.fromJson(json);
}

/// @nodoc
mixin _$SubscriptionModel {
  String get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  double get price => throw _privateConstructorUsedError;
  @JsonKey(unknownEnumValue: BillingCycle.custom)
  BillingCycle get billingCycle => throw _privateConstructorUsedError;
  DateTime get nextBillingDate => throw _privateConstructorUsedError;
  @JsonKey(unknownEnumValue: SubscriptionCategory.other)
  SubscriptionCategory get category => throw _privateConstructorUsedError;
  DateTime? get startDate => throw _privateConstructorUsedError;
  String? get description => throw _privateConstructorUsedError;
  String? get logoUrl => throw _privateConstructorUsedError;
  @ColorSerializer()
  Color? get color => throw _privateConstructorUsedError;
  bool get isActive => throw _privateConstructorUsedError;
  bool get notificationsEnabled => throw _privateConstructorUsedError;
  int get notificationDaysBefore => throw _privateConstructorUsedError;
  DateTime? get trialEndDate => throw _privateConstructorUsedError;
  Map<String, dynamic>? get customCycleDetails =>
      throw _privateConstructorUsedError;
  String? get notes => throw _privateConstructorUsedError;

  /// Serializes this SubscriptionModel to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of SubscriptionModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SubscriptionModelCopyWith<SubscriptionModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubscriptionModelCopyWith<$Res> {
  factory $SubscriptionModelCopyWith(
          SubscriptionModel value, $Res Function(SubscriptionModel) then) =
      _$SubscriptionModelCopyWithImpl<$Res, SubscriptionModel>;
  @useResult
  $Res call(
      {String id,
      String name,
      double price,
      @JsonKey(unknownEnumValue: BillingCycle.custom) BillingCycle billingCycle,
      DateTime nextBillingDate,
      @JsonKey(unknownEnumValue: SubscriptionCategory.other)
      SubscriptionCategory category,
      DateTime? startDate,
      String? description,
      String? logoUrl,
      @ColorSerializer() Color? color,
      bool isActive,
      bool notificationsEnabled,
      int notificationDaysBefore,
      DateTime? trialEndDate,
      Map<String, dynamic>? customCycleDetails,
      String? notes});
}

/// @nodoc
class _$SubscriptionModelCopyWithImpl<$Res, $Val extends SubscriptionModel>
    implements $SubscriptionModelCopyWith<$Res> {
  _$SubscriptionModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SubscriptionModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? price = null,
    Object? billingCycle = null,
    Object? nextBillingDate = null,
    Object? category = null,
    Object? startDate = freezed,
    Object? description = freezed,
    Object? logoUrl = freezed,
    Object? color = freezed,
    Object? isActive = null,
    Object? notificationsEnabled = null,
    Object? notificationDaysBefore = null,
    Object? trialEndDate = freezed,
    Object? customCycleDetails = freezed,
    Object? notes = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      price: null == price
          ? _value.price
          : price // ignore: cast_nullable_to_non_nullable
              as double,
      billingCycle: null == billingCycle
          ? _value.billingCycle
          : billingCycle // ignore: cast_nullable_to_non_nullable
              as BillingCycle,
      nextBillingDate: null == nextBillingDate
          ? _value.nextBillingDate
          : nextBillingDate // ignore: cast_nullable_to_non_nullable
              as DateTime,
      category: null == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as SubscriptionCategory,
      startDate: freezed == startDate
          ? _value.startDate
          : startDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      logoUrl: freezed == logoUrl
          ? _value.logoUrl
          : logoUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      color: freezed == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color?,
      isActive: null == isActive
          ? _value.isActive
          : isActive // ignore: cast_nullable_to_non_nullable
              as bool,
      notificationsEnabled: null == notificationsEnabled
          ? _value.notificationsEnabled
          : notificationsEnabled // ignore: cast_nullable_to_non_nullable
              as bool,
      notificationDaysBefore: null == notificationDaysBefore
          ? _value.notificationDaysBefore
          : notificationDaysBefore // ignore: cast_nullable_to_non_nullable
              as int,
      trialEndDate: freezed == trialEndDate
          ? _value.trialEndDate
          : trialEndDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      customCycleDetails: freezed == customCycleDetails
          ? _value.customCycleDetails
          : customCycleDetails // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      notes: freezed == notes
          ? _value.notes
          : notes // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SubscriptionModelImplCopyWith<$Res>
    implements $SubscriptionModelCopyWith<$Res> {
  factory _$$SubscriptionModelImplCopyWith(_$SubscriptionModelImpl value,
          $Res Function(_$SubscriptionModelImpl) then) =
      __$$SubscriptionModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      double price,
      @JsonKey(unknownEnumValue: BillingCycle.custom) BillingCycle billingCycle,
      DateTime nextBillingDate,
      @JsonKey(unknownEnumValue: SubscriptionCategory.other)
      SubscriptionCategory category,
      DateTime? startDate,
      String? description,
      String? logoUrl,
      @ColorSerializer() Color? color,
      bool isActive,
      bool notificationsEnabled,
      int notificationDaysBefore,
      DateTime? trialEndDate,
      Map<String, dynamic>? customCycleDetails,
      String? notes});
}

/// @nodoc
class __$$SubscriptionModelImplCopyWithImpl<$Res>
    extends _$SubscriptionModelCopyWithImpl<$Res, _$SubscriptionModelImpl>
    implements _$$SubscriptionModelImplCopyWith<$Res> {
  __$$SubscriptionModelImplCopyWithImpl(_$SubscriptionModelImpl _value,
      $Res Function(_$SubscriptionModelImpl) _then)
      : super(_value, _then);

  /// Create a copy of SubscriptionModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? price = null,
    Object? billingCycle = null,
    Object? nextBillingDate = null,
    Object? category = null,
    Object? startDate = freezed,
    Object? description = freezed,
    Object? logoUrl = freezed,
    Object? color = freezed,
    Object? isActive = null,
    Object? notificationsEnabled = null,
    Object? notificationDaysBefore = null,
    Object? trialEndDate = freezed,
    Object? customCycleDetails = freezed,
    Object? notes = freezed,
  }) {
    return _then(_$SubscriptionModelImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      price: null == price
          ? _value.price
          : price // ignore: cast_nullable_to_non_nullable
              as double,
      billingCycle: null == billingCycle
          ? _value.billingCycle
          : billingCycle // ignore: cast_nullable_to_non_nullable
              as BillingCycle,
      nextBillingDate: null == nextBillingDate
          ? _value.nextBillingDate
          : nextBillingDate // ignore: cast_nullable_to_non_nullable
              as DateTime,
      category: null == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as SubscriptionCategory,
      startDate: freezed == startDate
          ? _value.startDate
          : startDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      logoUrl: freezed == logoUrl
          ? _value.logoUrl
          : logoUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      color: freezed == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color?,
      isActive: null == isActive
          ? _value.isActive
          : isActive // ignore: cast_nullable_to_non_nullable
              as bool,
      notificationsEnabled: null == notificationsEnabled
          ? _value.notificationsEnabled
          : notificationsEnabled // ignore: cast_nullable_to_non_nullable
              as bool,
      notificationDaysBefore: null == notificationDaysBefore
          ? _value.notificationDaysBefore
          : notificationDaysBefore // ignore: cast_nullable_to_non_nullable
              as int,
      trialEndDate: freezed == trialEndDate
          ? _value.trialEndDate
          : trialEndDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      customCycleDetails: freezed == customCycleDetails
          ? _value._customCycleDetails
          : customCycleDetails // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      notes: freezed == notes
          ? _value.notes
          : notes // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$SubscriptionModelImpl implements _SubscriptionModel {
  const _$SubscriptionModelImpl(
      {required this.id,
      required this.name,
      required this.price,
      @JsonKey(unknownEnumValue: BillingCycle.custom)
      required this.billingCycle,
      required this.nextBillingDate,
      @JsonKey(unknownEnumValue: SubscriptionCategory.other)
      required this.category,
      this.startDate,
      this.description,
      this.logoUrl,
      @ColorSerializer() this.color,
      this.isActive = true,
      this.notificationsEnabled = true,
      this.notificationDaysBefore = 7,
      this.trialEndDate,
      final Map<String, dynamic>? customCycleDetails,
      this.notes})
      : _customCycleDetails = customCycleDetails;

  factory _$SubscriptionModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$SubscriptionModelImplFromJson(json);

  @override
  final String id;
  @override
  final String name;
  @override
  final double price;
  @override
  @JsonKey(unknownEnumValue: BillingCycle.custom)
  final BillingCycle billingCycle;
  @override
  final DateTime nextBillingDate;
  @override
  @JsonKey(unknownEnumValue: SubscriptionCategory.other)
  final SubscriptionCategory category;
  @override
  final DateTime? startDate;
  @override
  final String? description;
  @override
  final String? logoUrl;
  @override
  @ColorSerializer()
  final Color? color;
  @override
  @JsonKey()
  final bool isActive;
  @override
  @JsonKey()
  final bool notificationsEnabled;
  @override
  @JsonKey()
  final int notificationDaysBefore;
  @override
  final DateTime? trialEndDate;
  final Map<String, dynamic>? _customCycleDetails;
  @override
  Map<String, dynamic>? get customCycleDetails {
    final value = _customCycleDetails;
    if (value == null) return null;
    if (_customCycleDetails is EqualUnmodifiableMapView)
      return _customCycleDetails;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  final String? notes;

  @override
  String toString() {
    return 'SubscriptionModel(id: $id, name: $name, price: $price, billingCycle: $billingCycle, nextBillingDate: $nextBillingDate, category: $category, startDate: $startDate, description: $description, logoUrl: $logoUrl, color: $color, isActive: $isActive, notificationsEnabled: $notificationsEnabled, notificationDaysBefore: $notificationDaysBefore, trialEndDate: $trialEndDate, customCycleDetails: $customCycleDetails, notes: $notes)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SubscriptionModelImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.price, price) || other.price == price) &&
            (identical(other.billingCycle, billingCycle) ||
                other.billingCycle == billingCycle) &&
            (identical(other.nextBillingDate, nextBillingDate) ||
                other.nextBillingDate == nextBillingDate) &&
            (identical(other.category, category) ||
                other.category == category) &&
            (identical(other.startDate, startDate) ||
                other.startDate == startDate) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.logoUrl, logoUrl) || other.logoUrl == logoUrl) &&
            (identical(other.color, color) || other.color == color) &&
            (identical(other.isActive, isActive) ||
                other.isActive == isActive) &&
            (identical(other.notificationsEnabled, notificationsEnabled) ||
                other.notificationsEnabled == notificationsEnabled) &&
            (identical(other.notificationDaysBefore, notificationDaysBefore) ||
                other.notificationDaysBefore == notificationDaysBefore) &&
            (identical(other.trialEndDate, trialEndDate) ||
                other.trialEndDate == trialEndDate) &&
            const DeepCollectionEquality()
                .equals(other._customCycleDetails, _customCycleDetails) &&
            (identical(other.notes, notes) || other.notes == notes));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      name,
      price,
      billingCycle,
      nextBillingDate,
      category,
      startDate,
      description,
      logoUrl,
      color,
      isActive,
      notificationsEnabled,
      notificationDaysBefore,
      trialEndDate,
      const DeepCollectionEquality().hash(_customCycleDetails),
      notes);

  /// Create a copy of SubscriptionModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SubscriptionModelImplCopyWith<_$SubscriptionModelImpl> get copyWith =>
      __$$SubscriptionModelImplCopyWithImpl<_$SubscriptionModelImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$SubscriptionModelImplToJson(
      this,
    );
  }
}

abstract class _SubscriptionModel implements SubscriptionModel {
  const factory _SubscriptionModel(
      {required final String id,
      required final String name,
      required final double price,
      @JsonKey(unknownEnumValue: BillingCycle.custom)
      required final BillingCycle billingCycle,
      required final DateTime nextBillingDate,
      @JsonKey(unknownEnumValue: SubscriptionCategory.other)
      required final SubscriptionCategory category,
      final DateTime? startDate,
      final String? description,
      final String? logoUrl,
      @ColorSerializer() final Color? color,
      final bool isActive,
      final bool notificationsEnabled,
      final int notificationDaysBefore,
      final DateTime? trialEndDate,
      final Map<String, dynamic>? customCycleDetails,
      final String? notes}) = _$SubscriptionModelImpl;

  factory _SubscriptionModel.fromJson(Map<String, dynamic> json) =
      _$SubscriptionModelImpl.fromJson;

  @override
  String get id;
  @override
  String get name;
  @override
  double get price;
  @override
  @JsonKey(unknownEnumValue: BillingCycle.custom)
  BillingCycle get billingCycle;
  @override
  DateTime get nextBillingDate;
  @override
  @JsonKey(unknownEnumValue: SubscriptionCategory.other)
  SubscriptionCategory get category;
  @override
  DateTime? get startDate;
  @override
  String? get description;
  @override
  String? get logoUrl;
  @override
  @ColorSerializer()
  Color? get color;
  @override
  bool get isActive;
  @override
  bool get notificationsEnabled;
  @override
  int get notificationDaysBefore;
  @override
  DateTime? get trialEndDate;
  @override
  Map<String, dynamic>? get customCycleDetails;
  @override
  String? get notes;

  /// Create a copy of SubscriptionModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SubscriptionModelImplCopyWith<_$SubscriptionModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}


===== FILE: subscription_repository_impl.dart =====
===== PATH: lib/features/subscriptions/data/repositories/subscription_repository_impl.dart =====

import 'package:aboapp/features/subscriptions/data/datasources/subscription_local_datasource.dart';
import 'package:aboapp/features/subscriptions/data/models/subscription_model.dart';
import 'package:aboapp/features/subscriptions/domain/entities/subscription_entity.dart';
import 'package:aboapp/features/subscriptions/domain/repositories/subscription_repository.dart';
import 'package:injectable/injectable.dart';

@LazySingleton(as: SubscriptionRepository)
class SubscriptionRepositoryImpl implements SubscriptionRepository {
  final SubscriptionLocalDataSource localDataSource;

  SubscriptionRepositoryImpl({
    required this.localDataSource,
  });

  @override
  Future<List<SubscriptionEntity>> getAllSubscriptions() async {
    try {
      final localSubscriptions = await localDataSource.getAllSubscriptions();
      return localSubscriptions.map((model) => model.toEntity()).toList();
    } catch (e) {
      // print('Error fetching subscriptions: $e'); // Avoid print
      throw Exception('Could not load subscriptions.'); 
    }
  }

  @override
  Future<SubscriptionEntity?> getSubscriptionById(String id) async {
    final allSubscriptions = await getAllSubscriptions();
    try {
      return allSubscriptions.firstWhere((sub) => sub.id == id);
    } catch (e) {
      return null; 
    }
  }

  @override
  Future<void> addSubscription(SubscriptionEntity subscription) async {
    final model = SubscriptionModel.fromEntity(subscription);
    await localDataSource.saveSubscription(model);
  }

  @override
  Future<void> updateSubscription(SubscriptionEntity subscription) async {
    final model = SubscriptionModel.fromEntity(subscription);
    await localDataSource.updateSubscription(model);
  }

  @override
  Future<void> deleteSubscription(String id) async {
    await localDataSource.deleteSubscription(id);
  }

  @override
  Future<void> saveAllSubscriptions(List<SubscriptionEntity> subscriptions) async {
    final models = subscriptions.map((e) => SubscriptionModel.fromEntity(e)).toList();
    await localDataSource.cacheSubscriptions(models);
  }
}

===== FILE: subscription_entity.dart =====
===== PATH: lib/features/subscriptions/domain/entities/subscription_entity.dart =====

import 'package:flutter/material.dart'; 
import 'package:freezed_annotation/freezed_annotation.dart';

part 'subscription_entity.freezed.dart'; 

enum BillingCycle {
  weekly,
  monthly,
  quarterly,
  biAnnual, 
  yearly,
  custom, 
}

enum SubscriptionCategory {
  streaming,
  software,
  gaming,
  fitness,
  music,
  news,
  cloud,
  utilities, 
  education, 
  other,
}

@freezed
class SubscriptionEntity with _$SubscriptionEntity {
  const SubscriptionEntity._(); 

  const factory SubscriptionEntity({
    required String id,
    required String name,
    required double price, 
    required BillingCycle billingCycle,
    required DateTime nextBillingDate,
    required SubscriptionCategory category,
    DateTime? startDate,
    String? description,
    String? logoUrl, 
    Color? color,     
    @Default(true) bool isActive,
    @Default(true) bool notificationsEnabled,
    @Default(7) int notificationDaysBefore,
    DateTime? trialEndDate,
    Map<String, dynamic>? customCycleDetails, 
    String? notes, 
  }) = _SubscriptionEntity;

  bool get isInTrial {
    if (trialEndDate == null) return false;
    return DateTime.now().isBefore(trialEndDate!);
  }

  int get daysUntilBilling {
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    final nextBillingDay = DateTime(nextBillingDate.year, nextBillingDate.month, nextBillingDate.day);
    return nextBillingDay.difference(today).inDays;
  }

  double get monthlyEquivalentPrice {
    switch (billingCycle) {
      case BillingCycle.weekly:
        return price * (365.25 / 12 / 7); 
      case BillingCycle.monthly:
        return price;
      case BillingCycle.quarterly:
        return price / 3.0;
      case BillingCycle.biAnnual:
        return price / 6.0;
      case BillingCycle.yearly:
        return price / 12.0;
      case BillingCycle.custom:
        final days = customCycleDetails?['value'] as int?;
        if (days != null && days > 0) {
          return price * (30.4375 / days); 
        }
        return price; 
      // No default needed if all cases are covered, but good for safety if enum changes.
      // However, the linter for unreachable_switch_default will trigger if all are covered.
      // Removing default as the error was for it being unreachable.
    }
  }
}

// Moved extensions for SubscriptionCategory to subscription_card_widget.dart
// to keep entity cleaner and consolidate UI helpers.

===== FILE: subscription_entity.freezed.dart =====
===== PATH: lib/features/subscriptions/domain/entities/subscription_entity.freezed.dart =====

// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'subscription_entity.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$SubscriptionEntity {
  String get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  double get price => throw _privateConstructorUsedError;
  BillingCycle get billingCycle => throw _privateConstructorUsedError;
  DateTime get nextBillingDate => throw _privateConstructorUsedError;
  SubscriptionCategory get category => throw _privateConstructorUsedError;
  DateTime? get startDate => throw _privateConstructorUsedError;
  String? get description => throw _privateConstructorUsedError;
  String? get logoUrl => throw _privateConstructorUsedError;
  Color? get color => throw _privateConstructorUsedError;
  bool get isActive => throw _privateConstructorUsedError;
  bool get notificationsEnabled => throw _privateConstructorUsedError;
  int get notificationDaysBefore => throw _privateConstructorUsedError;
  DateTime? get trialEndDate => throw _privateConstructorUsedError;
  Map<String, dynamic>? get customCycleDetails =>
      throw _privateConstructorUsedError;
  String? get notes => throw _privateConstructorUsedError;

  /// Create a copy of SubscriptionEntity
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SubscriptionEntityCopyWith<SubscriptionEntity> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubscriptionEntityCopyWith<$Res> {
  factory $SubscriptionEntityCopyWith(
          SubscriptionEntity value, $Res Function(SubscriptionEntity) then) =
      _$SubscriptionEntityCopyWithImpl<$Res, SubscriptionEntity>;
  @useResult
  $Res call(
      {String id,
      String name,
      double price,
      BillingCycle billingCycle,
      DateTime nextBillingDate,
      SubscriptionCategory category,
      DateTime? startDate,
      String? description,
      String? logoUrl,
      Color? color,
      bool isActive,
      bool notificationsEnabled,
      int notificationDaysBefore,
      DateTime? trialEndDate,
      Map<String, dynamic>? customCycleDetails,
      String? notes});
}

/// @nodoc
class _$SubscriptionEntityCopyWithImpl<$Res, $Val extends SubscriptionEntity>
    implements $SubscriptionEntityCopyWith<$Res> {
  _$SubscriptionEntityCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SubscriptionEntity
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? price = null,
    Object? billingCycle = null,
    Object? nextBillingDate = null,
    Object? category = null,
    Object? startDate = freezed,
    Object? description = freezed,
    Object? logoUrl = freezed,
    Object? color = freezed,
    Object? isActive = null,
    Object? notificationsEnabled = null,
    Object? notificationDaysBefore = null,
    Object? trialEndDate = freezed,
    Object? customCycleDetails = freezed,
    Object? notes = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      price: null == price
          ? _value.price
          : price // ignore: cast_nullable_to_non_nullable
              as double,
      billingCycle: null == billingCycle
          ? _value.billingCycle
          : billingCycle // ignore: cast_nullable_to_non_nullable
              as BillingCycle,
      nextBillingDate: null == nextBillingDate
          ? _value.nextBillingDate
          : nextBillingDate // ignore: cast_nullable_to_non_nullable
              as DateTime,
      category: null == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as SubscriptionCategory,
      startDate: freezed == startDate
          ? _value.startDate
          : startDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      logoUrl: freezed == logoUrl
          ? _value.logoUrl
          : logoUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      color: freezed == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color?,
      isActive: null == isActive
          ? _value.isActive
          : isActive // ignore: cast_nullable_to_non_nullable
              as bool,
      notificationsEnabled: null == notificationsEnabled
          ? _value.notificationsEnabled
          : notificationsEnabled // ignore: cast_nullable_to_non_nullable
              as bool,
      notificationDaysBefore: null == notificationDaysBefore
          ? _value.notificationDaysBefore
          : notificationDaysBefore // ignore: cast_nullable_to_non_nullable
              as int,
      trialEndDate: freezed == trialEndDate
          ? _value.trialEndDate
          : trialEndDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      customCycleDetails: freezed == customCycleDetails
          ? _value.customCycleDetails
          : customCycleDetails // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      notes: freezed == notes
          ? _value.notes
          : notes // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SubscriptionEntityImplCopyWith<$Res>
    implements $SubscriptionEntityCopyWith<$Res> {
  factory _$$SubscriptionEntityImplCopyWith(_$SubscriptionEntityImpl value,
          $Res Function(_$SubscriptionEntityImpl) then) =
      __$$SubscriptionEntityImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      double price,
      BillingCycle billingCycle,
      DateTime nextBillingDate,
      SubscriptionCategory category,
      DateTime? startDate,
      String? description,
      String? logoUrl,
      Color? color,
      bool isActive,
      bool notificationsEnabled,
      int notificationDaysBefore,
      DateTime? trialEndDate,
      Map<String, dynamic>? customCycleDetails,
      String? notes});
}

/// @nodoc
class __$$SubscriptionEntityImplCopyWithImpl<$Res>
    extends _$SubscriptionEntityCopyWithImpl<$Res, _$SubscriptionEntityImpl>
    implements _$$SubscriptionEntityImplCopyWith<$Res> {
  __$$SubscriptionEntityImplCopyWithImpl(_$SubscriptionEntityImpl _value,
      $Res Function(_$SubscriptionEntityImpl) _then)
      : super(_value, _then);

  /// Create a copy of SubscriptionEntity
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? price = null,
    Object? billingCycle = null,
    Object? nextBillingDate = null,
    Object? category = null,
    Object? startDate = freezed,
    Object? description = freezed,
    Object? logoUrl = freezed,
    Object? color = freezed,
    Object? isActive = null,
    Object? notificationsEnabled = null,
    Object? notificationDaysBefore = null,
    Object? trialEndDate = freezed,
    Object? customCycleDetails = freezed,
    Object? notes = freezed,
  }) {
    return _then(_$SubscriptionEntityImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      price: null == price
          ? _value.price
          : price // ignore: cast_nullable_to_non_nullable
              as double,
      billingCycle: null == billingCycle
          ? _value.billingCycle
          : billingCycle // ignore: cast_nullable_to_non_nullable
              as BillingCycle,
      nextBillingDate: null == nextBillingDate
          ? _value.nextBillingDate
          : nextBillingDate // ignore: cast_nullable_to_non_nullable
              as DateTime,
      category: null == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as SubscriptionCategory,
      startDate: freezed == startDate
          ? _value.startDate
          : startDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      logoUrl: freezed == logoUrl
          ? _value.logoUrl
          : logoUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      color: freezed == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color?,
      isActive: null == isActive
          ? _value.isActive
          : isActive // ignore: cast_nullable_to_non_nullable
              as bool,
      notificationsEnabled: null == notificationsEnabled
          ? _value.notificationsEnabled
          : notificationsEnabled // ignore: cast_nullable_to_non_nullable
              as bool,
      notificationDaysBefore: null == notificationDaysBefore
          ? _value.notificationDaysBefore
          : notificationDaysBefore // ignore: cast_nullable_to_non_nullable
              as int,
      trialEndDate: freezed == trialEndDate
          ? _value.trialEndDate
          : trialEndDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      customCycleDetails: freezed == customCycleDetails
          ? _value._customCycleDetails
          : customCycleDetails // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      notes: freezed == notes
          ? _value.notes
          : notes // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$SubscriptionEntityImpl extends _SubscriptionEntity {
  const _$SubscriptionEntityImpl(
      {required this.id,
      required this.name,
      required this.price,
      required this.billingCycle,
      required this.nextBillingDate,
      required this.category,
      this.startDate,
      this.description,
      this.logoUrl,
      this.color,
      this.isActive = true,
      this.notificationsEnabled = true,
      this.notificationDaysBefore = 7,
      this.trialEndDate,
      final Map<String, dynamic>? customCycleDetails,
      this.notes})
      : _customCycleDetails = customCycleDetails,
        super._();

  @override
  final String id;
  @override
  final String name;
  @override
  final double price;
  @override
  final BillingCycle billingCycle;
  @override
  final DateTime nextBillingDate;
  @override
  final SubscriptionCategory category;
  @override
  final DateTime? startDate;
  @override
  final String? description;
  @override
  final String? logoUrl;
  @override
  final Color? color;
  @override
  @JsonKey()
  final bool isActive;
  @override
  @JsonKey()
  final bool notificationsEnabled;
  @override
  @JsonKey()
  final int notificationDaysBefore;
  @override
  final DateTime? trialEndDate;
  final Map<String, dynamic>? _customCycleDetails;
  @override
  Map<String, dynamic>? get customCycleDetails {
    final value = _customCycleDetails;
    if (value == null) return null;
    if (_customCycleDetails is EqualUnmodifiableMapView)
      return _customCycleDetails;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  final String? notes;

  @override
  String toString() {
    return 'SubscriptionEntity(id: $id, name: $name, price: $price, billingCycle: $billingCycle, nextBillingDate: $nextBillingDate, category: $category, startDate: $startDate, description: $description, logoUrl: $logoUrl, color: $color, isActive: $isActive, notificationsEnabled: $notificationsEnabled, notificationDaysBefore: $notificationDaysBefore, trialEndDate: $trialEndDate, customCycleDetails: $customCycleDetails, notes: $notes)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SubscriptionEntityImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.price, price) || other.price == price) &&
            (identical(other.billingCycle, billingCycle) ||
                other.billingCycle == billingCycle) &&
            (identical(other.nextBillingDate, nextBillingDate) ||
                other.nextBillingDate == nextBillingDate) &&
            (identical(other.category, category) ||
                other.category == category) &&
            (identical(other.startDate, startDate) ||
                other.startDate == startDate) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.logoUrl, logoUrl) || other.logoUrl == logoUrl) &&
            (identical(other.color, color) || other.color == color) &&
            (identical(other.isActive, isActive) ||
                other.isActive == isActive) &&
            (identical(other.notificationsEnabled, notificationsEnabled) ||
                other.notificationsEnabled == notificationsEnabled) &&
            (identical(other.notificationDaysBefore, notificationDaysBefore) ||
                other.notificationDaysBefore == notificationDaysBefore) &&
            (identical(other.trialEndDate, trialEndDate) ||
                other.trialEndDate == trialEndDate) &&
            const DeepCollectionEquality()
                .equals(other._customCycleDetails, _customCycleDetails) &&
            (identical(other.notes, notes) || other.notes == notes));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      name,
      price,
      billingCycle,
      nextBillingDate,
      category,
      startDate,
      description,
      logoUrl,
      color,
      isActive,
      notificationsEnabled,
      notificationDaysBefore,
      trialEndDate,
      const DeepCollectionEquality().hash(_customCycleDetails),
      notes);

  /// Create a copy of SubscriptionEntity
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SubscriptionEntityImplCopyWith<_$SubscriptionEntityImpl> get copyWith =>
      __$$SubscriptionEntityImplCopyWithImpl<_$SubscriptionEntityImpl>(
          this, _$identity);
}

abstract class _SubscriptionEntity extends SubscriptionEntity {
  const factory _SubscriptionEntity(
      {required final String id,
      required final String name,
      required final double price,
      required final BillingCycle billingCycle,
      required final DateTime nextBillingDate,
      required final SubscriptionCategory category,
      final DateTime? startDate,
      final String? description,
      final String? logoUrl,
      final Color? color,
      final bool isActive,
      final bool notificationsEnabled,
      final int notificationDaysBefore,
      final DateTime? trialEndDate,
      final Map<String, dynamic>? customCycleDetails,
      final String? notes}) = _$SubscriptionEntityImpl;
  const _SubscriptionEntity._() : super._();

  @override
  String get id;
  @override
  String get name;
  @override
  double get price;
  @override
  BillingCycle get billingCycle;
  @override
  DateTime get nextBillingDate;
  @override
  SubscriptionCategory get category;
  @override
  DateTime? get startDate;
  @override
  String? get description;
  @override
  String? get logoUrl;
  @override
  Color? get color;
  @override
  bool get isActive;
  @override
  bool get notificationsEnabled;
  @override
  int get notificationDaysBefore;
  @override
  DateTime? get trialEndDate;
  @override
  Map<String, dynamic>? get customCycleDetails;
  @override
  String? get notes;

  /// Create a copy of SubscriptionEntity
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SubscriptionEntityImplCopyWith<_$SubscriptionEntityImpl> get copyWith =>
      throw _privateConstructorUsedError;
}


===== FILE: subscription_repository.dart =====
===== PATH: lib/features/subscriptions/domain/repositories/subscription_repository.dart =====

import 'package:aboapp/features/subscriptions/domain/entities/subscription_entity.dart';
// Using a Either for functional error handling is a good practice, but for simplicity,
// we can use Futures that might throw exceptions, to be handled by the BLoC/Cubit.
// import 'package:dartz/dartz.dart'; // For Either
// import 'package:aboapp/core/error/failures.dart'; // Custom failure types

abstract class SubscriptionRepository {
  Future<List<SubscriptionEntity>> getAllSubscriptions();
  Future<SubscriptionEntity?> getSubscriptionById(String id);
  Future<void> addSubscription(SubscriptionEntity subscription);
  Future<void> updateSubscription(SubscriptionEntity subscription);
  Future<void> deleteSubscription(String id);
  Future<void> saveAllSubscriptions(List<SubscriptionEntity> subscriptions); // For bulk operations if needed
}

===== FILE: add_subscription_usecase.dart =====
===== PATH: lib/features/subscriptions/domain/usecases/add_subscription_usecase.dart =====

import 'package:aboapp/features/subscriptions/domain/entities/subscription_entity.dart';
import 'package:aboapp/features/subscriptions/domain/repositories/subscription_repository.dart';
import 'package:injectable/injectable.dart';

@lazySingleton
class AddSubscriptionUseCase {
  final SubscriptionRepository repository;

  AddSubscriptionUseCase(this.repository);

  Future<void> call(SubscriptionEntity subscription) async {
    // Business logic before adding, e.g., validation, could go here.
    // However, complex validation is often better handled in the entity or BLoC/Cubit.
    return await repository.addSubscription(subscription);
  }
}

===== FILE: delete_subscription_usecase.dart =====
===== PATH: lib/features/subscriptions/domain/usecases/delete_subscription_usecase.dart =====

import 'package:aboapp/features/subscriptions/domain/repositories/subscription_repository.dart';
import 'package:injectable/injectable.dart';

@lazySingleton
class DeleteSubscriptionUseCase {
  final SubscriptionRepository repository;

  DeleteSubscriptionUseCase(this.repository);

  Future<void> call(String id) async {
    return await repository.deleteSubscription(id);
  }
}

===== FILE: get_all_subscriptions_usecase.dart =====
===== PATH: lib/features/subscriptions/domain/usecases/get_all_subscriptions_usecase.dart =====

import 'package:aboapp/features/subscriptions/domain/entities/subscription_entity.dart';
import 'package:aboapp/features/subscriptions/domain/repositories/subscription_repository.dart';
import 'package:injectable/injectable.dart';

// Basic use case structure. Can be expanded with parameters if needed (e.g., for filtering).
// For more complex scenarios, consider a generic UseCase class.

@lazySingleton
class GetAllSubscriptionsUseCase {
  final SubscriptionRepository repository;

  GetAllSubscriptionsUseCase(this.repository);

  Future<List<SubscriptionEntity>> call() async {
    // You can add pre-processing or post-processing logic here if necessary.
    return await repository.getAllSubscriptions();
  }
}

===== FILE: update_subscription_usecase.dart =====
===== PATH: lib/features/subscriptions/domain/usecases/update_subscription_usecase.dart =====

import 'package:aboapp/features/subscriptions/domain/entities/subscription_entity.dart';
import 'package:aboapp/features/subscriptions/domain/repositories/subscription_repository.dart';
import 'package:injectable/injectable.dart';

@lazySingleton
class UpdateSubscriptionUseCase {
  final SubscriptionRepository repository;

  UpdateSubscriptionUseCase(this.repository);

  Future<void> call(SubscriptionEntity subscription) async {
    return await repository.updateSubscription(subscription);
  }
}

===== FILE: subscription_cubit.dart =====
===== PATH: lib/features/subscriptions/presentation/cubit/subscription_cubit.dart =====

import 'package:aboapp/features/subscriptions/domain/entities/subscription_entity.dart';
import 'package:aboapp/features/subscriptions/domain/usecases/add_subscription_usecase.dart';
import 'package:aboapp/features/subscriptions/domain/usecases/delete_subscription_usecase.dart';
import 'package:aboapp/features/subscriptions/domain/usecases/get_all_subscriptions_usecase.dart';
import 'package:aboapp/features/subscriptions/domain/usecases/update_subscription_usecase.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:injectable/injectable.dart';
import 'package:uuid/uuid.dart';

part 'subscription_state.dart';
part 'subscription_cubit.freezed.dart'; // Generated by Freezed

@injectable // Register with GetIt
class SubscriptionCubit extends Cubit<SubscriptionState> {
  final GetAllSubscriptionsUseCase _getAllSubscriptions;
  final AddSubscriptionUseCase _addSubscription;
  final UpdateSubscriptionUseCase _updateSubscription;
  final DeleteSubscriptionUseCase _deleteSubscription;
  final Uuid _uuid; // For generating IDs if needed for new entities

  // Store all fetched subscriptions internally to apply filters/sorting without re-fetching
  List<SubscriptionEntity> _masterSubscriptionList = [];

  SubscriptionCubit(
    this._getAllSubscriptions,
    this._addSubscription,
    this._updateSubscription,
    this._deleteSubscription,
    this._uuid, // Injected if Uuid is registered as a dependency, or instantiate here
  ) : super(const SubscriptionState.initial());

  Future<void> loadSubscriptions() async {
    emit(const SubscriptionState.loading());
    try {
      _masterSubscriptionList = await _getAllSubscriptions();
      // Apply default filters/sort before emitting loaded state
      _applyFiltersAndSort();
    } catch (e) {
      emit(SubscriptionState.error(message: e.toString()));
    }
  }

  Future<void> addSubscription(SubscriptionEntity subscription) async {
    // Ensure new subscriptions have a unique ID
    final subToAdd = subscription.id.isEmpty 
        ? subscription.copyWith(id: _uuid.v4()) 
        : subscription;
    
    emit(const SubscriptionState.loading()); // Optional: show loading during add
    try {
      await _addSubscription(subToAdd);
      _masterSubscriptionList.add(subToAdd); // Update master list
      _applyFiltersAndSort();
    } catch (e) {
      emit(SubscriptionState.error(message: "Failed to add subscription: ${e.toString()}"));
      // Optionally reload or revert to previous loaded state
      _applyFiltersAndSort(); // Re-emit previous loaded state or specific error state
    }
  }

  Future<void> updateSubscription(SubscriptionEntity subscription) async {
    emit(const SubscriptionState.loading()); // Optional
    try {
      await _updateSubscription(subscription);
      final index = _masterSubscriptionList.indexWhere((s) => s.id == subscription.id);
      if (index != -1) {
        _masterSubscriptionList[index] = subscription;
      } else {
        _masterSubscriptionList.add(subscription); // Or handle as error if update target not found
      }
      _applyFiltersAndSort();
    } catch (e) {
      emit(SubscriptionState.error(message: "Failed to update subscription: ${e.toString()}"));
      _applyFiltersAndSort();
    }
  }

  Future<void> deleteSubscription(String id) async {
    emit(const SubscriptionState.loading()); // Optional
    try {
      await _deleteSubscription(id);
      _masterSubscriptionList.removeWhere((s) => s.id == id);
      _applyFiltersAndSort();
    } catch (e) {
      emit(SubscriptionState.error(message: "Failed to delete subscription: ${e.toString()}"));
      _applyFiltersAndSort();
    }
  }
  
  Future<void> toggleSubscriptionActiveStatus(String id) async {
    final index = _masterSubscriptionList.indexWhere((s) => s.id == id);
    if (index != -1) {
      final sub = _masterSubscriptionList[index];
      final updatedSub = sub.copyWith(isActive: !sub.isActive);
      await updateSubscription(updatedSub); // This will handle loading state and re-filtering
    }
  }

  Future<void> toggleSubscriptionNotification(String id) async {
     final index = _masterSubscriptionList.indexWhere((s) => s.id == id);
    if (index != -1) {
      final sub = _masterSubscriptionList[index];
      final updatedSub = sub.copyWith(notificationsEnabled: !sub.notificationsEnabled);
      await updateSubscription(updatedSub);
    }
  }

  // Method to apply filters and sorting, then emit _Loaded state
  void _applyFiltersAndSort({
      SortOption? newSortOption,
      SubscriptionCategory? newFilterCategory,
      BillingCycle? newFilterBillingCycle,
      String? newSearchTerm,
      bool clearSearch = false,
  }) {
    // Get current state or defaults
    SortOption currentSortOption = state.maybeWhen(
        loaded: (alls, filters, sort, cat, bill, search) => sort ?? SortOption.nextBillingDateAsc,
        orElse: () => SortOption.nextBillingDateAsc);
    SubscriptionCategory? currentFilterCategory = state.maybeWhen(
        loaded: (alls, filters, sort, cat, bill, search) => cat, orElse: () => null);
    BillingCycle? currentFilterBillingCycle = state.maybeWhen(
        loaded: (alls, filters, sort, cat, bill, search) => bill, orElse: () => null);
    String? currentSearchTerm = state.maybeWhen(
        loaded: (alls, filters, sort, cat, bill, search) => search, orElse: () => null);

    // Update with new values if provided
    if (newSortOption != null) currentSortOption = newSortOption;
    if (newFilterCategory != null) currentFilterCategory = newFilterCategory;
    if (newFilterBillingCycle != null) currentFilterBillingCycle = newFilterBillingCycle;
    if (newSearchTerm != null) currentSearchTerm = newSearchTerm;
    if (clearSearch) currentSearchTerm = null;


    List<SubscriptionEntity> filtered = List.from(_masterSubscriptionList);

    // Apply search term
    if (currentSearchTerm != null && currentSearchTerm.isNotEmpty) {
      final query = currentSearchTerm.toLowerCase();
      filtered = filtered.where((sub) => 
        sub.name.toLowerCase().contains(query) || 
        (sub.description?.toLowerCase().contains(query) ?? false)
      ).toList();
    }

    // Apply category filter
    if (currentFilterCategory != null) {
      filtered = filtered.where((sub) => sub.category == currentFilterCategory).toList();
    }

    // Apply billing cycle filter
    if (currentFilterBillingCycle != null) {
      filtered = filtered.where((sub) => sub.billingCycle == currentFilterBillingCycle).toList();
    }
    
    // Apply sorting
    // Add all sorting options as per your SortOption enum
    switch (currentSortOption) {
      case SortOption.nameAsc:
        filtered.sort((a, b) => a.name.toLowerCase().compareTo(b.name.toLowerCase()));
        break;
      case SortOption.nameDesc:
        filtered.sort((a, b) => b.name.toLowerCase().compareTo(a.name.toLowerCase()));
        break;
      case SortOption.priceAsc:
        filtered.sort((a, b) => a.monthlyEquivalentPrice.compareTo(b.monthlyEquivalentPrice));
        break;
      case SortOption.priceDesc:
        filtered.sort((a, b) => b.monthlyEquivalentPrice.compareTo(a.monthlyEquivalentPrice));
        break;
      case SortOption.nextBillingDateAsc:
        filtered.sort((a, b) => a.nextBillingDate.compareTo(b.nextBillingDate));
        break;
      case SortOption.nextBillingDateDesc:
         filtered.sort((a, b) => b.nextBillingDate.compareTo(a.nextBillingDate));
        break;
      case SortOption.category:
        filtered.sort((a, b) => a.category.index.compareTo(b.category.index));
        break;
    }

    emit(SubscriptionState.loaded(
      allSubscriptions: _masterSubscriptionList,
      filteredSubscriptions: filtered,
      currentSortOption: currentSortOption,
      filterCategory: currentFilterCategory,
      filterBillingCycle: currentFilterBillingCycle,
      searchTerm: currentSearchTerm,
    ));
  }

  // Public methods to trigger filter/sort changes
  void changeSortOption(SortOption option) {
    _applyFiltersAndSort(newSortOption: option);
  }

  void filterByCategory(SubscriptionCategory? category) {
    _applyFiltersAndSort(newFilterCategory: category);
  }

  void filterByBillingCycle(BillingCycle? cycle) {
    _applyFiltersAndSort(newFilterBillingCycle: cycle);
  }

  void searchSubscriptions(String searchTerm) {
    _applyFiltersAndSort(newSearchTerm: searchTerm);
  }
   void clearSearch() {
    _applyFiltersAndSort(clearSearch: true, newSearchTerm: '');
  }

  void clearCategoryFilter() {
    _applyFiltersAndSort(newFilterCategory: null); // Pass null to effectively clear
  }

  void clearBillingCycleFilter() {
    _applyFiltersAndSort(newFilterBillingCycle: null); // Pass null to clear
  }

  void clearAllFilters() {
    _applyFiltersAndSort(
      newFilterCategory: null,
      newFilterBillingCycle: null,
      newSearchTerm: '', // Also clear search
      clearSearch: true,
    );
  }
}

===== FILE: subscription_cubit.freezed.dart =====
===== PATH: lib/features/subscriptions/presentation/cubit/subscription_cubit.freezed.dart =====

// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'subscription_cubit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$SubscriptionState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            List<SubscriptionEntity> allSubscriptions,
            List<SubscriptionEntity> filteredSubscriptions,
            SortOption? currentSortOption,
            SubscriptionCategory? filterCategory,
            BillingCycle? filterBillingCycle,
            String? searchTerm)
        loaded,
    required TResult Function(String message) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(
            List<SubscriptionEntity> allSubscriptions,
            List<SubscriptionEntity> filteredSubscriptions,
            SortOption? currentSortOption,
            SubscriptionCategory? filterCategory,
            BillingCycle? filterBillingCycle,
            String? searchTerm)?
        loaded,
    TResult? Function(String message)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            List<SubscriptionEntity> allSubscriptions,
            List<SubscriptionEntity> filteredSubscriptions,
            SortOption? currentSortOption,
            SubscriptionCategory? filterCategory,
            BillingCycle? filterBillingCycle,
            String? searchTerm)?
        loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubscriptionStateCopyWith<$Res> {
  factory $SubscriptionStateCopyWith(
          SubscriptionState value, $Res Function(SubscriptionState) then) =
      _$SubscriptionStateCopyWithImpl<$Res, SubscriptionState>;
}

/// @nodoc
class _$SubscriptionStateCopyWithImpl<$Res, $Val extends SubscriptionState>
    implements $SubscriptionStateCopyWith<$Res> {
  _$SubscriptionStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SubscriptionState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$InitialImplCopyWith<$Res> {
  factory _$$InitialImplCopyWith(
          _$InitialImpl value, $Res Function(_$InitialImpl) then) =
      __$$InitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitialImplCopyWithImpl<$Res>
    extends _$SubscriptionStateCopyWithImpl<$Res, _$InitialImpl>
    implements _$$InitialImplCopyWith<$Res> {
  __$$InitialImplCopyWithImpl(
      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)
      : super(_value, _then);

  /// Create a copy of SubscriptionState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$InitialImpl implements _Initial {
  const _$InitialImpl();

  @override
  String toString() {
    return 'SubscriptionState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            List<SubscriptionEntity> allSubscriptions,
            List<SubscriptionEntity> filteredSubscriptions,
            SortOption? currentSortOption,
            SubscriptionCategory? filterCategory,
            BillingCycle? filterBillingCycle,
            String? searchTerm)
        loaded,
    required TResult Function(String message) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(
            List<SubscriptionEntity> allSubscriptions,
            List<SubscriptionEntity> filteredSubscriptions,
            SortOption? currentSortOption,
            SubscriptionCategory? filterCategory,
            BillingCycle? filterBillingCycle,
            String? searchTerm)?
        loaded,
    TResult? Function(String message)? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            List<SubscriptionEntity> allSubscriptions,
            List<SubscriptionEntity> filteredSubscriptions,
            SortOption? currentSortOption,
            SubscriptionCategory? filterCategory,
            BillingCycle? filterBillingCycle,
            String? searchTerm)?
        loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements SubscriptionState {
  const factory _Initial() = _$InitialImpl;
}

/// @nodoc
abstract class _$$LoadingImplCopyWith<$Res> {
  factory _$$LoadingImplCopyWith(
          _$LoadingImpl value, $Res Function(_$LoadingImpl) then) =
      __$$LoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadingImplCopyWithImpl<$Res>
    extends _$SubscriptionStateCopyWithImpl<$Res, _$LoadingImpl>
    implements _$$LoadingImplCopyWith<$Res> {
  __$$LoadingImplCopyWithImpl(
      _$LoadingImpl _value, $Res Function(_$LoadingImpl) _then)
      : super(_value, _then);

  /// Create a copy of SubscriptionState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$LoadingImpl implements _Loading {
  const _$LoadingImpl();

  @override
  String toString() {
    return 'SubscriptionState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            List<SubscriptionEntity> allSubscriptions,
            List<SubscriptionEntity> filteredSubscriptions,
            SortOption? currentSortOption,
            SubscriptionCategory? filterCategory,
            BillingCycle? filterBillingCycle,
            String? searchTerm)
        loaded,
    required TResult Function(String message) error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(
            List<SubscriptionEntity> allSubscriptions,
            List<SubscriptionEntity> filteredSubscriptions,
            SortOption? currentSortOption,
            SubscriptionCategory? filterCategory,
            BillingCycle? filterBillingCycle,
            String? searchTerm)?
        loaded,
    TResult? Function(String message)? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            List<SubscriptionEntity> allSubscriptions,
            List<SubscriptionEntity> filteredSubscriptions,
            SortOption? currentSortOption,
            SubscriptionCategory? filterCategory,
            BillingCycle? filterBillingCycle,
            String? searchTerm)?
        loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _Loading implements SubscriptionState {
  const factory _Loading() = _$LoadingImpl;
}

/// @nodoc
abstract class _$$LoadedImplCopyWith<$Res> {
  factory _$$LoadedImplCopyWith(
          _$LoadedImpl value, $Res Function(_$LoadedImpl) then) =
      __$$LoadedImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {List<SubscriptionEntity> allSubscriptions,
      List<SubscriptionEntity> filteredSubscriptions,
      SortOption? currentSortOption,
      SubscriptionCategory? filterCategory,
      BillingCycle? filterBillingCycle,
      String? searchTerm});
}

/// @nodoc
class __$$LoadedImplCopyWithImpl<$Res>
    extends _$SubscriptionStateCopyWithImpl<$Res, _$LoadedImpl>
    implements _$$LoadedImplCopyWith<$Res> {
  __$$LoadedImplCopyWithImpl(
      _$LoadedImpl _value, $Res Function(_$LoadedImpl) _then)
      : super(_value, _then);

  /// Create a copy of SubscriptionState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? allSubscriptions = null,
    Object? filteredSubscriptions = null,
    Object? currentSortOption = freezed,
    Object? filterCategory = freezed,
    Object? filterBillingCycle = freezed,
    Object? searchTerm = freezed,
  }) {
    return _then(_$LoadedImpl(
      allSubscriptions: null == allSubscriptions
          ? _value._allSubscriptions
          : allSubscriptions // ignore: cast_nullable_to_non_nullable
              as List<SubscriptionEntity>,
      filteredSubscriptions: null == filteredSubscriptions
          ? _value._filteredSubscriptions
          : filteredSubscriptions // ignore: cast_nullable_to_non_nullable
              as List<SubscriptionEntity>,
      currentSortOption: freezed == currentSortOption
          ? _value.currentSortOption
          : currentSortOption // ignore: cast_nullable_to_non_nullable
              as SortOption?,
      filterCategory: freezed == filterCategory
          ? _value.filterCategory
          : filterCategory // ignore: cast_nullable_to_non_nullable
              as SubscriptionCategory?,
      filterBillingCycle: freezed == filterBillingCycle
          ? _value.filterBillingCycle
          : filterBillingCycle // ignore: cast_nullable_to_non_nullable
              as BillingCycle?,
      searchTerm: freezed == searchTerm
          ? _value.searchTerm
          : searchTerm // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$LoadedImpl implements _Loaded {
  const _$LoadedImpl(
      {required final List<SubscriptionEntity> allSubscriptions,
      required final List<SubscriptionEntity> filteredSubscriptions,
      this.currentSortOption,
      this.filterCategory,
      this.filterBillingCycle,
      this.searchTerm})
      : _allSubscriptions = allSubscriptions,
        _filteredSubscriptions = filteredSubscriptions;

  final List<SubscriptionEntity> _allSubscriptions;
  @override
  List<SubscriptionEntity> get allSubscriptions {
    if (_allSubscriptions is EqualUnmodifiableListView)
      return _allSubscriptions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_allSubscriptions);
  }

  final List<SubscriptionEntity> _filteredSubscriptions;
  @override
  List<SubscriptionEntity> get filteredSubscriptions {
    if (_filteredSubscriptions is EqualUnmodifiableListView)
      return _filteredSubscriptions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_filteredSubscriptions);
  }

// For UI display after filtering/sorting
// Add other relevant data for the UI, e.g., sorting options, filter values
  @override
  final SortOption? currentSortOption;
  @override
  final SubscriptionCategory? filterCategory;
  @override
  final BillingCycle? filterBillingCycle;
  @override
  final String? searchTerm;

  @override
  String toString() {
    return 'SubscriptionState.loaded(allSubscriptions: $allSubscriptions, filteredSubscriptions: $filteredSubscriptions, currentSortOption: $currentSortOption, filterCategory: $filterCategory, filterBillingCycle: $filterBillingCycle, searchTerm: $searchTerm)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoadedImpl &&
            const DeepCollectionEquality()
                .equals(other._allSubscriptions, _allSubscriptions) &&
            const DeepCollectionEquality()
                .equals(other._filteredSubscriptions, _filteredSubscriptions) &&
            (identical(other.currentSortOption, currentSortOption) ||
                other.currentSortOption == currentSortOption) &&
            (identical(other.filterCategory, filterCategory) ||
                other.filterCategory == filterCategory) &&
            (identical(other.filterBillingCycle, filterBillingCycle) ||
                other.filterBillingCycle == filterBillingCycle) &&
            (identical(other.searchTerm, searchTerm) ||
                other.searchTerm == searchTerm));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_allSubscriptions),
      const DeepCollectionEquality().hash(_filteredSubscriptions),
      currentSortOption,
      filterCategory,
      filterBillingCycle,
      searchTerm);

  /// Create a copy of SubscriptionState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$LoadedImplCopyWith<_$LoadedImpl> get copyWith =>
      __$$LoadedImplCopyWithImpl<_$LoadedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            List<SubscriptionEntity> allSubscriptions,
            List<SubscriptionEntity> filteredSubscriptions,
            SortOption? currentSortOption,
            SubscriptionCategory? filterCategory,
            BillingCycle? filterBillingCycle,
            String? searchTerm)
        loaded,
    required TResult Function(String message) error,
  }) {
    return loaded(allSubscriptions, filteredSubscriptions, currentSortOption,
        filterCategory, filterBillingCycle, searchTerm);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(
            List<SubscriptionEntity> allSubscriptions,
            List<SubscriptionEntity> filteredSubscriptions,
            SortOption? currentSortOption,
            SubscriptionCategory? filterCategory,
            BillingCycle? filterBillingCycle,
            String? searchTerm)?
        loaded,
    TResult? Function(String message)? error,
  }) {
    return loaded?.call(allSubscriptions, filteredSubscriptions,
        currentSortOption, filterCategory, filterBillingCycle, searchTerm);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            List<SubscriptionEntity> allSubscriptions,
            List<SubscriptionEntity> filteredSubscriptions,
            SortOption? currentSortOption,
            SubscriptionCategory? filterCategory,
            BillingCycle? filterBillingCycle,
            String? searchTerm)?
        loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(allSubscriptions, filteredSubscriptions, currentSortOption,
          filterCategory, filterBillingCycle, searchTerm);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class _Loaded implements SubscriptionState {
  const factory _Loaded(
      {required final List<SubscriptionEntity> allSubscriptions,
      required final List<SubscriptionEntity> filteredSubscriptions,
      final SortOption? currentSortOption,
      final SubscriptionCategory? filterCategory,
      final BillingCycle? filterBillingCycle,
      final String? searchTerm}) = _$LoadedImpl;

  List<SubscriptionEntity> get allSubscriptions;
  List<SubscriptionEntity>
      get filteredSubscriptions; // For UI display after filtering/sorting
// Add other relevant data for the UI, e.g., sorting options, filter values
  SortOption? get currentSortOption;
  SubscriptionCategory? get filterCategory;
  BillingCycle? get filterBillingCycle;
  String? get searchTerm;

  /// Create a copy of SubscriptionState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$LoadedImplCopyWith<_$LoadedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ErrorImplCopyWith<$Res> {
  factory _$$ErrorImplCopyWith(
          _$ErrorImpl value, $Res Function(_$ErrorImpl) then) =
      __$$ErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$ErrorImplCopyWithImpl<$Res>
    extends _$SubscriptionStateCopyWithImpl<$Res, _$ErrorImpl>
    implements _$$ErrorImplCopyWith<$Res> {
  __$$ErrorImplCopyWithImpl(
      _$ErrorImpl _value, $Res Function(_$ErrorImpl) _then)
      : super(_value, _then);

  /// Create a copy of SubscriptionState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$ErrorImpl(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ErrorImpl implements _Error {
  const _$ErrorImpl({required this.message});

  @override
  final String message;

  @override
  String toString() {
    return 'SubscriptionState.error(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ErrorImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  /// Create a copy of SubscriptionState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>
      __$$ErrorImplCopyWithImpl<_$ErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            List<SubscriptionEntity> allSubscriptions,
            List<SubscriptionEntity> filteredSubscriptions,
            SortOption? currentSortOption,
            SubscriptionCategory? filterCategory,
            BillingCycle? filterBillingCycle,
            String? searchTerm)
        loaded,
    required TResult Function(String message) error,
  }) {
    return error(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(
            List<SubscriptionEntity> allSubscriptions,
            List<SubscriptionEntity> filteredSubscriptions,
            SortOption? currentSortOption,
            SubscriptionCategory? filterCategory,
            BillingCycle? filterBillingCycle,
            String? searchTerm)?
        loaded,
    TResult? Function(String message)? error,
  }) {
    return error?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            List<SubscriptionEntity> allSubscriptions,
            List<SubscriptionEntity> filteredSubscriptions,
            SortOption? currentSortOption,
            SubscriptionCategory? filterCategory,
            BillingCycle? filterBillingCycle,
            String? searchTerm)?
        loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _Error implements SubscriptionState {
  const factory _Error({required final String message}) = _$ErrorImpl;

  String get message;

  /// Create a copy of SubscriptionState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}


===== FILE: subscription_state.dart =====
===== PATH: lib/features/subscriptions/presentation/cubit/subscription_state.dart =====

part of 'subscription_cubit.dart'; // Generated by Cubit

@freezed
class SubscriptionState with _$SubscriptionState {
  const factory SubscriptionState.initial() = _Initial;
  const factory SubscriptionState.loading() = _Loading;
  const factory SubscriptionState.loaded({
    required List<SubscriptionEntity> allSubscriptions,
    required List<SubscriptionEntity> filteredSubscriptions, // For UI display after filtering/sorting
    // Add other relevant data for the UI, e.g., sorting options, filter values
    SortOption? currentSortOption,
    SubscriptionCategory? filterCategory,
    BillingCycle? filterBillingCycle,
    String? searchTerm,
  }) = _Loaded;
  const factory SubscriptionState.error({required String message}) = _Error;
}

// Enums for sorting and potentially filtering (can be moved to domain if they represent business logic)
enum SortOption { nameAsc, nameDesc, priceAsc, priceDesc, nextBillingDateAsc, nextBillingDateDesc, category }
// Filter enums (BillingCycle, SubscriptionCategory) are already defined in subscription_entity.dart

===== FILE: add_edit_subscription_screen.dart =====
===== PATH: lib/features/subscriptions/presentation/screens/add_edit_subscription_screen.dart =====

// import 'package:aboapp/core/routing/app_router.dart'; // Unused import
import 'package:aboapp/features/subscriptions/domain/entities/subscription_entity.dart';
import 'package:aboapp/features/subscriptions/presentation/cubit/subscription_cubit.dart';
import 'package:aboapp/features/subscriptions/presentation/widgets/subscription_card_widget.dart'; // For CategoryDisplayHelpers
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:go_router/go_router.dart';
import 'package:intl/intl.dart';
import 'package:uuid/uuid.dart';
import 'package:aboapp/core/utils/haptic_feedback.dart' as app_haptics; 

class AddEditSubscriptionScreen extends StatefulWidget {
  final SubscriptionEntity? subscription; 
  final String? subscriptionId; 

  const AddEditSubscriptionScreen({
    super.key,
    this.subscription,
    this.subscriptionId,
  });

  @override
  State<AddEditSubscriptionScreen> createState() => _AddEditSubscriptionScreenState();
}

class _AddEditSubscriptionScreenState extends State<AddEditSubscriptionScreen> {
  final _formKey = GlobalKey<FormState>();
  final _uuid = const Uuid(); 

  late TextEditingController _nameController;
  late TextEditingController _priceController;
  late TextEditingController _descriptionController;
  late TextEditingController _logoUrlController;
  late TextEditingController _notesController;
  late TextEditingController _customCycleDaysController;

  late String _currentId;
  SubscriptionCategory _category = SubscriptionCategory.other;
  BillingCycle _billingCycle = BillingCycle.monthly;
  DateTime _nextBillingDate = DateTime.now().add(const Duration(days: 30));
  DateTime? _startDate;
  Color? _selectedColor;
  bool _isActive = true;
  bool _notificationsEnabled = true;
  int _notificationDaysBefore = 7;
  bool _isInTrial = false;
  DateTime? _trialEndDate;

  bool get _isEditing => widget.subscription != null || widget.subscriptionId != null;

  @override
  void initState() {
    super.initState();

    _nameController = TextEditingController();
    _priceController = TextEditingController();
    _descriptionController = TextEditingController();
    _logoUrlController = TextEditingController();
    _notesController = TextEditingController();
    _customCycleDaysController = TextEditingController();

    final initialSub = widget.subscription; 

    if (initialSub != null) {
      _loadSubscriptionData(initialSub);
    } else if (widget.subscriptionId != null) {
      final subFromState = context.read<SubscriptionCubit>().state.maybeWhen(
            loaded: (all, filtered, _, __, ___, ____) =>
                all.firstWhere((s) => s.id == widget.subscriptionId, orElse: () => _createEmptySubscription()),
            orElse: () => _createEmptySubscription(), 
          );
       _loadSubscriptionData(subFromState);
    } else {
      _currentId = _uuid.v4();
      _startDate = DateTime.now(); 
      _nextBillingDate = DateTime.now().add(const Duration(days: 30)); 
    }
  }
  
  SubscriptionEntity _createEmptySubscription() {
    return SubscriptionEntity(
      id: _uuid.v4(),
      name: '',
      price: 0.0,
      billingCycle: BillingCycle.monthly,
      nextBillingDate: DateTime.now().add(const Duration(days: 30)),
      category: SubscriptionCategory.other,
      startDate: DateTime.now(),
    );
  }


  void _loadSubscriptionData(SubscriptionEntity sub) {
    _currentId = sub.id;
    _nameController.text = sub.name;
    _priceController.text = sub.price.toStringAsFixed(2);
    _descriptionController.text = sub.description ?? '';
    _logoUrlController.text = sub.logoUrl ?? '';
    _notesController.text = sub.notes ?? '';
    _category = sub.category;
    _billingCycle = sub.billingCycle;
    _nextBillingDate = sub.nextBillingDate;
    _startDate = sub.startDate;
    _selectedColor = sub.color;
    _isActive = sub.isActive;
    _notificationsEnabled = sub.notificationsEnabled;
    _notificationDaysBefore = sub.notificationDaysBefore;
    _isInTrial = sub.isInTrial;
    _trialEndDate = sub.trialEndDate;
    if (sub.billingCycle == BillingCycle.custom && sub.customCycleDetails?['value'] != null) {
      _customCycleDaysController.text = sub.customCycleDetails!['value'].toString();
    }
  }

  @override
  void dispose() {
    _nameController.dispose();
    _priceController.dispose();
    _descriptionController.dispose();
    _logoUrlController.dispose();
    _notesController.dispose();
    _customCycleDaysController.dispose();
    super.dispose();
  }

  Future<void> _selectDate(BuildContext context, {
    required DateTime initialDate,
    required ValueChanged<DateTime> onDateSelected,
    DateTime? firstDate,
    DateTime? lastDate,
  }) async {
    final DateTime? picked = await showDatePicker(
      context: context,
      initialDate: initialDate,
      firstDate: firstDate ?? DateTime(2000),
      lastDate: lastDate ?? DateTime(2101),
    );
    if (picked != null) {
      onDateSelected(picked);
    }
  }

  void _saveSubscription() {
    if (_formKey.currentState?.validate() ?? false) {
      final name = _nameController.text.trim();
      final price = double.tryParse(_priceController.text) ?? 0.0;
      final description = _descriptionController.text.trim();
      final logoUrl = _logoUrlController.text.trim();
      final notes = _notesController.text.trim();
      
      Map<String, dynamic>? customCycleDetails;
      if (_billingCycle == BillingCycle.custom) {
        final days = int.tryParse(_customCycleDaysController.text);
        if (days != null && days > 0) {
          customCycleDetails = {'type': 'days', 'value': days};
        } else {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Invalid custom cycle days.')), // TODO: Localize
          );
          return; 
        }
      }

      final subscriptionEntity = SubscriptionEntity(
        id: _currentId,
        name: name,
        price: price,
        billingCycle: _billingCycle,
        nextBillingDate: _nextBillingDate,
        category: _category,
        startDate: _startDate,
        description: description.isEmpty ? null : description,
        logoUrl: logoUrl.isEmpty ? null : logoUrl,
        color: _selectedColor,
        isActive: _isActive, 
        notificationsEnabled: _notificationsEnabled,
        notificationDaysBefore: _notificationDaysBefore,
        trialEndDate: _isInTrial ? _trialEndDate : null,
        customCycleDetails: customCycleDetails,
        notes: notes.isEmpty ? null : notes,
      );

      if (_isEditing) {
        context.read<SubscriptionCubit>().updateSubscription(subscriptionEntity);
      } else {
        context.read<SubscriptionCubit>().addSubscription(subscriptionEntity);
      }
      app_haptics.HapticFeedback.lightImpact();
      context.pop(); 
    } else {
      app_haptics.HapticFeedback.warningImpact(); 
    }
  }
  
  String _getBillingCycleLabel(BuildContext context, BillingCycle cycle) {
    // TODO: Localize these strings
    switch (cycle) {
      case BillingCycle.weekly: return 'Weekly';
      case BillingCycle.monthly: return 'Monthly';
      case BillingCycle.quarterly: return 'Quarterly';
      case BillingCycle.biAnnual: return 'Every 6 Months';
      case BillingCycle.yearly: return 'Yearly';
      case BillingCycle.custom: return 'Custom (Days)';
    }
  }


  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final dateFormat = DateFormat('dd MMM yyyy'); 

    return Scaffold(
      appBar: AppBar(
        title: Text(_isEditing ? 'Edit Subscription' : 'Add Subscription'), 
        actions: [
          IconButton(
            icon: const Icon(Icons.save_alt_rounded),
            tooltip: 'Save', 
            onPressed: _saveSubscription,
          ),
        ],
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16.0),
        child: Form(
          key: _formKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: <Widget>[
              _buildSectionHeader(context, 'Basic Information'), 
              TextFormField(
                controller: _nameController,
                decoration: const InputDecoration(labelText: 'Name'), 
                textCapitalization: TextCapitalization.words,
                validator: (value) => (value?.trim().isEmpty ?? true) ? 'Name is required' : null, 
              ),
              const SizedBox(height: 12),
              TextFormField(
                controller: _priceController,
                decoration: const InputDecoration(labelText: 'Price', prefixText: '€ '), 
                keyboardType: const TextInputType.numberWithOptions(decimal: true),
                inputFormatters: [FilteringTextInputFormatter.allow(RegExp(r'^\d*\.?\d{0,2}'))],
                validator: (value) {
                  if (value?.trim().isEmpty ?? true) return 'Price is required'; 
                  if (double.tryParse(value!) == null) return 'Invalid price'; 
                  return null;
                },
              ),
              const SizedBox(height: 12),
              DropdownButtonFormField<SubscriptionCategory>(
                value: _category,
                decoration: const InputDecoration(labelText: 'Category'), 
                items: SubscriptionCategory.values.map((cat) {
                  return DropdownMenuItem(
                    value: cat,
                    child: Row(
                      children: [
                        Icon(cat.displayIcon, size: 20, color: cat.categoryDisplayIconColor(theme)), // Using extensions
                        const SizedBox(width: 8),
                        Text(cat.displayName), // Using extensions
                      ],
                    ),
                  );
                }).toList(),
                onChanged: (val) => setState(() => _category = val!),
              ),
              const SizedBox(height: 12),
              TextFormField(
                controller: _descriptionController,
                decoration: const InputDecoration(labelText: 'Description (Optional)'), 
                maxLines: 2,
                textCapitalization: TextCapitalization.sentences,
              ),
              const SizedBox(height: 24),

              _buildSectionHeader(context, 'Billing Details'), 
              DropdownButtonFormField<BillingCycle>(
                value: _billingCycle,
                decoration: const InputDecoration(labelText: 'Billing Cycle'), 
                items: BillingCycle.values.map((cycle) {
                  return DropdownMenuItem(value: cycle, child: Text(_getBillingCycleLabel(context, cycle)));
                }).toList(),
                onChanged: (val) => setState(() => _billingCycle = val!),
              ),
              if (_billingCycle == BillingCycle.custom) ...[
                const SizedBox(height: 12),
                TextFormField(
                  controller: _customCycleDaysController,
                  decoration: const InputDecoration(labelText: 'Custom Cycle (in days)'), 
                  keyboardType: TextInputType.number,
                  inputFormatters: [FilteringTextInputFormatter.digitsOnly],
                  validator: (value) {
                    if (value?.trim().isEmpty ?? true) return 'Cycle days required'; 
                    if ((int.tryParse(value!) ?? 0) <= 0) return 'Must be > 0 days'; 
                    return null;
                  },
                ),
              ],
              const SizedBox(height: 12),
              _buildDatePickerTile(
                context: context,
                title: 'Next Billing Date', 
                date: _nextBillingDate,
                dateFormat: dateFormat,
                onTap: () => _selectDate(context,
                    initialDate: _nextBillingDate,
                    onDateSelected: (date) => setState(() => _nextBillingDate = date)),
              ),
              const SizedBox(height: 12),
               _buildDatePickerTile(
                context: context,
                title: 'Subscription Start Date', 
                date: _startDate,
                dateFormat: dateFormat,
                onTap: () => _selectDate(context,
                    initialDate: _startDate ?? DateTime.now(),
                    lastDate: DateTime.now().add(const Duration(days: 365*5)), 
                    onDateSelected: (date) => setState(() => _startDate = date)),
                canBeNull: true,
              ),
              const SizedBox(height: 24),

              _buildSectionHeader(context, 'Optional Details'), 
               SwitchListTile.adaptive(
                title: Text('Active Subscription', style: theme.textTheme.bodyLarge), 
                value: _isActive,
                onChanged: (val) => setState(() => _isActive = val),
                dense: true,
                contentPadding: EdgeInsets.zero,
              ),
              SwitchListTile.adaptive(
                title: Text('In Trial Period', style: theme.textTheme.bodyLarge), 
                value: _isInTrial,
                onChanged: (val) => setState(() {
                  _isInTrial = val;
                  if (!_isInTrial) _trialEndDate = null;
                }),
                dense: true,
                contentPadding: EdgeInsets.zero,
              ),
              if (_isInTrial)
                _buildDatePickerTile(
                  context: context,
                  title: 'Trial End Date', 
                  date: _trialEndDate,
                  dateFormat: dateFormat,
                  onTap: () => _selectDate(context,
                      initialDate: _trialEndDate ?? _nextBillingDate.add(const Duration(days:7)),
                      firstDate: DateTime.now(),
                      onDateSelected: (date) => setState(() => _trialEndDate = date)),
                  canBeNull: true,
                ),
              const SizedBox(height: 12),
              SwitchListTile.adaptive(
                title: Text('Enable Notifications', style: theme.textTheme.bodyLarge), 
                value: _notificationsEnabled,
                onChanged: (val) => setState(() => _notificationsEnabled = val),
                dense: true,
                contentPadding: EdgeInsets.zero,
              ),
              if (_notificationsEnabled) ...[
                const SizedBox(height: 12),
                DropdownButtonFormField<int>(
                  value: _notificationDaysBefore,
                  decoration: const InputDecoration(labelText: 'Notify Days Before Renewal'), 
                  items: [1, 2, 3, 5, 7, 10, 14, 21, 30].map((days) {
                    return DropdownMenuItem(value: days, child: Text('$days day${days > 1 ? "s" : ""}')); 
                  }).toList(),
                  onChanged: (val) => setState(() => _notificationDaysBefore = val!),
                ),
              ],
              const SizedBox(height: 12),
              TextFormField(
                controller: _logoUrlController,
                decoration: const InputDecoration(labelText: 'Logo URL (Optional)'), 
                keyboardType: TextInputType.url,
              ),
              const SizedBox(height: 12),
              TextFormField(
                controller: _notesController,
                decoration: const InputDecoration(labelText: 'Notes (Optional)'), 
                maxLines: 3,
                textCapitalization: TextCapitalization.sentences,
              ),
              const SizedBox(height: 32),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildSectionHeader(BuildContext context, String title) {
    return Padding(
      padding: const EdgeInsets.only(top: 16.0, bottom: 8.0),
      child: Text(
        title,
        style: Theme.of(context).textTheme.titleLarge?.copyWith(
          color: Theme.of(context).colorScheme.primary,
          fontWeight: FontWeight.w600,
        ),
      ),
    );
  }

  Widget _buildDatePickerTile({
    required BuildContext context,
    required String title,
    required DateTime? date,
    required DateFormat dateFormat,
    required VoidCallback onTap,
    bool canBeNull = false,
  }) {
    final theme = Theme.of(context);
    return ListTile(
      contentPadding: EdgeInsets.zero,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(8.0),
        side: BorderSide(color: theme.inputDecorationTheme.enabledBorder?.borderSide.color ?? theme.dividerColor)
      ),
      title: Text(title, style: theme.textTheme.bodyMedium?.copyWith(color: theme.colorScheme.onSurfaceVariant)),
      subtitle: Text(
        date != null ? dateFormat.format(date) : (canBeNull ? 'Not Set' : 'Please select a date'), 
        style: theme.textTheme.bodyLarge?.copyWith(fontWeight: FontWeight.w500, color: date != null ? theme.colorScheme.onSurface : theme.colorScheme.onSurfaceVariant),
      ),
      trailing: const Icon(Icons.calendar_month_rounded),
      onTap: onTap,
    );
  }
}

===== FILE: home_screen.dart =====
===== PATH: lib/features/subscriptions/presentation/screens/home_screen.dart =====

import 'package:aboapp/core/routing/app_router.dart';
import 'package:aboapp/features/subscriptions/domain/entities/subscription_entity.dart';
import 'package:aboapp/features/subscriptions/presentation/cubit/subscription_cubit.dart';
import 'package:aboapp/features/subscriptions/presentation/widgets/monthly_spending_summary_card.dart';
import 'package:aboapp/features/subscriptions/presentation/widgets/subscription_card_widget.dart'; // For CategoryDisplayHelpers
import 'package:aboapp/widgets/empty_state_widget.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:go_router/go_router.dart';
import 'package:shimmer/shimmer.dart';
import 'package:aboapp/core/utils/haptic_feedback.dart' as app_haptics;
import 'package:aboapp/core/theme/app_colors.dart'; // Import AppColors

class HomeScreen extends StatefulWidget {
  const HomeScreen({super.key});

  @override
  State<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends State<HomeScreen> with SingleTickerProviderStateMixin {
  final _searchController = TextEditingController();
  final _searchFocusNode = FocusNode();
  bool _isSearching = false;
  late AnimationController _fabAnimationController;


  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      context.read<SubscriptionCubit>().loadSubscriptions();
    });
     _fabAnimationController = AnimationController(
      duration: const Duration(milliseconds: 300),
      vsync: this,
    );
    _fabAnimationController.forward();
  }

  @override
  void dispose() {
    _searchController.dispose();
    _searchFocusNode.dispose();
    _fabAnimationController.dispose();
    super.dispose();
  }

  void _toggleSearch(BuildContext context) {
    setState(() {
      _isSearching = !_isSearching;
      if (!_isSearching) {
        _searchController.clear();
        _searchFocusNode.unfocus();
        context.read<SubscriptionCubit>().clearSearch();
      } else {
        _searchFocusNode.requestFocus();
      }
    });
  }
  
  String _getBillingCycleLabel(BuildContext context, BillingCycle cycle) {
    // TODO: Localize
    switch (cycle) {
      case BillingCycle.weekly: return 'Weekly';
      case BillingCycle.monthly: return 'Monthly';
      case BillingCycle.quarterly: return 'Quarterly';
      case BillingCycle.biAnnual: return 'Bi-Annual';
      case BillingCycle.yearly: return 'Yearly';
      case BillingCycle.custom: return 'Custom';
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Scaffold(
      appBar: AppBar(
        title: AnimatedSwitcher(
          duration: const Duration(milliseconds: 200),
          child: _isSearching
              ? TextField(
                  controller: _searchController,
                  focusNode: _searchFocusNode,
                  autofocus: true,
                  decoration: InputDecoration(
                    hintText: 'Search subscriptions...', 
                    border: InputBorder.none,
                    isDense: true,
                    hintStyle: theme.appBarTheme.titleTextStyle?.copyWith(
                      fontWeight: FontWeight.normal,
                      color: theme.colorScheme.onSurface.withOpacity(0.6) // Kept withOpacity
                    )
                  ),
                  style: theme.appBarTheme.titleTextStyle,
                  onChanged: (query) => context.read<SubscriptionCubit>().searchSubscriptions(query),
                )
              : const Text('My Subscriptions'), 
        ),
        actions: [
          IconButton(
            icon: Icon(_isSearching ? Icons.close_rounded : Icons.search_rounded),
            onPressed: () => _toggleSearch(context),
            tooltip: _isSearching ? 'Close Search' : 'Search', 
          ),
        ],
      ),
      body: BlocBuilder<SubscriptionCubit, SubscriptionState>(
        builder: (context, state) {
          return state.when(
            initial: () => const Center(child: CircularProgressIndicator.adaptive()),
            loading: () => _buildLoadingShimmer(theme),
            loaded: (allSubs, filteredSubs, sortOption, filterCat, filterBill, searchTerm) {
              final activeSubscriptions = allSubs.where((s) => s.isActive).toList();
              return RefreshIndicator(
                onRefresh: () async {
                  app_haptics.HapticFeedback.mediumImpact();
                  await context.read<SubscriptionCubit>().loadSubscriptions();
                },
                child: CustomScrollView(
                  physics: const AlwaysScrollableScrollPhysics(),
                  slivers: [
                    if (!_isSearching)
                      SliverToBoxAdapter(
                        child: Padding(
                          padding: const EdgeInsets.fromLTRB(16, 16, 16, 8),
                          child: MonthlySpendingSummaryCard(
                            activeSubscriptions: activeSubscriptions,
                          ),
                        ),
                      ),
                    _buildFilterAndSortControls(context, theme, sortOption, filterCat, filterBill),
                    if (filteredSubs.isEmpty)
                      SliverFillRemaining(
                        hasScrollBody: false,
                        child: Center(
                          child: EmptyStateWidget(
                            icon: Icons.search_off_rounded,
                            title: 'No Subscriptions Found',
                            message: 'Try adjusting your search or filters.',
                            onRetry: () => context.read<SubscriptionCubit>().clearAllFilters(),
                            retryText: 'Clear Filters', 
                          ),
                        ),
                      )
                    else
                      SliverList(
                        delegate: SliverChildBuilderDelegate(
                          (context, index) {
                            final subscription = filteredSubs[index];
                            return SubscriptionCardWidget(
                              subscription: subscription,
                              onTap: () {
                                context.pushNamed(
                                  AppRoutes.editSubscription,
                                  pathParameters: {'id': subscription.id},
                                  extra: subscription, 
                                );
                              },
                              onLongPress: () => _showSubscriptionActions(context, theme, subscription),
                            );
                          },
                          childCount: filteredSubs.length,
                        ),
                      ),
                    const SliverPadding(padding: EdgeInsets.only(bottom: 80)), 
                  ],
                ),
              );
            },
            error: (message) => Center(
              child: EmptyStateWidget(
                icon: Icons.error_outline_rounded,
                title: 'Error', 
                message: message,
                onRetry: () => context.read<SubscriptionCubit>().loadSubscriptions(),
                retryText: 'Retry', 
              ),
            ),
          );
        },
      ),
    );
  }

  Widget _buildFilterAndSortControls(
    BuildContext context, 
    ThemeData theme,
    SortOption? currentSort,
    SubscriptionCategory? currentCat,
    BillingCycle? currentBill,
  ) {
    return SliverToBoxAdapter(
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
        child: Column(
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                DropdownButtonHideUnderline(
                  child: DropdownButton<SortOption>(
                    value: currentSort ?? SortOption.nextBillingDateAsc,
                    icon: const Icon(Icons.sort_rounded, size: 20),
                    style: theme.textTheme.bodySmall,
                    items: SortOption.values.map((option) {
                      return DropdownMenuItem<SortOption>(
                        value: option,
                        child: Text(option.toString().split('.').last), 
                      );
                    }).toList(),
                    onChanged: (option) {
                      if (option != null) {
                        context.read<SubscriptionCubit>().changeSortOption(option);
                      }
                    },
                  ),
                ),
                if (currentCat != null || currentBill != null || (_searchController.text.isNotEmpty && _isSearching))
                  TextButton.icon(
                    icon: const Icon(Icons.clear_all_rounded, size: 18),
                    label: const Text('Clear Filters'), 
                    onPressed: () => context.read<SubscriptionCubit>().clearAllFilters(),
                    style: TextButton.styleFrom(
                      padding: EdgeInsets.zero,
                      tapTargetSize: MaterialTapTargetSize.shrinkWrap,
                    ),
                  ),
              ],
            ),
            const SizedBox(height: 8),
            SingleChildScrollView(
              scrollDirection: Axis.horizontal,
              child: Row(
                children: [
                  FilterChip(
                    label: const Text('All Cats'), 
                    selected: currentCat == null,
                    onSelected: (_) => context.read<SubscriptionCubit>().clearCategoryFilter(),
                  ),
                  ...SubscriptionCategory.values.map((category) => Padding(
                        padding: const EdgeInsets.only(left: 8.0),
                        child: FilterChip(
                          avatar: Icon(category.displayIcon, size: 16, color: category == currentCat ? theme.colorScheme.onPrimary : category.categoryDisplayIconColor(theme)),
                          label: Text(category.displayName), 
                          selected: currentCat == category,
                          onSelected: (selected) {
                            context.read<SubscriptionCubit>().filterByCategory(selected ? category : null);
                          },
                          selectedColor: category.categoryDisplayIconColor(theme), 
                          checkmarkColor: theme.colorScheme.onPrimary,
                        ),
                      )),
                ],
              ),
            ),
            const SizedBox(height: 4),
             SingleChildScrollView(
              scrollDirection: Axis.horizontal,
              child: Row(
                children: [
                   FilterChip(
                    label: const Text('All Cycles'), 
                    selected: currentBill == null,
                    onSelected: (_) => context.read<SubscriptionCubit>().clearBillingCycleFilter(),
                  ),
                  ...BillingCycle.values.where((c) => c != BillingCycle.custom).map((cycle) => Padding(
                        padding: const EdgeInsets.only(left: 8.0),
                        child: FilterChip(
                          label: Text(_getBillingCycleLabel(context, cycle)),
                          selected: currentBill == cycle,
                          onSelected: (selected) {
                             context.read<SubscriptionCubit>().filterByBillingCycle(selected ? cycle : null);
                          },
                        ),
                      )),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildLoadingShimmer(ThemeData theme) {
    return Shimmer.fromColors(
      baseColor: theme.colorScheme.surfaceContainerHighest.withOpacity(0.3), // Corrected deprecated
      highlightColor: theme.colorScheme.surfaceContainerHighest.withOpacity(0.1), // Corrected deprecated
      child: ListView(
        padding: const EdgeInsets.all(16.0),
        children: [
          Container(
            height: 130.0,
            decoration: BoxDecoration(
              color: theme.cardColor,
              borderRadius: BorderRadius.circular(12.0),
            ),
            margin: const EdgeInsets.only(bottom: 16),
          ),
          Container(height: 40, color: theme.cardColor, margin: const EdgeInsets.only(bottom:8)),
          Container(height: 40, color: theme.cardColor, margin: const EdgeInsets.only(bottom:16)),
          ...List.generate(5, (index) => Container(
            height: 90.0,
            decoration: BoxDecoration(
              color: theme.cardColor,
              borderRadius: BorderRadius.circular(12.0),
            ),
            margin: const EdgeInsets.only(bottom: 10.0),
          )),
        ],
      ),
    );
  }

  void _showSubscriptionActions(BuildContext context, ThemeData theme, SubscriptionEntity subscription) {
    app_haptics.HapticFeedback.mediumImpact();
    showModalBottomSheet(
      context: context,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(16.0)),
      ),
      builder: (builderContext) { 
        return Wrap(
          children: <Widget>[
            ListTile(
              leading: const Icon(Icons.edit_rounded),
              title: const Text('Edit Subscription'), 
              onTap: () {
                Navigator.pop(builderContext);
                context.pushNamed(
                  AppRoutes.editSubscription,
                  pathParameters: {'id': subscription.id},
                  extra: subscription,
                );
              },
            ),
            ListTile(
              leading: Icon(subscription.isActive ? Icons.pause_circle_outline_rounded : Icons.play_circle_outline_rounded),
              title: Text(subscription.isActive ? 'Pause Subscription' : 'Resume Subscription'), 
              onTap: () {
                Navigator.pop(builderContext);
                context.read<SubscriptionCubit>().toggleSubscriptionActiveStatus(subscription.id);
              },
            ),
             ListTile(
              leading: Icon(subscription.notificationsEnabled ? Icons.notifications_off_rounded : Icons.notifications_active_rounded),
              title: Text(subscription.notificationsEnabled ? 'Disable Notifications' : 'Enable Notifications'), 
              onTap: () {
                Navigator.pop(builderContext);
                context.read<SubscriptionCubit>().toggleSubscriptionNotification(subscription.id);
              },
            ),
            ListTile(
              leading: Icon(Icons.delete_forever_rounded, color: theme.colorScheme.error),
              title: Text('Delete Subscription', style: TextStyle(color: theme.colorScheme.error)), 
              onTap: () async {
                Navigator.pop(builderContext);
                final confirmDelete = await showDialog<bool>(
                  context: context, 
                  builder: (dialogContext) => AlertDialog(
                    title: const Text('Confirm Delete'), 
                    content: Text('Are you sure you want to delete "${subscription.name}"? This cannot be undone.'), 
                    actions: <Widget>[
                      TextButton(
                        child: const Text('Cancel'), 
                        onPressed: () => Navigator.of(dialogContext).pop(false),
                      ),
                      TextButton(
                        child: Text('Delete', style: TextStyle(color: theme.colorScheme.error)), 
                        onPressed: () => Navigator.of(dialogContext).pop(true),
                      ),
                    ],
                  ),
                );
                if (confirmDelete == true) {
                   if (!mounted) return; // Guard context use
                  context.read<SubscriptionCubit>().deleteSubscription(subscription.id);
                }
              },
            ),
          ],
        );
      },
    );
  }
}
// Removed duplicate CategoryDisplayExtension, use the one in subscription_card_widget.dart

===== FILE: monthly_spending_summary_card.dart =====
===== PATH: lib/features/subscriptions/presentation/widgets/monthly_spending_summary_card.dart =====

import 'package:aboapp/features/subscriptions/domain/entities/subscription_entity.dart';
import 'package:flutter/material.dart';
import 'package:intl/intl.dart'; // For number formatting

// Assuming you'll have a shared animated counter widget.
// If not, this would be a simpler Text widget.
import 'package:aboapp/widgets/animated_counter_widget.dart'; // We'll create this shared widget next

class MonthlySpendingSummaryCard extends StatelessWidget {
  final List<SubscriptionEntity> activeSubscriptions;

  const MonthlySpendingSummaryCard({
    super.key,
    required this.activeSubscriptions,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    // TODO: Replace 'de_DE' and '€' with locale/currency from SettingsCubit/Provider
    final currencyFormat = NumberFormat.currency(locale: 'de_DE', symbol: '€', decimalDigits: 2);

    final double totalMonthlySpending = activeSubscriptions.fold(
      0.0,
      (sum, sub) => sum + sub.monthlyEquivalentPrice,
    );

    final double yearlySpending = totalMonthlySpending * 12;
    final double dailyAverage = activeSubscriptions.isNotEmpty
        ? totalMonthlySpending / 30.4375 // Average days in a month
        : 0.0;

    return Card(
      elevation: 2.0, // Subtle elevation
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16.0)),
      child: Container(
        padding: const EdgeInsets.all(16.0),
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(16.0),
          gradient: LinearGradient(
            colors: [
              theme.colorScheme.primaryContainer.withOpacity(0.6),
              theme.colorScheme.primaryContainer.withOpacity(0.9),
            ],
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
          ),
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  'Monthly Spending', // TODO: Localize
                  style: theme.textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.bold,
                    color: theme.colorScheme.onPrimaryContainer,
                  ),
                ),
                Container(
                  padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                  decoration: BoxDecoration(
                    color: theme.colorScheme.primary.withOpacity(0.2),
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: Text(
                    '${activeSubscriptions.length} Active', // TODO: Localize
                    style: theme.textTheme.labelSmall?.copyWith(
                      color: theme.colorScheme.primary,
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                ),
              ],
            ),
            const SizedBox(height: 8.0),
            AnimatedCounterWidget(
              value: totalMonthlySpending,
              formatter: (value) => currencyFormat.format(value),
              style: theme.textTheme.displaySmall!.copyWith(
                color: theme.colorScheme.primary,
                fontWeight: FontWeight.bold,
              ),
              duration: const Duration(milliseconds: 700),
            ),
            Text(
              'per month', // TODO: Localize
              style: theme.textTheme.bodySmall?.copyWith(
                color: theme.colorScheme.onPrimaryContainer.withOpacity(0.8),
              ),
            ),
            const SizedBox(height: 16.0),
            const Divider(),
            const SizedBox(height: 8.0),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                _buildStatItem(
                  context,
                  theme,
                  currencyFormat,
                  label: 'Yearly Total', // TODO: Localize
                  value: yearlySpending,
                  color: theme.colorScheme.onPrimaryContainer,
                ),
                _buildStatItem(
                  context,
                  theme,
                  currencyFormat,
                  label: 'Daily Average', // TODO: Localize
                  value: dailyAverage,
                  color: theme.colorScheme.onPrimaryContainer,
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildStatItem(
    BuildContext context,
    ThemeData theme,
    NumberFormat currencyFormat, {
    required String label,
    required double value,
    required Color color,
  }) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          label,
          style: theme.textTheme.labelSmall?.copyWith(
            color: color.withOpacity(0.8),
          ),
        ),
        const SizedBox(height: 2.0),
        AnimatedCounterWidget(
          value: value,
          formatter: (val) => currencyFormat.format(val),
          style: theme.textTheme.titleSmall!.copyWith(
            fontWeight: FontWeight.w600,
            color: color,
          ),
          duration: const Duration(milliseconds: 600),
        ),
      ],
    );
  }
}

===== FILE: subscription_card_widget.dart =====
===== PATH: lib/features/subscriptions/presentation/widgets/subscription_card_widget.dart =====

import 'package:aboapp/core/theme/app_colors.dart'; // Import AppColors
import 'package:aboapp/features/subscriptions/domain/entities/subscription_entity.dart';
import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';

class SubscriptionCardWidget extends StatelessWidget {
  final SubscriptionEntity subscription;
  final VoidCallback? onTap;
  final VoidCallback? onLongPress;

  const SubscriptionCardWidget({
    super.key,
    required this.subscription,
    this.onTap,
    this.onLongPress,
  });

  String _getBillingCycleShortLabel(BillingCycle cycle) {
    // TODO: Localize
    switch (cycle) {
      case BillingCycle.weekly: return 'wk';
      case BillingCycle.monthly: return 'mo';
      case BillingCycle.quarterly: return 'qtr';
      case BillingCycle.biAnnual: return '6mo';
      case BillingCycle.yearly: return 'yr';
      case BillingCycle.custom: return 'cust';
    }
  }

  Color _getDaysUntilBillingColor(BuildContext context, int days) {
    final theme = Theme.of(context);
    if (days < 0) return theme.colorScheme.error; 
    if (days <= 3) return theme.colorScheme.error.withOpacity(0.8); // Kept withOpacity
    if (days <= 7) return AppColors.warning.withOpacity(0.9); // Used AppColors.warning, Kept withOpacity
    return theme.colorScheme.onSurfaceVariant;
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    // TODO: Use locale from SettingsProvider
    final currencyFormat = NumberFormat.currency(locale: 'de_DE', symbol: '€', decimalDigits: 2);
    final dateFormat = DateFormat('dd MMM, yyyy'); // TODO: Localize

    final daysUntil = subscription.daysUntilBilling;
    final String daysLabel = daysUntil < 0
        ? '${daysUntil.abs()} days ago' // TODO: Localize
        : daysUntil == 0
            ? 'Today' // TODO: Localize
            : daysUntil == 1
                ? 'Tomorrow' // TODO: Localize
                : '$daysUntil days'; // TODO: Localize

    return Card(
      margin: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 6.0),
      clipBehavior: Clip.antiAlias,
      child: InkWell(
        onTap: onTap,
        onLongPress: onLongPress,
        child: Padding(
          padding: const EdgeInsets.all(12.0),
          child: Row(
            children: [
              _buildLogo(context, theme),
              const SizedBox(width: 12.0),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      subscription.name,
                      style: theme.textTheme.titleMedium?.copyWith(fontWeight: FontWeight.w600),
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                    ),
                    const SizedBox(height: 2.0),
                    Text(
                      subscription.category.displayName, // Using extension
                      style: theme.textTheme.bodySmall?.copyWith(
                        color: theme.colorScheme.onSurfaceVariant,
                      ),
                    ),
                    if (subscription.isInTrial) ...[
                      const SizedBox(height: 4.0),
                      Container(
                        padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                        decoration: BoxDecoration(
                          color: theme.colorScheme.tertiaryContainer,
                          borderRadius: BorderRadius.circular(6),
                        ),
                        child: Text(
                          'TRIAL', // TODO: Localize
                          style: theme.textTheme.labelSmall?.copyWith(
                            color: theme.colorScheme.onTertiaryContainer,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                      ),
                    ],
                  ],
                ),
              ),
              const SizedBox(width: 12.0),
              Column(
                crossAxisAlignment: CrossAxisAlignment.end,
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Text(
                    '${currencyFormat.format(subscription.price)} / ${_getBillingCycleShortLabel(subscription.billingCycle)}',
                    style: theme.textTheme.titleSmall?.copyWith(
                      fontWeight: FontWeight.bold,
                      color: theme.colorScheme.primary,
                    ),
                  ),
                  const SizedBox(height: 4.0),
                  Row(
                    children: [
                      Icon(
                        Icons.calendar_today_rounded,
                        size: 12,
                        color: _getDaysUntilBillingColor(context, daysUntil),
                      ),
                      const SizedBox(width: 4),
                      Text(
                        dateFormat.format(subscription.nextBillingDate),
                        style: theme.textTheme.bodySmall?.copyWith(
                          color: _getDaysUntilBillingColor(context, daysUntil),
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                    ],
                  ),
                   Text(
                      daysLabel,
                      style: theme.textTheme.labelSmall?.copyWith(
                        color: _getDaysUntilBillingColor(context, daysUntil),
                        fontStyle: FontStyle.italic,
                      ),
                    ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildLogo(BuildContext context, ThemeData theme) {
    final hasRemoteLogo = subscription.logoUrl != null && subscription.logoUrl!.isNotEmpty;
    final Color bgColor = subscription.color ?? subscription.category.categoryDisplayIconColor(theme).withOpacity(0.1); // Kept withOpacity
    final Color fgColor = subscription.color != null ? (ThemeData.estimateBrightnessForColor(subscription.color!) == Brightness.dark ? Colors.white : Colors.black) : subscription.category.categoryDisplayIconColor(theme);


    return Container(
      width: 52,
      height: 52,
      decoration: BoxDecoration(
        color: bgColor,
        borderRadius: BorderRadius.circular(10.0),
      ),
      child: ClipRRect( 
        borderRadius: BorderRadius.circular(10.0),
        child: hasRemoteLogo
            ? CachedNetworkImage(
                imageUrl: subscription.logoUrl!,
                width: 52,
                height: 52,
                fit: BoxFit.contain, 
                placeholder: (context, url) => Center(
                  child: Icon(
                    subscription.category.displayIcon, // Using extension
                    color: fgColor.withOpacity(0.5), // Kept withOpacity
                    size: 28,
                  ),
                ),
                errorWidget: (context, url, error) => Center(
                  child: Icon(
                    subscription.category.displayIcon, // Using extension
                    color: fgColor.withOpacity(0.7), // Kept withOpacity
                    size: 28,
                  ),
                ),
              )
            : Center( 
                child: Text(
                  subscription.name.isNotEmpty ? subscription.name[0].toUpperCase() : '?',
                  style: theme.textTheme.titleLarge?.copyWith(color: fgColor, fontWeight: FontWeight.bold),
                ),
              ),
      ),
    );
  }
}

// Centralized display helpers for SubscriptionCategory
extension CategoryDisplayHelpers on SubscriptionCategory {
   Color categoryDisplayIconColor(ThemeData theme) {
    switch (this) {
      case SubscriptionCategory.streaming: return AppColors.catStreaming;
      case SubscriptionCategory.software: return AppColors.catSoftware;
      case SubscriptionCategory.gaming: return AppColors.catGaming;
      case SubscriptionCategory.fitness: return AppColors.catFitness;
      case SubscriptionCategory.music: return AppColors.catMusic;
      case SubscriptionCategory.news: return AppColors.catNews;
      case SubscriptionCategory.cloud: return AppColors.catCloud;
      case SubscriptionCategory.utilities: return Colors.teal.shade400; // Example
      case SubscriptionCategory.education: return Colors.indigo.shade400; // Example
      case SubscriptionCategory.other: return AppColors.catOther;
      // No default because all enum values are covered.
    }
  }

  String get displayName {
    // TODO: Localize these
    switch (this) {
      case SubscriptionCategory.streaming: return 'Streaming';
      case SubscriptionCategory.software: return 'Software';
      case SubscriptionCategory.gaming: return 'Gaming';
      case SubscriptionCategory.fitness: return 'Fitness';
      case SubscriptionCategory.music: return 'Music';
      case SubscriptionCategory.news: return 'News & Mags';
      case SubscriptionCategory.cloud: return 'Cloud Storage';
      case SubscriptionCategory.utilities: return 'Utilities';
      case SubscriptionCategory.education: return 'Education';
      case SubscriptionCategory.other: return 'Other';
    }
  }

  IconData get displayIcon {
     switch (this) {
      case SubscriptionCategory.streaming: return Icons.live_tv_rounded;
      case SubscriptionCategory.software: return Icons.widgets_outlined;
      case SubscriptionCategory.gaming: return Icons.gamepad_outlined;
      case SubscriptionCategory.fitness: return Icons.fitness_center_rounded;
      case SubscriptionCategory.music: return Icons.music_note_rounded;
      case SubscriptionCategory.news: return Icons.article_outlined;
      case SubscriptionCategory.cloud: return Icons.cloud_outlined;
      case SubscriptionCategory.utilities: return Icons.lightbulb_outline_rounded;
      case SubscriptionCategory.education: return Icons.school_outlined;
      case SubscriptionCategory.other: return Icons.category_rounded;
    }
  }
}

===== FILE: main.dart =====
===== PATH: lib/main.dart =====

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:aboapp/app.dart'; 
import 'package:aboapp/core/di/injection.dart'; 
// import 'package:flutter_bloc/flutter_bloc.dart'; // Unused import

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await configureDependencies();

  await SystemChrome.setPreferredOrientations([
    DeviceOrientation.portraitUp,
    DeviceOrientation.portraitDown,
  ]);

  SystemChrome.setSystemUIOverlayStyle(
    const SystemUiOverlayStyle(
      statusBarColor: Colors.transparent, 
      statusBarIconBrightness: Brightness.dark, 
      systemNavigationBarColor: Colors.transparent, 
      systemNavigationBarIconBrightness: Brightness.dark, 
      systemNavigationBarDividerColor: Colors.transparent,
    ),
  );

  runApp(const AboApp());
}

===== FILE: main_container_screen.dart =====
===== PATH: lib/main_container_screen.dart =====

import 'package:aboapp/core/routing/app_router.dart';
// import 'package:aboapp/features/settings/presentation/cubit/settings_cubit.dart'; // Unused
// import 'package:aboapp/features/subscriptions/presentation/screens/add_edit_subscription_screen.dart'; // Unused
import 'package:flutter/material.dart';
// import 'package:flutter_bloc/flutter_bloc.dart'; // Unused
import 'package:go_router/go_router.dart';
import 'package:aboapp/core/utils/haptic_feedback.dart' as app_haptics;


class MainContainerScreen extends StatefulWidget {
  final Widget child; 
  final String location; 

  const MainContainerScreen({
    super.key,
    required this.child,
    required this.location,
  });

  @override
  State<MainContainerScreen> createState() => _MainContainerScreenState();
}

class _MainContainerScreenState extends State<MainContainerScreen> {
  late PageController _pageController;
  int _currentPageIndex = 0;

  // static const List<String> _pageLocations = [ // Unused field
  //   AppRoutes.home, 
  //   "${AppRoutes.home}/${AppRoutes.statistics}", 
  //   "${AppRoutes.home}/${AppRoutes.settings}",   
  // ];

  @override
  void initState() {
    super.initState();
    _currentPageIndex = _calculatePageIndex(widget.location);
    _pageController = PageController(initialPage: _currentPageIndex);
  }

  @override
  void didUpdateWidget(MainContainerScreen oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.location != oldWidget.location) {
      final newIndex = _calculatePageIndex(widget.location);
      if (newIndex != _currentPageIndex) {
        _currentPageIndex = newIndex;
        if (_pageController.hasClients && _pageController.page?.round() != _currentPageIndex) {
             _pageController.jumpToPage(_currentPageIndex);
        }
      }
    }
  }

  int _calculatePageIndex(String location) {
    if (location.startsWith("${AppRoutes.home}/${AppRoutes.statistics}")) { // Used interpolation
      return 1;
    } else if (location.startsWith("${AppRoutes.home}/${AppRoutes.settings}")) { // Used interpolation
      return 2;
    }
    return 0; 
  }

  // _onPageChanged removed as it was unused

  void _onBottomNavItemTapped(int index) {
     if (_currentPageIndex == index) return;
    
    // Navigate using GoRouter when BottomAppBar item is tapped
    // This keeps the URL in sync and GoRouter handles updating the ShellRoute's child
    app_haptics.HapticFeedback.selectionClick();
    switch (index) {
      case 0:
        context.goNamed(AppRoutes.home); 
        break;
      case 1:
        context.goNamed(AppRoutes.statistics);
        break;
      case 2:
        context.goNamed(AppRoutes.settings);
        break;
      case 3: // For 'About' item
        // Example action: Show a dialog or navigate to an 'About' screen (if defined)
        showDialog(
          context: context,
          builder: (ctx) => AlertDialog(
            title: const Text('About AboApp'), // TODO: Localize
            content: const Text('Version 3.0.0\nSubscription Management Made Easy.'), // TODO: Localize
            actions: [
              TextButton(
                onPressed: () => Navigator.of(ctx).pop(),
                child: const Text('Close'), // TODO: Localize
              )
            ],
          ),
        );
        // Do not change _currentPageIndex here if it's just a dialog
        // If it were a separate page in the PageView, then update index and use _pageController.
        return; // Return early to prevent _pageController interaction for dialogs
    }
    
    // Animate page controller only if it's a main navigation item
    if (index <= 2 && _pageController.hasClients) {
       _pageController.animateToPage(
        index,
        duration: const Duration(milliseconds: 300),
        curve: Curves.easeInOut,
      );
    }
     // No need to call setState here if GoRouter handles the rebuild via location change
  }
  
  @override
  void dispose() {
    _pageController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Scaffold(
      body: widget.child, 
      floatingActionButton: _currentPageIndex == 0 
          ? FloatingActionButton(
              onPressed: () {
                app_haptics.HapticFeedback.lightImpact();
                context.pushNamed(AppRoutes.addSubscription);
              },
              tooltip: 'Add Subscription', 
              child: const Icon(Icons.add_rounded),
            )
          : null,
      floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked,
      bottomNavigationBar: BottomAppBar(
        shape: const CircularNotchedRectangle(), 
        notchMargin: 6.0,
        color: theme.bottomNavigationBarTheme.backgroundColor ?? theme.colorScheme.surface,
        elevation: theme.bottomNavigationBarTheme.elevation ?? 8.0,
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceAround,
          children: <Widget>[
            _buildBottomNavItem(
              context: context,
              icon: Icons.list_alt_rounded,
              label: 'Subscriptions', 
              index: 0,
              isSelected: _currentPageIndex == 0,
              onTap: () => _onBottomNavItemTapped(0),
            ),
            _buildBottomNavItem(
              context: context,
              icon: Icons.bar_chart_rounded,
              label: 'Statistics', 
              index: 1,
              isSelected: _currentPageIndex == 1,
              onTap: () => _onBottomNavItemTapped(1),
            ),
            const SizedBox(width: 40), 
            _buildBottomNavItem(
              context: context,
              icon: Icons.settings_rounded,
              label: 'Settings', 
              index: 2,
              isSelected: _currentPageIndex == 2,
              onTap: () => _onBottomNavItemTapped(2),
            ),
             _buildBottomNavItem( 
              context: context,
              icon: Icons.info_outline_rounded,
              label: 'About', 
              index: 3, 
              isSelected: false, // 'About' is not a page in PageView, so never "selected" in that sense
              onTap: () => _onBottomNavItemTapped(3),
            ),
          ],
        ),
      ),
    );
  }

   Widget _buildBottomNavItem({
    required BuildContext context,
    required IconData icon,
    required String label,
    required int index,
    required bool isSelected,
    required VoidCallback onTap,
  }) {
    final theme = Theme.of(context);
    final color = isSelected
        ? theme.bottomNavigationBarTheme.selectedItemColor ?? theme.colorScheme.primary
        : theme.bottomNavigationBarTheme.unselectedItemColor ?? theme.colorScheme.onSurfaceVariant;

    return Expanded(
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(24.0), 
        child: Padding(
          padding: const EdgeInsets.symmetric(vertical: 8.0),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            mainAxisAlignment: MainAxisAlignment.center,
            children: <Widget>[
              Icon(icon, color: color, size: 24),
              const SizedBox(height: 2),
              Text(
                label,
                style: (isSelected
                        ? theme.bottomNavigationBarTheme.selectedLabelStyle
                        : theme.bottomNavigationBarTheme.unselectedLabelStyle)
                    ?.copyWith(color: color, fontSize: 10), 
                overflow: TextOverflow.ellipsis,
              ),
            ],
          ),
        ),
      ),
    );
  }
}

===== FILE: animated_counter_widget.dart =====
===== PATH: lib/widgets/animated_counter_widget.dart =====

import 'package:flutter/material.dart';
// import 'dart:math' as math; // Unused import

class AnimatedCounterWidget extends StatelessWidget {
  final double value;
  final String Function(double) formatter;
  final TextStyle style;
  final Duration duration;
  final Curve curve;
  final bool useFlipAnimation; 

  const AnimatedCounterWidget({
    super.key,
    required this.value,
    required this.formatter,
    required this.style,
    this.duration = const Duration(milliseconds: 500),
    this.curve = Curves.easeOutCubic,
    this.useFlipAnimation = false, 
  });

  @override
  Widget build(BuildContext context) {
    if (useFlipAnimation) {
      return TweenAnimationBuilder<double>(
        tween: Tween<double>(begin: 0, end: value), 
        duration: duration,
        curve: curve,
        builder: (context, animatedValue, child) {
          return Text(formatter(animatedValue), style: style);
        },
      );
    } else {
      return TweenAnimationBuilder<double>(
        tween: Tween<double>(begin: _getBeginValue(), end: value),
        duration: duration,
        curve: curve,
        builder: (context, animatedValue, child) {
          return Text(formatter(animatedValue), style: style);
        },
      );
    }
  }

  double _getBeginValue() {
    return 0.0; 
  }
}

===== FILE: empty_state_widget.dart =====
===== PATH: lib/widgets/empty_state_widget.dart =====

import 'package:flutter/material.dart';

class EmptyStateWidget extends StatelessWidget {
  final IconData icon;
  final String title;
  final String message;
  final VoidCallback? onRetry;
  final String? retryText;

  const EmptyStateWidget({
    super.key,
    required this.icon,
    required this.title,
    required this.message,
    this.onRetry,
    this.retryText,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(32.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          crossAxisAlignment: CrossAxisAlignment.center,
          children: <Widget>[
            Icon(
              icon,
              size: 72,
              color: theme.colorScheme.onSurfaceVariant.withOpacity(0.6), // Kept withOpacity
            ),
            const SizedBox(height: 24),
            Text(
              title,
              style: theme.textTheme.headlineSmall?.copyWith(
                color: theme.colorScheme.onSurface,
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 12),
            Text(
              message,
              style: theme.textTheme.bodyMedium?.copyWith(
                color: theme.colorScheme.onSurfaceVariant,
              ),
              textAlign: TextAlign.center,
            ),
            if (onRetry != null) ...[
              const SizedBox(height: 24),
              ElevatedButton.icon(
                icon: const Icon(Icons.refresh_rounded),
                label: Text(retryText ?? 'Try Again'), 
                onPressed: onRetry,
                style: ElevatedButton.styleFrom(
                  padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }
}

===== FILE: pubspec.yaml =====
===== PATH: pubspec.yaml =====

name: aboapp
description: "A Flutter app for subscription management, refactored for clarity and maintainability."
publish_to: 'none' # Prevent accidental publishing

version: 3.0.0+1 # Starting fresh version for the refactor

environment:
  sdk: '>=3.3.0 <4.0.0' # Targeting a recent Dart SDK

dependencies:
  flutter:
    sdk: flutter
  flutter_localizations: # For internationalization
    sdk: flutter

  # State Management
  flutter_bloc: ^8.1.6 

  # Dependency Injection
  get_it: ^7.7.0
  injectable: ^2.5.0

  # Immutable Data Classes & Serialization
  freezed_annotation: ^2.4.1
  json_annotation: ^4.9.0

  # Routing
  go_router: ^14.2.0 

  # UI & Utility
  intl: ^0.19.0 
  uuid: ^4.4.0 
  cached_network_image: ^3.3.1 
  fl_chart: ^0.68.0 
  shimmer: ^3.0.0 
  flutter_native_splash: ^2.4.0 
  cupertino_icons: ^1.0.8 
  animations: ^2.0.11
  collection: ^1.18.0 # Added collection package

  # Local Storage
  shared_preferences: ^2.2.3

  # Local Notifications (if reminders are a feature)
  # flutter_local_notifications: ^17.0.0 

dev_dependencies:
  flutter_test:
    sdk: flutter
  
  flutter_lints: ^4.0.0 
  build_runner: ^2.4.11
  freezed: ^2.5.2 
  json_serializable: ^6.8.0 
  injectable_generator: ^2.5.0 
  go_router_builder: ^2.7.0 

flutter:
  uses-material-design: true

  assets:
    # Ensure these directories exist in your project's `assets` folder
    # - assets/images/ # For general images, app logo, onboarding illustrations
    # - assets/icons/  # For custom SVG or PNG icons if any
    - assets/l10n/ # For localization files

  fonts:
    - family: Inter
      fonts:
        - asset: assets/fonts/Inter-Regular.ttf
        - asset: assets/fonts/Inter-Medium.ttf
          weight: 500
        - asset: assets/fonts/Inter-SemiBold.ttf
          weight: 600
        - asset: assets/fonts/Inter-Bold.ttf
          weight: 700

flutter_native_splash:
  color: "#121212" 
  image: assets/images/app_logo_splash.png 
  android_12:
    color: "#121212"
    image: assets/images/app_logo_splash.png
  fullscreen: true

===== FILE: README.md =====
===== PATH: README.md =====

# aboapp_v4

A new Flutter project.

## Getting Started

This project is a starting point for a Flutter application.

A few resources to get you started if this is your first Flutter project:

- [Lab: Write your first Flutter app](https://docs.flutter.dev/get-started/codelab)
- [Cookbook: Useful Flutter samples](https://docs.flutter.dev/cookbook)

For help getting started with Flutter development, view the
[online documentation](https://docs.flutter.dev/), which offers tutorials,
samples, guidance on mobile development, and a full API reference.


